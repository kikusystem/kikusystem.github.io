{"title":"加密与安全","uid":"59350d812f080a56659be6ee1dae0a2a","slug":"加密与安全","date":"2022-10-24T07:35:31.000Z","updated":"2022-10-27T01:43:20.270Z","comments":true,"path":"api/articles/加密与安全.json","keywords":null,"cover":"https://pic1.zhimg.com/50/v2-70f55a0cc8ae4187a3072c1a8234cd67_hd.jpg","content":"<h1 id=\"加密与安全\"><a href=\"#加密与安全\" class=\"headerlink\" title=\"加密与安全\"></a>加密与安全</h1><h2 id=\"编码算法\"><a href=\"#编码算法\" class=\"headerlink\" title=\"编码算法\"></a>编码算法</h2><p>ASCII码就是一种编码，字母A的编码是16进制的0x41，字母B是0x42，以此类推：</p>\n<table>\n<thead>\n<tr>\n<th>字母</th>\n<th>ASCII编码</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>A</td>\n<td>0x41</td>\n</tr>\n<tr>\n<td>B</td>\n<td>0x42</td>\n</tr>\n<tr>\n<td>C</td>\n<td>0x43</td>\n</tr>\n<tr>\n<td>D</td>\n<td>0x44</td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n</tr>\n</tbody></table>\n<p>因为ASCII编码最多只能有127个字符，要相对更多的文字进行编码，就需要用Unicode。而中文的“中”编码就是0x4e2d，使用UTF-8则需要3个字节编码。</p>\n<table>\n<thead>\n<tr>\n<th>汉字</th>\n<th>Unicode编码</th>\n<th>UTF-8编码</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>中</td>\n<td>0x4e2d</td>\n<td>0xe4b8ad</td>\n</tr>\n<tr>\n<td>文</td>\n<td>0x6587</td>\n<td>0xe69687</td>\n</tr>\n<tr>\n<td>编</td>\n<td>0x7f16</td>\n<td>0xe7bc96</td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n<td>…</td>\n</tr>\n</tbody></table>\n<p>因此，最简单的编码是直接给每个字符制定一个若干字节的整数，复杂一点的编码就需要根据一个已有的编码推算出来。</p>\n<p>比如UTF-8编码，它是一个不定长编码，但可以从给定字符的Unicode编码推算出来。</p>\n<h3 id=\"URL编码\"><a href=\"#URL编码\" class=\"headerlink\" title=\"URL编码\"></a>URL编码</h3><p>URL编码是浏览器发送数据给服务器时使用的编码，它通常附加在URL的参数部分，例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">https:&#x2F;&#x2F;www.baidu.com&#x2F;s?wd&#x3D;%E4%B8%AD%E6%96%87</code></pre>\n\n<p>之所以需要URL编码，是因为处于兼容性考虑，很多服务器只识别ASCII字符。如果URL中包含中文、日文这些非ASCII字符时，URL编码有一套规则：</p>\n<ul>\n<li>如果字符时A<del>Z，a</del>z，0~9以及-、_、·、*，则保持不变；</li>\n<li>如果是其他字符，先转换为UTF-8编码，然后对每个字节以%XX表示。</li>\n</ul>\n<p>例如：字符“中”的UTF-8编码是0xe4b8ad，因此，它的URL编码是%E4%B8%AD。<strong>URL编码总是大写</strong>。</p>\n<p><strong>注意：URL编码是编码算法，不是加密算法。URL编码的目的是吧任意文件数据编码为%前缀表示的文本，编码后的文本仅包含A<del>Z，a</del>z，0~9，-，_，·，*和%，便于浏览器和服务器处理。</strong></p>\n<h3 id=\"Base64编码\"><a href=\"#Base64编码\" class=\"headerlink\" title=\"Base64编码\"></a>Base64编码</h3><p>URL编码是对字符进行编码，表示成%xx的形式，而Base64编码是对二进制数据进行编码，表示成文本格式。</p>\n<p>Base64编码就是通过64个可打印字符来表示二进制数据的方法，且这64个字符中只包含A<del>Z、a</del>z、0~9、+、/、=这些字符。它的原理是把3字节的二进制数据按6bit一组，用4个int整数表示，然后查表，把int整数用索引对应到字符，得到编码后的字符串。</p>\n<p><strong>Base64编码表</strong></p>\n<table>\n<thead>\n<tr>\n<th>码值</th>\n<th>字符</th>\n<th>码值</th>\n<th>字符</th>\n<th>码值</th>\n<th>字符</th>\n<th>码值</th>\n<th>字符</th>\n<th>码值</th>\n<th>字符</th>\n<th>码值</th>\n<th>字符</th>\n<th>码值</th>\n<th>字符</th>\n<th>码值</th>\n<th>字符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>A</td>\n<td>8</td>\n<td>I</td>\n<td>16</td>\n<td>Q</td>\n<td>24</td>\n<td>Y</td>\n<td>32</td>\n<td>g</td>\n<td>40</td>\n<td>o</td>\n<td>48</td>\n<td>w</td>\n<td>56</td>\n<td>4</td>\n</tr>\n<tr>\n<td>1</td>\n<td>B</td>\n<td>9</td>\n<td>J</td>\n<td>17</td>\n<td>R</td>\n<td>25</td>\n<td>Z</td>\n<td>33</td>\n<td>h</td>\n<td>41</td>\n<td>p</td>\n<td>49</td>\n<td>x</td>\n<td>57</td>\n<td>5</td>\n</tr>\n<tr>\n<td>2</td>\n<td>C</td>\n<td>10</td>\n<td>K</td>\n<td>18</td>\n<td>S</td>\n<td>26</td>\n<td>a</td>\n<td>34</td>\n<td>i</td>\n<td>42</td>\n<td>q</td>\n<td>50</td>\n<td>y</td>\n<td>58</td>\n<td>6</td>\n</tr>\n<tr>\n<td>3</td>\n<td>D</td>\n<td>11</td>\n<td>L</td>\n<td>19</td>\n<td>T</td>\n<td>27</td>\n<td>b</td>\n<td>35</td>\n<td>j</td>\n<td>43</td>\n<td>r</td>\n<td>51</td>\n<td>z</td>\n<td>59</td>\n<td>7</td>\n</tr>\n<tr>\n<td>4</td>\n<td>E</td>\n<td>12</td>\n<td>M</td>\n<td>20</td>\n<td>U</td>\n<td>28</td>\n<td>c</td>\n<td>36</td>\n<td>k</td>\n<td>44</td>\n<td>s</td>\n<td>52</td>\n<td>0</td>\n<td>60</td>\n<td>8</td>\n</tr>\n<tr>\n<td>5</td>\n<td>F</td>\n<td>13</td>\n<td>N</td>\n<td>21</td>\n<td>V</td>\n<td>29</td>\n<td>d</td>\n<td>37</td>\n<td>l</td>\n<td>45</td>\n<td>t</td>\n<td>53</td>\n<td>1</td>\n<td>61</td>\n<td>9</td>\n</tr>\n<tr>\n<td>6</td>\n<td>G</td>\n<td>14</td>\n<td>O</td>\n<td>22</td>\n<td>W</td>\n<td>30</td>\n<td>e</td>\n<td>38</td>\n<td>m</td>\n<td>46</td>\n<td>u</td>\n<td>54</td>\n<td>2</td>\n<td>62</td>\n<td>+</td>\n</tr>\n<tr>\n<td>7</td>\n<td>H</td>\n<td>15</td>\n<td>P</td>\n<td>23</td>\n<td>X</td>\n<td>31</td>\n<td>f</td>\n<td>39</td>\n<td>n</td>\n<td>47</td>\n<td>v</td>\n<td>55</td>\n<td>3</td>\n<td>63</td>\n<td>/</td>\n</tr>\n</tbody></table>\n<p>注意：由于base64编码用了8位字符来表示信息中的6个位，所以base64编码字符串大约比原始值扩大了33%。</p>\n<p><img src=\"img/jiami1.png\" alt=\"image-20221024160611969\"></p>\n<p>可以看到“Son”通过Base64编码转换成了“U29u”。这是刚刚好的情况，3个ASCII字符刚好转换成对应的4个Base64字符。但是，当需要转换的字符数不是3的倍数的情况下该怎么办呢？Base64规定，当需要转换的字符不是3的倍数时，一律采用补0的方式凑足3的倍数，具体如下所示：</p>\n<p><img src=\"img/jiami2.png\" alt=\"image-20221024161223518\"></p>\n<p>每6个Bit为一组，第一组转换后为字符“U”，第二组末尾补4个0转换后为字符“w”。剩下的使用“=”替代。即字符”S“通过Base64编码后为Uw==。这就是Base64的编码过程。</p>\n<p>如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字符怎么办？Base64用\\x00字节在末尾补足后，再在编码的末尾加上1个或2个=号，表示不了多少字节，解码的时候，会自动去掉。</p>\n<p>Base64编码的目的是把二进制数据变成文本格式，这样在很多文本中就可以处理二进制数据。例如，电子邮件协议就是文本协议，如果要在电子邮件中添加一个二进制文件，就可以用Base64编码，然后以文本的形式传送。</p>\n<p>Base64编码的确定是传输效率会降低，因为它把原始数据的长度增加了1/3。</p>\n<p>和URL编码一样，Base64编码是一种编码算法，不是加密算法。如果把Base64的64个字符编码换成32个、48个或者58个，就可以使用Base32编码，Base48编码和Base58编码。字符越少，编码的效率就会越低。</p>\n<h2 id=\"哈希算法\"><a href=\"#哈希算法\" class=\"headerlink\" title=\"哈希算法\"></a>哈希算法</h2><p>哈希算法（Hash）又称摘要算法（Digest）它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。</p>\n<p>哈希算法最重要的特点就是：</p>\n<ul>\n<li>相同的输入一定得到相同的输出；</li>\n<li>不同的输入大概率得不到不同的输出。</li>\n</ul>\n<p>哈希算法的目的就是为了验证原始数据是否被篡改。</p>\n<p>Java字符串的haseCode()就是一个哈希算法，它的输入是任意字符串，输出是固定的4字节int整数：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&quot;hello&quot;.hashCode();\t\t&#x2F;&#x2F;0x5e918d2</code></pre>\n\n<p>两个相同的字符串永远会计算出相同的hashCode，否则基于hashCode定位的HashMap就无法正常工作。这也是为什么当我们自定义一个class时，覆写equals()方法时我们必须正确覆写hashCode()方法。</p>\n<h3 id=\"哈希碰撞\"><a href=\"#哈希碰撞\" class=\"headerlink\" title=\"哈希碰撞\"></a>哈希碰撞</h3><p>哈希碰撞是指，两个不同的输入得到了相同的输出：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&quot;AaAaAa&quot;.hashCode(); &#x2F;&#x2F; 0x7460e8c0\n&quot;BBAaBB&quot;.hashCode(); &#x2F;&#x2F; 0x7460e8c0</code></pre>\n\n<p><strong>碰撞时不可避免的。</strong>因为输出的字节长度是固定的，String的hashCode()输出是4字节证书，最多只有4294967296种输出，但输入的数据长度是不固定的，有无数种输入。所以，哈希算法是把一个无限的输入集合映射到一个有线的输出集合，必然会产生碰撞。</p>\n<p>我们担心的不应该是碰撞，而是碰撞的概率，因为碰撞概率的高低关系到哈希算法的安全性。一个安全的哈希算法必须满足：</p>\n<ul>\n<li>碰撞概率低；</li>\n<li>不能猜测输出。</li>\n</ul>\n<p>不能猜测输出是指，输入的任意一个bit的变化会造成输出完全不同，这样就很难从输出反推输入（只能依靠暴力穷举）。假设一种哈希算法有如下规律：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">hashA(&quot;java001&quot;) &#x3D; &quot;123456&quot;\nhashA(&quot;java002&quot;) &#x3D; &quot;123457&quot;\nhashA(&quot;java003&quot;) &#x3D; &quot;123458&quot;</code></pre>\n\n<p>那么很容易从123459反推输入，这种哈希算法就不安全。安全的哈希算法从输出是看不出任何规律的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">hashB(&quot;java001&quot;) &#x3D; &quot;123456&quot;\nhashB(&quot;java002&quot;) &#x3D; &quot;580271&quot;\nhashB(&quot;java003&quot;) &#x3D; ???</code></pre>\n\n<p>常用的哈希算法有：</p>\n<table>\n<thead>\n<tr>\n<th>算法</th>\n<th>输出长度（位）</th>\n<th>输出长度（字节）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>MD5</td>\n<td>128bits</td>\n<td>16bytes</td>\n</tr>\n<tr>\n<td>SHA-1</td>\n<td>160bits</td>\n<td>20bytes</td>\n</tr>\n<tr>\n<td>RipeMD-160</td>\n<td>160bits</td>\n<td>20bytes</td>\n</tr>\n<tr>\n<td>SHA-256</td>\n<td>256bits</td>\n<td>32bytes</td>\n</tr>\n<tr>\n<td>SHA-512</td>\n<td>512bits</td>\n<td>64bytes</td>\n</tr>\n</tbody></table>\n<p>根据碰撞概率，哈希算法的输出长度越长，就越难产生碰撞，也就越安全。</p>\n<h3 id=\"MD5和SHA-1算法：\"><a href=\"#MD5和SHA-1算法：\" class=\"headerlink\" title=\"MD5和SHA-1算法：\"></a>MD5和SHA-1算法：</h3><p>java标准库提供了常用的哈希算法，并且有一套统一的接口。以MD5算法为例：</p>\n<h4 id=\"基本步骤：\"><a href=\"#基本步骤：\" class=\"headerlink\" title=\"基本步骤：\"></a>基本步骤：</h4><ol>\n<li>创建爱你MessageDiges实例</li>\n<li>反复调用update(byte[])输入数据</li>\n<li>调用digest()方法获得byte[]数组表示的摘要</li>\n<li>将结果转换为十六进制的字符串</li>\n</ol>\n<h4 id=\"代码示例：\"><a href=\"#代码示例：\" class=\"headerlink\" title=\"代码示例：\"></a>代码示例：</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n \npublic class Demo02 &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tString password &#x3D; &quot;scderfg&quot;;\n\t\t\n\t\ttry &#123;\n\t\t\t&#x2F;&#x2F; 根据当前算法，获取加密工具对象(摘要)\n\t\t\tMessageDigest message &#x3D; MessageDigest.getInstance(&quot;MD5&quot;);\n\t\t\t\n\t\t\t&#x2F;&#x2F; 更新原始数据\n\t\t\tmessage.update(password.getBytes());\n            \n            &#x2F;&#x2F; 完成hash()计算\n            byte[] resultByteArray &#x3D; digest.digest();\n\t\t\t\n\t\t\t&#x2F;&#x2F; 加密后的字节数组，转换字符串\n\t\t\tStringBuilder result &#x3D; new StringBuilder();\n\t\t\t\n\t\t\tfor(byte bite : resultByteArray) &#123;\n\t\t\t\tresult.append(String.format(&quot;%02x&quot;, bite));\n\t\t\t&#125;\n\t\t\t\n\t\t\tSystem.out.println(result);\n\t\t\tSystem.out.println(result.length());\n\t\t\t \n\t\t&#125; catch (NoSuchAlgorithmException e) &#123;\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<p>在Java中使用MD5和SHA-1完全一样，只需要把算法名称改为“SHA-1”。</p>\n<p>类似的，计算SHA-256，我们只需要传入名称“SHA-256”；计算SHA-512，只需要传入名称“SHA-512”。</p>\n<h3 id=\"RipeMD-160\"><a href=\"#RipeMD-160\" class=\"headerlink\" title=\"RipeMD-160\"></a>RipeMD-160</h3><p>RipeMD-160是一种基于（Mekle-Damgard结构的加密哈希函数，它是比特币标准之一。RipeMD-160是RTPEND算法的增强版本，RipeMD-160算法可以产生出160位的哈希摘要。</p>\n<h4 id=\"基本步骤：-1\"><a href=\"#基本步骤：-1\" class=\"headerlink\" title=\"基本步骤：\"></a>基本步骤：</h4><ol>\n<li>把BouncyCastle提供的bcprov-jdk15on-1.70.jar添加到classpath</li>\n<li>Java标准库的java.security包提供了一种标准机制，允许第三番提供商无缝接入。我们要使用BouncyCastle提供的RipeMD160算法，需要先把BouncyCastle注册一下</li>\n<li>接下来步骤和MD5算法相同</li>\n</ol>\n<h4 id=\"代码示例：-1\"><a href=\"#代码示例：-1\" class=\"headerlink\" title=\"代码示例：\"></a>代码示例：</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">public class Demo01 &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t\n\t\ttry &#123;\n\t\t\t&#x2F;&#x2F; 注册BouncyCastle提供的通知类对象BouncyCastleProvider\n\t\t\tSecurity.addProvider(new BouncyCastleProvider());\n\t\t\t\n\t\t\t&#x2F;&#x2F; 获取RipeMD160算法的&quot;消息摘要对象&quot;(加密对象)\n\t\t\tMessageDigest md &#x3D; MessageDigest.getInstance(&quot;RipeMD160&quot;);\n\t\t\t\n\t\t\t&#x2F;&#x2F; 更新原始数据\n\t\t\tmd.update(&quot;HelloWord&quot;.getBytes());\n\t\t\t\n\t\t\t&#x2F;&#x2F; 获取信息摘要(加密)\n\t\t\tbyte[] result &#x3D; md.digest();\n\t\t\t\n\t\t\t&#x2F;&#x2F; 消息摘要的字节长度和内容\n\t\t\tSystem.out.println(result.length); &#x2F;&#x2F; 160位&#x3D;20字节\n\t\t\tSystem.out.println(Arrays.toString(result));\n\t\t\t\n\t\t\t&#x2F;&#x2F; 16进制内容字符串\n\t\t\tString hex &#x3D; new BigInteger(1,result).toString(16);\n\t\t\tSystem.out.println(hex.length()); &#x2F;&#x2F; 20字节&#x3D;40字符\n\t\t\tSystem.out.println(hex);\n\t\t\t\n\t\t&#125; catch (NoSuchAlgorithmException e) &#123;\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<p>使用哈希口令时，还要注意防止彩虹表攻击。</p>\n<p>什么事彩虹表呢？如果只拿到MD5，从MD5反推明文口令，只能使用暴力穷举的方法。</p>\n<p>然而黑客并不笨，暴力穷举会消耗大量的算力和时间。但是，如果有一个预先计算好的常用口令和它们的MD5的对照表：</p>\n<table>\n<thead>\n<tr>\n<th>常用口令</th>\n<th>MD5</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>hello123</td>\n<td>f30aa7a662c728b7407c54ae6bfd27d1</td>\n</tr>\n<tr>\n<td>12345678</td>\n<td>25d55ad283aa400af464c76d713c07ad</td>\n</tr>\n<tr>\n<td>passw0rd</td>\n<td>bed128365216c019988915ed3add75fb</td>\n</tr>\n<tr>\n<td>19700101</td>\n<td>570da6d5277a646f6552b8832012f5dc</td>\n</tr>\n<tr>\n<td>…</td>\n<td>…</td>\n</tr>\n<tr>\n<td>20201231</td>\n<td>6879c0ae9117b50074ce0a0d4c843060</td>\n</tr>\n</tbody></table>\n<p>这个表就是彩虹表。如果用户使用了常用口令，黑客从MD5以下就能反查到原始口令：</p>\n<p>bob的MD5：<code>f30aa7a662c728b7407c54ae6bfd27d1</code>，原始口令：<code>hello123</code></p>\n<p>这就是为什么不要使用常用密码，以及不要使用生日作为密码的原因。</p>\n<p>即使用户使用了常用口令，我们也可以采取措施来地狱彩虹表攻击，方法是对每个口令额外增加随机数，这个方法称之为加盐（salt）：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">digest &#x3D; md5(salt+inputPassword)</code></pre>\n\n<p>经过加盐处理的数据库表，内容如下：</p>\n<table>\n<thead>\n<tr>\n<th>username</th>\n<th>salt</th>\n<th>password</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bob</td>\n<td>H1r0a</td>\n<td>a5022319ff4c56955e22a74abcc2c210</td>\n</tr>\n</tbody></table>\n<p>加盐的目的在于使黑客的彩虹表失效，即使用户使用常用口令，也无法从MD5反推原始口令。</p>\n<h2 id=\"Hmac算法\"><a href=\"#Hmac算法\" class=\"headerlink\" title=\"Hmac算法\"></a>Hmac算法</h2><p>Hmac算法就是一种基于迷药的消息认证码算法，它的全称是Hash-based Message Authentication Code，是一种更安全的消息摘要算法。</p>\n<p>Hmac算法总是和某种哈希算法配合起来用的。例如，我们使用MD5算法，对应的就是HmacMD5算法，它相当于“加盐”的MD5：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">HmacMD5 ≈ md5(secure_random_key, input)</code></pre>\n\n<p>因此，HmacMD5可以看做带有一个安全的key的MD5。使用HmacMD5而不是用MD5家salt，有如下好处：</p>\n<ul>\n<li>HmacMD5使用的key长度是64字节，更安全；</li>\n<li>Hmac是标准算法，同时适用与SHA-1等其他哈希算法；</li>\n<li>Hmac输出和原有的哈希算法长度一致。</li>\n</ul>\n<p>可见，Hmac本质上就是把key混入摘要的算法。验证此哈希时，除了原始的输入数据，还要提供key。</p>\n<p>为了保证安全，我们不会自己制定key，而是通过Java标准库的KeyGenerator生成一个安全的随机的key。下面是使用HmacMD5的代码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import java.math.BigInteger;\nimport javax.crypto.*;\npublic class Main &#123;\n    public static void main(String[] args) throws Exception &#123;\n        KeyGenerator keyGen &#x3D; KeyGenerator.getInstance(&quot;HmacMD5&quot;);\n        SecretKey key &#x3D; keyGen.generateKey();\n        &#x2F;&#x2F; 打印随机生成的key:\n        byte[] skey &#x3D; key.getEncoded();\n        System.out.println(new BigInteger(1, skey).toString(16));\n        Mac mac &#x3D; Mac.getInstance(&quot;HmacMD5&quot;);\n        mac.init(key);\n        mac.update(&quot;HelloWorld&quot;.getBytes(&quot;UTF-8&quot;));\n        byte[] result &#x3D; mac.doFinal();\n        System.out.println(new BigInteger(1, result).toString(16));\n    &#125;\n&#125;</code></pre>\n\n<p>和MD5相比，使用HmacMD5的步骤是：</p>\n<ol>\n<li>通过名称<code>HmacMD5</code>获取<code>KeyGenerator</code>实例；</li>\n<li>通过<code>KeyGenerator</code>创建一个<code>SecretKey</code>实例；</li>\n<li>通过名称<code>HmacMD5</code>获取<code>Mac</code>实例；</li>\n<li>用<code>SecretKey</code>初始化<code>Mac</code>实例；</li>\n<li>对<code>Mac</code>实例反复调用<code>update(byte[])</code>输入数据；</li>\n<li>调用<code>Mac</code>实例的<code>doFinal()</code>获取最终的哈希值。</li>\n</ol>\n<p>我们可以用Hmac算法取代原有的自定义的加盐算法，因此，存储用户名和口令的数据库结构如下：</p>\n<table>\n<thead>\n<tr>\n<th>username</th>\n<th>secret_key (64 bytes)</th>\n<th>password</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bob</td>\n<td>a8c06e05f92e…5e16</td>\n<td>7e0387872a57c85ef6dddbaa12f376de</td>\n</tr>\n</tbody></table>\n<p>有了Hmac计算的哈希和<code>SecretKey</code>，我们想要验证怎么办？这时，<code>SecretKey</code>不能从<code>KeyGenerator</code>生成，而是从一个<code>byte[]</code>数组恢复：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import java.util.Arrays;\nimport javax.crypto.*;\nimport javax.crypto.spec.*;\npublic class Main &#123;\n    public static void main(String[] args) throws Exception &#123;\n        byte[] hkey &#x3D; new byte[] &#123; 106, 70, -110, 125, 39, -20, 52, 56, 85, 9, -19, -72, 52, -53, 52, -45, -6, 119, -63,\n                30, 20, -83, -28, 77, 98, 109, -32, -76, 121, -106, 0, -74, -107, -114, -45, 104, -104, -8, 2, 121, 6,\n                97, -18, -13, -63, -30, -125, -103, -80, -46, 113, -14, 68, 32, -46, 101, -116, -104, -81, -108, 122,\n                89, -106, -109 &#125;;\n\n        SecretKey key &#x3D; new SecretKeySpec(hkey, &quot;HmacMD5&quot;);\n        Mac mac &#x3D; Mac.getInstance(&quot;HmacMD5&quot;);\n        mac.init(key);\n        mac.update(&quot;HelloWorld&quot;.getBytes(&quot;UTF-8&quot;));\n        byte[] result &#x3D; mac.doFinal();\n        System.out.println(Arrays.toString(result));\n        &#x2F;&#x2F; [126, 59, 37, 63, 73, 90, 111, -96, -77, 15, 82, -74, 122, -55, -67, 54]\n    &#125;</code></pre>\n\n<p>恢复<code>SecretKey</code>的语句就是<code>new SecretKeySpec(hkey, &quot;HmacMD5&quot;)</code>。</p>\n<p>Hmac算法是一种标准的基于密钥的哈希算法，可以配合MD5、SHA-1等哈希算法，计算的摘要长度和原摘要算法长度相同。</p>\n<h2 id=\"对称加密算法\"><a href=\"#对称加密算法\" class=\"headerlink\" title=\"对称加密算法\"></a>对称加密算法</h2><p>对称加密算法就是传统的用一个密码进行加密和解密。</p>\n<p>常用的对称加密算法有:</p>\n<ol>\n<li>DES</li>\n</ol>\n<p>已破解，不再安全，基本没有企业在用，是对称加密算法的及时，具有学习价值。</p>\n<p>密钥长度56（JDK）、56/64（BC）。</p>\n<ol start=\"2\">\n<li>3DES</li>\n</ol>\n<p>早于AES出现来替代DES。</p>\n<p>计算密钥时间太长、加密效率不高，所以也基本上不用。</p>\n<p>密钥长度112/168（JDK）、128/192（BC）。</p>\n<ol start=\"3\">\n<li>AES</li>\n</ol>\n<p><strong>最常用的对称加密算法</strong></p>\n<p>密钥建立时间短、灵敏性好、内存需求低。</p>\n<p>实际使用中，使用工作模式为CTR（最好用BC去实现），此工作模式需要引入IV参数（16位的字节数组）。</p>\n<p>秘钥长度128/192/256，其中192与256需要配置无政策限制权限文件（JDK6）</p>\n<p>填充模式最常用的两种PKCS5Padding和PKCS7Padding，其中后者只有BC独有。</p>\n<ol start=\"4\">\n<li>IDEA</li>\n</ol>\n<p>常用的电子邮件加密算法。</p>\n<p>工作模式只有ECB。密钥长度128位。</p>\n<ol start=\"5\">\n<li>PBE</li>\n</ol>\n<p>综合了消息摘要算法和对称加密算法，最常见的是PBEWithMD5AndDES。</p>\n<p>工作模式只有CBC（已丧失安全性，不推荐使用），所以PBE也不推荐使用了。</p>\n<h3 id=\"加密模式\"><a href=\"#加密模式\" class=\"headerlink\" title=\"加密模式\"></a>加密模式</h3><table>\n<thead>\n<tr>\n<th>加密模式(英文）</th>\n<th>加密模式（中文）</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Electronic Code Book(ECB)</td>\n<td>电子密码本模式</td>\n<td>最基本的加密模式，也就是通常理解的加密，相同的明文将永远加密成相同的密文，无初始向量，容易受到密码本重放攻击，一般情况下很少用</td>\n</tr>\n<tr>\n<td>Cipher Block Chaining(CBC)</td>\n<td>密码分组链接模式</td>\n<td>明文被加密前要与前面的密文进行异或运算后再加密，因此只要选择不同的初始向量，相同的密文加密后会形成不同的密文，这是目前应用最广泛的模式。CBC加密后的密文是上下文相关的，但明文的错误不会传递到后续分组，但如果一个分组丢失，后面的分组将全部作废(同步错误)。</td>\n</tr>\n<tr>\n<td>Cipher Feedback Mode(CFB)</td>\n<td>加密反馈模式</td>\n<td>类似于自同步序列密码，分组加密后，按8位分组将密文和明文进行移位异或后得到输出同时反馈回移位寄存器，优点最小可以按字节进行加解密，也可以是n位的，CFB也是上下文相关的，CFB模式下，明文的一个错误会影响后面的密文(错误扩散)。</td>\n</tr>\n<tr>\n<td>Output Feedback Mode(OFB)</td>\n<td>输出反馈模式</td>\n<td>将分组密码作为同步序列密码运行，和CFB相似，不过OFB用的是前一个n位密文输出分组反馈回移位寄存器，OFB没有错误扩散问题。</td>\n</tr>\n</tbody></table>\n<h3 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h3><p>对称加密算法使用同一个密钥进行加密和解密，常用算法有DES、AES和IDEA等；</p>\n<p>密钥长度由算法设计决定，AES的秘钥长度是128/192/256位；</p>\n<p>使用对称加密算法需要指定算法名称、工作模式和填充模式。</p>\n<h2 id=\"口令加密算法\"><a href=\"#口令加密算法\" class=\"headerlink\" title=\"口令加密算法\"></a>口令加密算法</h2><p>对称加密算法决定了口令必须是固定长度，然后对明文进行分块加密。又因为安全需求，口令长度往往都是128位以上，即至少16个字符。</p>\n<p>但是我们平时使用的加密软件，输入6位、8位都可以，难道加密方式不一样？</p>\n<p>实际上用户输入的口令并不能直接作为AES的秘钥进行加密（除非长度恰好是128/192/256位），并且用户输入的口令一般都有规律，安全性远远不如安全随机数产生的随机口令。因此，用户输入的口令，通常还需要使用PBE算法，采用随机数杂凑计算出真正的密钥，再进行加密。</p>\n<p>PBE就是Password Based Encryption的缩写，它的作用如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">key &#x3D; generate(userPassword, secureRandomPassword);</code></pre>\n\n<p>PBE的作用就是把用户输入的口令和一个安全随机的口令采用杂凑后计算出真正的密钥。以AES密钥为例，我们让用户输入一个口令，然后生成一个随机数，通过PBE算法计算出真正的AES口令，在进行加密，代码如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class Main &#123;\n    public static void main(String[] args) throws Exception &#123;\n        &#x2F;&#x2F; 把BouncyCastle作为Provider添加到java.security:\n        Security.addProvider(new BouncyCastleProvider());\n        &#x2F;&#x2F; 原文:\n        String message &#x3D; &quot;Hello, world!&quot;;\n        &#x2F;&#x2F; 加密口令:\n        String password &#x3D; &quot;hello12345&quot;;\n        &#x2F;&#x2F; 16 bytes随机Salt:\n        byte[] salt &#x3D; SecureRandom.getInstanceStrong().generateSeed(16);\n        System.out.printf(&quot;salt: %032x\\n&quot;, new BigInteger(1, salt));\n        &#x2F;&#x2F; 加密:\n        byte[] data &#x3D; message.getBytes(&quot;UTF-8&quot;);\n        byte[] encrypted &#x3D; encrypt(password, salt, data);\n        System.out.println(&quot;encrypted: &quot; + Base64.getEncoder().encodeToString(encrypted));\n        &#x2F;&#x2F; 解密:\n        byte[] decrypted &#x3D; decrypt(password, salt, encrypted);\n        System.out.println(&quot;decrypted: &quot; + new String(decrypted, &quot;UTF-8&quot;));\n    &#125;\n\n    &#x2F;&#x2F; 加密:\n    public static byte[] encrypt(String password, byte[] salt, byte[] input) throws GeneralSecurityException &#123;\n        PBEKeySpec keySpec &#x3D; new PBEKeySpec(password.toCharArray());\n        SecretKeyFactory skeyFactory &#x3D; SecretKeyFactory.getInstance(&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;);\n        SecretKey skey &#x3D; skeyFactory.generateSecret(keySpec);\n        PBEParameterSpec pbeps &#x3D; new PBEParameterSpec(salt, 1000);\n        Cipher cipher &#x3D; Cipher.getInstance(&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;);\n        cipher.init(Cipher.ENCRYPT_MODE, skey, pbeps);\n        return cipher.doFinal(input);\n    &#125;\n\n    &#x2F;&#x2F; 解密:\n    public static byte[] decrypt(String password, byte[] salt, byte[] input) throws GeneralSecurityException &#123;\n        PBEKeySpec keySpec &#x3D; new PBEKeySpec(password.toCharArray());\n        SecretKeyFactory skeyFactory &#x3D; SecretKeyFactory.getInstance(&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;);\n        SecretKey skey &#x3D; skeyFactory.generateSecret(keySpec);\n        PBEParameterSpec pbeps &#x3D; new PBEParameterSpec(salt, 1000);\n        Cipher cipher &#x3D; Cipher.getInstance(&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;);\n        cipher.init(Cipher.DECRYPT_MODE, skey, pbeps);\n        return cipher.doFinal(input);\n    &#125;\n&#125;</code></pre>\n\n<p>使用PBE时，我们还需要引入BouncyCastle，并指定算法是<code>PBEwithSHA1and128bitAES-CBC-BC</code>。观察代码，实际上真正的AES密钥是调用<code>Cipher</code>的<code>init()</code>方法时同时传入<code>SecretKey</code>和<code>PBEParameterSpec</code>实现的。在创建<code>PBEParameterSpec</code>的时候，我们还指定了循环次数<code>1000</code>，循环次数越多，暴力破解需要的计算量就越大。</p>\n<p>如果我们把salt和循环次数固定，就得到了一个通用的“口令”加密软件。如果我们把随机生成的salt存储在U盘，就得到了一个“口令”加<strong>USB Key</strong>的加密软件，它的好处在于，及时用户使用了一个非常弱的口令，没有USB Key仍然无法解密，因为USB Key存储的随机数密钥安全性非常高。</p>\n<h3 id=\"小结：-1\"><a href=\"#小结：-1\" class=\"headerlink\" title=\"小结：\"></a>小结：</h3><p>PBE算法通过用户口令和安全的随机salt计算出Key，然后再进行加密；</p>\n<p>Key通过口令和安全的随机salt计算得出，大大提高了安全性；</p>\n<p>PBE算法内部使用的仍然是标准对称加密算法（例如AES）。</p>\n<h2 id=\"密钥交换算法\"><a href=\"#密钥交换算法\" class=\"headerlink\" title=\"密钥交换算法\"></a>密钥交换算法</h2><p>根据对称加密算法，我们需要安全的进行传输密钥。</p>\n<p>密钥交换算法即DH算法（Diffle-Hellman算法）解决了密钥在双方不直接传递密钥的情况下完成秘钥交换，这个神奇的交换原理完全由数学理论支持。</p>\n<p>我们来看DH算法交换密钥的步骤。假设甲乙双方需要传递密钥，他们之间可以这么做：</p>\n<ol>\n<li>甲首选选择一个素数<code>p</code>，例如509，底数<code>g</code>，任选，例如5，随机数<code>a</code>，例如123，然后计算<code>A=g^a mod p</code>，结果是215，然后，甲发送<code>p＝509</code>，<code>g=5</code>，<code>A=215</code>给乙；</li>\n<li>乙方收到后，也选择一个随机数<code>b</code>，例如，456，然后计算<code>B=g^b mod p</code>，结果是181，乙再同时计算<code>s=A^b mod p</code>，结果是121；</li>\n<li>乙把计算的<code>B=181</code>发给甲，甲计算<code>s＝B^a mod p</code>的余数，计算结果与乙算出的结果一样，都是121。</li>\n</ol>\n<p>所以最终双方协商出的密钥<code>s</code>是121。注意到这个密钥<code>s</code>并没有在网络上传输。而通过网络传输的<code>p</code>，<code>g</code>，<code>A</code>和<code>B</code>是无法推算出<code>s</code>的，因为实际算法选择的素数是非常大的。</p>\n<p>所以，更确切地说，DH算法是一个密钥协商算法，双方最终协商出一个共同的密钥，而这个密钥不会通过网络传输。</p>\n<p>如果我们把<code>a</code>看成甲的私钥，<code>A</code>看成甲的公钥，<code>b</code>看成乙的私钥，<code>B</code>看成乙的公钥，DH算法的本质就是双方各自生成自己的私钥和公钥，私钥仅对自己可见，然后交换公钥，并根据自己的私钥和对方的公钥，生成最终的密钥<code>secretKey</code>，DH算法通过数学定律保证了双方各自计算出的<code>secretKey</code>是相同的。</p>\n<p>但是DH算法并未解决中间人攻击，即甲乙双方并不能确保与自己通信的是否真的是对方。消除中间人攻击需要其他方法。</p>\n<h2 id=\"非对称加密算法\"><a href=\"#非对称加密算法\" class=\"headerlink\" title=\"非对称加密算法\"></a>非对称加密算法</h2><p> 非对称密钥就是加密和机密使用的不是相同的密钥：只有同一个公钥-私钥对才能正常加解密。                                                                   </p>\n<p>非对称加密的典型算法就是RSA算法，也是使用最广泛的。还有DSA算法，ECC算法，DH算法。</p>\n<p>因为非加密的缺点是运算速度非常慢，比对称加密要慢很多。所以，在实际应用的时候，非对称加密总是和对称加密一起使用。假设小明需要给小红需要传输加密文件，他们首先交换了各自的公钥，然后：</p>\n<ol>\n<li>小明生成一个随机的AES口令，然后用小红的公钥通过RSA加密这个口令，并发给小红；</li>\n<li>小红用自己的RSA私钥解密得到AES口令；</li>\n<li>双方使用这个共享的AES阔领用AES加密通信。</li>\n</ol>\n<p>课件非对称加密实际上应用在第一步，即加密“AES口令”。这也是我们在浏览器中常用的HTTPS协议的做法，即浏览器和服务器先通过RSA交换AES口令，接下来双方通信实际上采用的是速度较快的AES对称加密，而不是缓慢的RSA非对称加密。</p>\n<p>以RSA算法为例，它的密钥有256/512/1024/2048/4096等不同的长度。长度越长，密码强度越大，当然计算速度也越慢。</p>\n<p>如果修改待加密的<code>byte[]</code>数据的大小，可以发现，使用512bit的RSA加密时，明文长度不能超过53字节，使用1024bit的RSA加密时，明文长度不能超过117字节，这也是为什么使用RSA的时候，总是配合AES一起使用，即用AES加密任意长度的明文，用RSA加密AES口令。</p>\n<p>此外，只使用非对称加密算法不能防止中间人攻击。</p>\n<h2 id=\"签名算法\"><a href=\"#签名算法\" class=\"headerlink\" title=\"签名算法\"></a>签名算法</h2><p>如果使用私钥加密，公钥解密，私钥加密得到的密文实际上就是数字签名，要验证这个签名是否正确，只能用私钥持有者的公钥进行解密验证。使用数字签名的目的是为了确认某个信息确实是由某个发送发发送的，任何人都不可能伪造消息，并且，发送方也不能抵赖。</p>\n<p>在实际应用的时候，签名实际上并不是针对原始消息，而是针对原始消息的哈希进行签名，即：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">signature &#x3D; encrypt(privateKey, sha256(message))</code></pre>\n\n<p>对签名进行验证实际上就是对公钥解密：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">hash &#x3D; decrypt(publicKey, signature)</code></pre>\n\n<p>然后把解密后的哈希与原始消息的哈希进行对比。</p>\n<p>因为用户总是使用自己的私钥进行签名，所以，私钥就相当于用户身份。而公钥用来给外部验证用户身份。</p>\n<p>常用数字签名算法有：</p>\n<ul>\n<li>MD5withRSA</li>\n<li>SHA1withRSA</li>\n<li>SHA256withRSA</li>\n</ul>\n<p>他们实际上就是指定某种哈希算法进行RSA签名的方式。</p>\n<p>使用其他公钥，或者验证签名的时候修改原始信息，都无法验证成功。</p>\n<h3 id=\"DSA签名\"><a href=\"#DSA签名\" class=\"headerlink\" title=\"DSA签名\"></a>DSA签名</h3><p>除了RSA可以签名外，还可以使用DSA算法进行签名。DSA是Digital Signature Algorithm的缩写，它使用ElGamal数字签名算法。</p>\n<p>DSA只能配合SHA使用，常用的算法有：</p>\n<ul>\n<li>SHA1withDSA</li>\n<li>SHA256withDSA</li>\n<li>SHA512withDSA</li>\n<li>和RSA数字签名相比，DSA的优点是更快。</li>\n</ul>\n<h3 id=\"ECDSA签名\"><a href=\"#ECDSA签名\" class=\"headerlink\" title=\"ECDSA签名\"></a>ECDSA签名</h3><p>椭圆曲线签名算法ECDSA：Elliptic Curve Digital Signature Algorithm也是一种常用的签名算法，它的特点是可以从私钥推出公钥。比特币的签名算法就采用了ECDSA算法，使用标准椭圆曲线secp256k1。BouncyCastle提供了ECDSA的完整实现。</p>\n<h3 id=\"小结：-2\"><a href=\"#小结：-2\" class=\"headerlink\" title=\"小结：\"></a>小结：</h3><p>数字签名就是用发送方的私钥对原始数据进行签名，只有用发送方公钥才能通过签名验证。</p>\n<p>数字签名用于：</p>\n<ul>\n<li>防止伪造</li>\n<li>防止抵赖</li>\n<li>检测篡改</li>\n</ul>\n<p>常用的数字签名算法包括：MD5withRSA／SHA1withRSA／SHA256withRSA／SHA1withDSA／SHA256withDSA／SHA512withDSA／ECDSA等。</p>\n<h2 id=\"数字证书\"><a href=\"#数字证书\" class=\"headerlink\" title=\"数字证书\"></a>数字证书</h2><p>摘要算法用来确保数据没有被篡改，非对称加密算法可以对数据进行加解密，签名算法可以确保数据完整性和抗否认性，把这些算法集合到一起，并搞一套完善的标准，这就是数字证书。</p>\n<p>因此，数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准。</p>\n<p><strong>数字证书可以防止中间人攻击</strong>，因为它采用链式签名认证，即通过根证书（Root CA）去签名下一级证书，这样层层签名，知道最终的用户证书。而Root CA证书内置于操作系统中，所以，任何经过CA认证的数字证书都可以对其本身进行校验，确保整数本身不是伪造的。</p>\n<p>我们在上网时常用的HTTPS协议就是数字证书的应用。浏览器会自动验证证书的有效性。</p>\n<p>要使用数字证书，首先需要创建证书。正常情况下，一个合法的数字证书需要经过CA签名，这需要认证域名并支付一定的费用。开发的时候，我们可以使用自签名的证书，这种证书可以正常开发调试，但不能对外作为服务使用，因为其他客户端并不认可未经CA签名的证书。</p>\n<p><strong>注意：</strong>数字证书存储的是公钥，以及相关的证书链和算法信息。私钥必须严格保密，如果数字证书对应的私钥泄露，就会造成严重的安全威胁。如果CA证书的私钥泄露，那么该CA证书签发的所有证书将不可信。</p>\n<h3 id=\"小结：-3\"><a href=\"#小结：-3\" class=\"headerlink\" title=\"小结：\"></a>小结：</h3><p>数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、前民等多种功能的一种安全标准。</p>\n<p>数字证书采用链式签名管理，顶级的Root CA证书已内置在操作系统中。</p>\n<p>数字证书存储的是公钥，可以安全公开，而私钥必须严格保密。</p>\n","feature":true,"text":"加密与安全编码算法ASCII码就是一种编码，字母A的编码是16进制的0x41，字母B是0x42，以此类推： 字母 ASCII编码 A 0x41 B 0x42 C 0x43 D 0x44 … … 因为ASCII编码最多只能有127个字符，要相对更多的文字进行编码，就需要用Unico...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[],"tags":[{"name":"加密","slug":"加密","count":1,"path":"api/tags/加密.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">加密与安全</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">编码算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#URL%E7%BC%96%E7%A0%81\"><span class=\"toc-text\">URL编码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Base64%E7%BC%96%E7%A0%81\"><span class=\"toc-text\">Base64编码</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">哈希算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E\"><span class=\"toc-text\">哈希碰撞</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#MD5%E5%92%8CSHA-1%E7%AE%97%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">MD5和SHA-1算法：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4%EF%BC%9A\"><span class=\"toc-text\">基本步骤：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A\"><span class=\"toc-text\">代码示例：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RipeMD-160\"><span class=\"toc-text\">RipeMD-160</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4%EF%BC%9A-1\"><span class=\"toc-text\">基本步骤：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A-1\"><span class=\"toc-text\">代码示例：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Hmac%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">Hmac算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">对称加密算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">加密模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93%EF%BC%9A\"><span class=\"toc-text\">小结：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%A3%E4%BB%A4%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">口令加密算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93%EF%BC%9A-1\"><span class=\"toc-text\">小结：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">密钥交换算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">非对称加密算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">签名算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#DSA%E7%AD%BE%E5%90%8D\"><span class=\"toc-text\">DSA签名</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ECDSA%E7%AD%BE%E5%90%8D\"><span class=\"toc-text\">ECDSA签名</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93%EF%BC%9A-2\"><span class=\"toc-text\">小结：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6\"><span class=\"toc-text\">数字证书</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93%EF%BC%9A-3\"><span class=\"toc-text\">小结：</span></a></li></ol></li></ol></li></ol>","author":{"name":"kiku","slug":"blog-author","avatar":"https://samedi.gitee.io/favicon.png","link":"/","description":"网络运维,linux运维,web渗透","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"访问控制技术","uid":"8d37745125c6a8bb3305654c276ebe67","slug":"访问控制技术","date":"2022-10-31T02:17:00.000Z","updated":"2022-10-31T02:20:09.597Z","comments":true,"path":"api/articles/访问控制技术.json","keywords":null,"cover":"https://pic2.zhimg.com/v2-38269faf6a9edc1e6d6642c03fa8116b_r.jpg","text":"访问控制技术1、主体、客体和访问授权主体：是一个主动的尸体，它包括用户、用户组、终端、主机或一个应用，主体可以访问客体。 客体：是一个被动的实体，对客体的访问要受控，它可以是一个字节、字段、记录、程序、文件，或者是一个处理器、存贮器、网络接点等。 授权访问：指主体访问客体的允许，...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"访问控制","slug":"访问控制","count":1,"path":"api/tags/访问控制.json"}],"author":{"name":"kiku","slug":"blog-author","avatar":"https://samedi.gitee.io/favicon.png","link":"/","description":"网络运维,linux运维,web渗透","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"基础路由协议","uid":"76925a97c21ef31b084f9a5256583291","slug":"基础路由协议","date":"2022-10-12T15:51:50.000Z","updated":"2022-10-12T16:10:44.913Z","comments":true,"path":"api/articles/基础路由协议.json","keywords":null,"cover":"https://img-blog.csdnimg.cn/20210120124736436.jpeg","text":"关于RIP、OSPF和BGP背景路由器最重要的两个功能就是路由和转发，常见的路由算法有三种：RIP、OSPF和BGP。 静态路由算法（非自适应路由算法）：管理员手工配置路由信息。 优点：简便、可靠，在负荷稳定、拓扑变化不大的网络中运行效果很好，广泛用于高度安全性的军事网络和娇小的...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"基础路由协议","slug":"基础路由协议","count":1,"path":"api/categories/基础路由协议.json"}],"tags":[{"name":"路由协议","slug":"路由协议","count":1,"path":"api/tags/路由协议.json"},{"name":"网络","slug":"网络","count":1,"path":"api/tags/网络.json"}],"author":{"name":"kiku","slug":"blog-author","avatar":"https://samedi.gitee.io/favicon.png","link":"/","description":"网络运维,linux运维,web渗透","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}